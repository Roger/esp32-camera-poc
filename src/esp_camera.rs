#![allow(dead_code)]
#![allow(unused_variables)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(improper_ctypes)]

/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const _NEWLIB_VERSION_H__: u32 = 1;
pub const _NEWLIB_VERSION: &'static [u8; 6usize] = b"3.3.0\0";
pub const __NEWLIB__: u32 = 3;
pub const __NEWLIB_MINOR__: u32 = 3;
pub const __NEWLIB_PATCHLEVEL__: u32 = 0;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __ATFILE_VISIBLE: u32 = 1;
pub const __BSD_VISIBLE: u32 = 1;
pub const __GNU_VISIBLE: u32 = 0;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __LARGEFILE_VISIBLE: u32 = 0;
pub const __MISC_VISIBLE: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __SVID_VISIBLE: u32 = 1;
pub const __XSI_VISIBLE: u32 = 0;
pub const __SSP_FORTIFY_LEVEL: u32 = 0;
pub const __have_longlong64: u32 = 1;
pub const __have_long64: u32 = 1;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const ___int_least8_t_defined: u32 = 1;
pub const ___int_least16_t_defined: u32 = 1;
pub const ___int_least32_t_defined: u32 = 1;
pub const ___int_least64_t_defined: u32 = 1;
pub const __int20: u32 = 2;
pub const __int20__: u32 = 2;
pub const __INT8: &'static [u8; 3usize] = b"hh\0";
pub const __INT16: &'static [u8; 2usize] = b"h\0";
pub const __INT64: &'static [u8; 2usize] = b"l\0";
pub const __FAST8: &'static [u8; 3usize] = b"hh\0";
pub const __FAST16: &'static [u8; 2usize] = b"h\0";
pub const __FAST64: &'static [u8; 2usize] = b"l\0";
pub const __LEAST8: &'static [u8; 3usize] = b"hh\0";
pub const __LEAST16: &'static [u8; 2usize] = b"h\0";
pub const __LEAST64: &'static [u8; 2usize] = b"l\0";
pub const __int8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const __int_least8_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const WINT_MIN: u32 = 0;
pub const __NEWLIB_H__: u32 = 1;
pub const _WANT_IO_C99_FORMATS: u32 = 1;
pub const _WANT_IO_LONG_LONG: u32 = 1;
pub const _WANT_IO_POS_ARGS: u32 = 1;
pub const _WANT_REENT_SMALL: u32 = 1;
pub const _REENT_CHECK_VERIFY: u32 = 1;
pub const _MB_LEN_MAX: u32 = 1;
pub const _ICONV_ENABLED: u32 = 1;
pub const HAVE_INITFINI_ARRAY: u32 = 1;
pub const _ATEXIT_DYNAMIC_ALLOC: u32 = 1;
pub const _HAVE_LONG_DOUBLE: u32 = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: u32 = 1;
pub const _LDBL_EQ_DBL: u32 = 1;
pub const _FVWRITE_IN_STREAMIO: u32 = 1;
pub const _FSEEK_OPTIMIZATION: u32 = 1;
pub const _UNBUF_STREAM_OPT: u32 = 1;
pub const _RETARGETABLE_LOCKING: u32 = 1;
pub const _WANT_USE_LONG_TIME_T: u32 = 1;
pub const __OBSOLETE_MATH_DEFAULT: u32 = 1;
pub const __OBSOLETE_MATH: u32 = 1;
pub const __RAND_MAX: u32 = 2147483647;
pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___OFFSETOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _NULL: u32 = 0;
pub const _ATEXIT_SIZE: u32 = 32;
pub const _RAND48_SEED_0: u32 = 13070;
pub const _RAND48_SEED_1: u32 = 43981;
pub const _RAND48_SEED_2: u32 = 4660;
pub const _RAND48_MULT_0: u32 = 58989;
pub const _RAND48_MULT_1: u32 = 57068;
pub const _RAND48_MULT_2: u32 = 5;
pub const _RAND48_ADD: u32 = 11;
pub const _REENT_EMERGENCY_SIZE: u32 = 25;
pub const _REENT_ASCTIME_SIZE: u32 = 26;
pub const _REENT_SIGNAL_SIZE: u32 = 24;
pub const CONFIG_IDF_CMAKE: u32 = 1;
pub const CONFIG_IDF_TARGET_ARCH_XTENSA: u32 = 1;
pub const CONFIG_IDF_TARGET: &'static [u8; 6usize] = b"esp32\0";
pub const CONFIG_IDF_TARGET_ESP32: u32 = 1;
pub const CONFIG_IDF_FIRMWARE_CHIP_ID: u32 = 0;
pub const CONFIG_SDK_TOOLPREFIX: &'static [u8; 18usize] = b"xtensa-esp32-elf-\0";
pub const CONFIG_APP_BUILD_TYPE_APP_2NDBOOT: u32 = 1;
pub const CONFIG_APP_BUILD_GENERATE_BINARIES: u32 = 1;
pub const CONFIG_APP_BUILD_BOOTLOADER: u32 = 1;
pub const CONFIG_APP_BUILD_USE_FLASH_SECTIONS: u32 = 1;
pub const CONFIG_APP_COMPILE_TIME_DATE: u32 = 1;
pub const CONFIG_APP_RETRIEVE_LEN_ELF_SHA: u32 = 16;
pub const CONFIG_BOOTLOADER_OFFSET_IN_FLASH: u32 = 4096;
pub const CONFIG_BOOTLOADER_COMPILER_OPTIMIZATION_SIZE: u32 = 1;
pub const CONFIG_BOOTLOADER_LOG_LEVEL_INFO: u32 = 1;
pub const CONFIG_BOOTLOADER_LOG_LEVEL: u32 = 3;
pub const CONFIG_BOOTLOADER_VDDSDIO_BOOST_1_9V: u32 = 1;
pub const CONFIG_BOOTLOADER_WDT_ENABLE: u32 = 1;
pub const CONFIG_BOOTLOADER_WDT_TIME_MS: u32 = 9000;
pub const CONFIG_BOOTLOADER_RESERVE_RTC_SIZE: u32 = 0;
pub const CONFIG_BOOTLOADER_FLASH_XMC_SUPPORT: u32 = 1;
pub const CONFIG_ESPTOOLPY_BAUD_OTHER_VAL: u32 = 115200;
pub const CONFIG_ESPTOOLPY_FLASHMODE_DIO: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASHMODE: &'static [u8; 4usize] = b"dio\0";
pub const CONFIG_ESPTOOLPY_FLASHFREQ_40M: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASHFREQ: &'static [u8; 4usize] = b"40m\0";
pub const CONFIG_ESPTOOLPY_FLASHSIZE_2MB: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASHSIZE: &'static [u8; 4usize] = b"2MB\0";
pub const CONFIG_ESPTOOLPY_FLASHSIZE_DETECT: u32 = 1;
pub const CONFIG_ESPTOOLPY_BEFORE_RESET: u32 = 1;
pub const CONFIG_ESPTOOLPY_BEFORE: &'static [u8; 14usize] = b"default_reset\0";
pub const CONFIG_ESPTOOLPY_AFTER_RESET: u32 = 1;
pub const CONFIG_ESPTOOLPY_AFTER: &'static [u8; 11usize] = b"hard_reset\0";
pub const CONFIG_ESPTOOLPY_MONITOR_BAUD_115200B: u32 = 1;
pub const CONFIG_ESPTOOLPY_MONITOR_BAUD_OTHER_VAL: u32 = 115200;
pub const CONFIG_ESPTOOLPY_MONITOR_BAUD: u32 = 115200;
pub const CONFIG_PARTITION_TABLE_SINGLE_APP: u32 = 1;
pub const CONFIG_PARTITION_TABLE_CUSTOM_FILENAME: &'static [u8; 15usize] = b"partitions.csv\0";
pub const CONFIG_PARTITION_TABLE_FILENAME: &'static [u8; 25usize] = b"partitions_singleapp.csv\0";
pub const CONFIG_PARTITION_TABLE_OFFSET: u32 = 32768;
pub const CONFIG_PARTITION_TABLE_MD5: u32 = 1;
pub const CONFIG_OV7670_SUPPORT: u32 = 1;
pub const CONFIG_OV7725_SUPPORT: u32 = 1;
pub const CONFIG_OV2640_SUPPORT: u32 = 1;
pub const CONFIG_OV3660_SUPPORT: u32 = 1;
pub const CONFIG_OV5640_SUPPORT: u32 = 1;
pub const CONFIG_SCCB_HARDWARE_I2C_PORT1: u32 = 1;
pub const CONFIG_SCCB_CLK_FREQ: u32 = 100000;
pub const CONFIG_CAMERA_CORE0: u32 = 1;
pub const CONFIG_CAMERA_DMA_BUFFER_SIZE_MAX: u32 = 32768;
pub const CONFIG_COMPILER_OPTIMIZATION_DEFAULT: u32 = 1;
pub const CONFIG_COMPILER_OPTIMIZATION_ASSERTIONS_ENABLE: u32 = 1;
pub const CONFIG_COMPILER_STACK_CHECK_MODE_NONE: u32 = 1;
pub const CONFIG_APPTRACE_DEST_NONE: u32 = 1;
pub const CONFIG_APPTRACE_LOCK_ENABLE: u32 = 1;
pub const CONFIG_BTDM_CTRL_BR_EDR_SCO_DATA_PATH_EFF: u32 = 0;
pub const CONFIG_BTDM_CTRL_PCM_ROLE_EFF: u32 = 0;
pub const CONFIG_BTDM_CTRL_PCM_POLAR_EFF: u32 = 0;
pub const CONFIG_BTDM_CTRL_BLE_MAX_CONN_EFF: u32 = 0;
pub const CONFIG_BTDM_CTRL_BR_EDR_MAX_ACL_CONN_EFF: u32 = 0;
pub const CONFIG_BTDM_CTRL_BR_EDR_MAX_SYNC_CONN_EFF: u32 = 0;
pub const CONFIG_BTDM_CTRL_PINNED_TO_CORE: u32 = 0;
pub const CONFIG_BTDM_BLE_SLEEP_CLOCK_ACCURACY_INDEX_EFF: u32 = 1;
pub const CONFIG_BT_CTRL_MODE_EFF: u32 = 1;
pub const CONFIG_BT_CTRL_BLE_MAX_ACT: u32 = 10;
pub const CONFIG_BT_CTRL_BLE_MAX_ACT_EFF: u32 = 10;
pub const CONFIG_BT_CTRL_BLE_STATIC_ACL_TX_BUF_NB: u32 = 0;
pub const CONFIG_BT_CTRL_PINNED_TO_CORE: u32 = 0;
pub const CONFIG_BT_CTRL_HCI_TL: u32 = 1;
pub const CONFIG_BT_CTRL_ADV_DUP_FILT_MAX: u32 = 30;
pub const CONFIG_BT_CTRL_HW_CCA_EFF: u32 = 0;
pub const CONFIG_BT_CTRL_DFT_TX_POWER_LEVEL_EFF: u32 = 0;
pub const CONFIG_BT_CTRL_BLE_ADV_REPORT_FLOW_CTRL_SUPP: u32 = 1;
pub const CONFIG_BT_CTRL_BLE_ADV_REPORT_FLOW_CTRL_NUM: u32 = 100;
pub const CONFIG_BT_CTRL_BLE_ADV_REPORT_DISCARD_THRSHOLD: u32 = 20;
pub const CONFIG_BT_CTRL_BLE_SCAN_DUPL: u32 = 1;
pub const CONFIG_BT_CTRL_SCAN_DUPL_TYPE: u32 = 0;
pub const CONFIG_BT_CTRL_SCAN_DUPL_CACHE_SIZE: u32 = 100;
pub const CONFIG_BT_CTRL_COEX_PHY_CODED_TX_RX_TLIM_EFF: u32 = 0;
pub const CONFIG_BT_CTRL_SLEEP_MODE_EFF: u32 = 0;
pub const CONFIG_BT_CTRL_SLEEP_CLOCK_EFF: u32 = 0;
pub const CONFIG_BT_CTRL_HCI_TL_EFF: u32 = 1;
pub const CONFIG_BT_RESERVE_DRAM: u32 = 0;
pub const CONFIG_BT_NIMBLE_USE_ESP_TIMER: u32 = 1;
pub const CONFIG_COAP_MBEDTLS_PSK: u32 = 1;
pub const CONFIG_COAP_LOG_DEFAULT_LEVEL: u32 = 0;
pub const CONFIG_ADC_DISABLE_DAC: u32 = 1;
pub const CONFIG_SPI_MASTER_ISR_IN_IRAM: u32 = 1;
pub const CONFIG_SPI_SLAVE_ISR_IN_IRAM: u32 = 1;
pub const CONFIG_EFUSE_CODE_SCHEME_COMPAT_3_4: u32 = 1;
pub const CONFIG_EFUSE_MAX_BLK_LEN: u32 = 192;
pub const CONFIG_ESP_TLS_USING_MBEDTLS: u32 = 1;
pub const CONFIG_ESP32_REV_MIN_0: u32 = 1;
pub const CONFIG_ESP32_REV_MIN: u32 = 0;
pub const CONFIG_ESP32_DPORT_WORKAROUND: u32 = 1;
pub const CONFIG_ESP32_DEFAULT_CPU_FREQ_160: u32 = 1;
pub const CONFIG_ESP32_DEFAULT_CPU_FREQ_MHZ: u32 = 160;
pub const CONFIG_ESP32_TRACEMEM_RESERVE_DRAM: u32 = 0;
pub const CONFIG_ESP32_UNIVERSAL_MAC_ADDRESSES_FOUR: u32 = 1;
pub const CONFIG_ESP32_UNIVERSAL_MAC_ADDRESSES: u32 = 4;
pub const CONFIG_ESP32_ULP_COPROC_RESERVE_MEM: u32 = 0;
pub const CONFIG_ESP32_DEBUG_OCDAWARE: u32 = 1;
pub const CONFIG_ESP32_BROWNOUT_DET: u32 = 1;
pub const CONFIG_ESP32_BROWNOUT_DET_LVL_SEL_0: u32 = 1;
pub const CONFIG_ESP32_BROWNOUT_DET_LVL: u32 = 0;
pub const CONFIG_ESP32_REDUCE_PHY_TX_POWER: u32 = 1;
pub const CONFIG_ESP32_TIME_SYSCALL_USE_RTC_FRC1: u32 = 1;
pub const CONFIG_ESP32_RTC_CLK_SRC_INT_RC: u32 = 1;
pub const CONFIG_ESP32_RTC_CLK_CAL_CYCLES: u32 = 1024;
pub const CONFIG_ESP32_DEEP_SLEEP_WAKEUP_DELAY: u32 = 2000;
pub const CONFIG_ESP32_XTAL_FREQ_40: u32 = 1;
pub const CONFIG_ESP32_XTAL_FREQ: u32 = 40;
pub const CONFIG_ESP32_DPORT_DIS_INTERRUPT_LVL: u32 = 5;
pub const CONFIG_ADC_CAL_EFUSE_TP_ENABLE: u32 = 1;
pub const CONFIG_ADC_CAL_EFUSE_VREF_ENABLE: u32 = 1;
pub const CONFIG_ADC_CAL_LUT_ENABLE: u32 = 1;
pub const CONFIG_ESP_ERR_TO_NAME_LOOKUP: u32 = 1;
pub const CONFIG_ESP_SYSTEM_EVENT_QUEUE_SIZE: u32 = 32;
pub const CONFIG_ESP_SYSTEM_EVENT_TASK_STACK_SIZE: u32 = 2304;
pub const CONFIG_ESP_MAIN_TASK_STACK_SIZE: u32 = 3584;
pub const CONFIG_ESP_IPC_TASK_STACK_SIZE: u32 = 1024;
pub const CONFIG_ESP_IPC_USES_CALLERS_PRIORITY: u32 = 1;
pub const CONFIG_ESP_MINIMAL_SHARED_STACK_SIZE: u32 = 2048;
pub const CONFIG_ESP_CONSOLE_UART_DEFAULT: u32 = 1;
pub const CONFIG_ESP_CONSOLE_UART: u32 = 1;
pub const CONFIG_ESP_CONSOLE_MULTIPLE_UART: u32 = 1;
pub const CONFIG_ESP_CONSOLE_UART_NUM: u32 = 0;
pub const CONFIG_ESP_CONSOLE_UART_BAUDRATE: u32 = 115200;
pub const CONFIG_ESP_INT_WDT: u32 = 1;
pub const CONFIG_ESP_INT_WDT_TIMEOUT_MS: u32 = 300;
pub const CONFIG_ESP_INT_WDT_CHECK_CPU1: u32 = 1;
pub const CONFIG_ESP_TASK_WDT: u32 = 1;
pub const CONFIG_ESP_TASK_WDT_TIMEOUT_S: u32 = 5;
pub const CONFIG_ESP_TASK_WDT_CHECK_IDLE_TASK_CPU0: u32 = 1;
pub const CONFIG_ESP_TASK_WDT_CHECK_IDLE_TASK_CPU1: u32 = 1;
pub const CONFIG_ESP_MAC_ADDR_UNIVERSE_WIFI_STA: u32 = 1;
pub const CONFIG_ESP_MAC_ADDR_UNIVERSE_WIFI_AP: u32 = 1;
pub const CONFIG_ESP_MAC_ADDR_UNIVERSE_BT: u32 = 1;
pub const CONFIG_ESP_MAC_ADDR_UNIVERSE_ETH: u32 = 1;
pub const CONFIG_ETH_ENABLED: u32 = 1;
pub const CONFIG_ETH_USE_ESP32_EMAC: u32 = 1;
pub const CONFIG_ETH_PHY_INTERFACE_RMII: u32 = 1;
pub const CONFIG_ETH_RMII_CLK_INPUT: u32 = 1;
pub const CONFIG_ETH_RMII_CLK_IN_GPIO: u32 = 0;
pub const CONFIG_ETH_DMA_BUFFER_SIZE: u32 = 512;
pub const CONFIG_ETH_DMA_RX_BUFFER_NUM: u32 = 10;
pub const CONFIG_ETH_DMA_TX_BUFFER_NUM: u32 = 10;
pub const CONFIG_ETH_USE_SPI_ETHERNET: u32 = 1;
pub const CONFIG_ESP_EVENT_POST_FROM_ISR: u32 = 1;
pub const CONFIG_ESP_EVENT_POST_FROM_IRAM_ISR: u32 = 1;
pub const CONFIG_ESP_HTTP_CLIENT_ENABLE_HTTPS: u32 = 1;
pub const CONFIG_HTTPD_MAX_REQ_HDR_LEN: u32 = 512;
pub const CONFIG_HTTPD_MAX_URI_LEN: u32 = 512;
pub const CONFIG_HTTPD_ERR_RESP_NO_DELAY: u32 = 1;
pub const CONFIG_HTTPD_PURGE_BUF_LEN: u32 = 32;
pub const CONFIG_ESP_NETIF_IP_LOST_TIMER_INTERVAL: u32 = 120;
pub const CONFIG_ESP_NETIF_TCPIP_LWIP: u32 = 1;
pub const CONFIG_ESP_NETIF_TCPIP_ADAPTER_COMPATIBLE_LAYER: u32 = 1;
pub const CONFIG_ESP_SYSTEM_PANIC_PRINT_REBOOT: u32 = 1;
pub const CONFIG_ESP_SYSTEM_PD_FLASH: u32 = 1;
pub const CONFIG_ESP_TIME_FUNCS_USE_RTC_TIMER: u32 = 1;
pub const CONFIG_ESP_TIME_FUNCS_USE_ESP_TIMER: u32 = 1;
pub const CONFIG_ESP_TIMER_TASK_STACK_SIZE: u32 = 3584;
pub const CONFIG_ESP_TIMER_IMPL_TG0_LAC: u32 = 1;
pub const CONFIG_ESP32_WIFI_STATIC_RX_BUFFER_NUM: u32 = 10;
pub const CONFIG_ESP32_WIFI_DYNAMIC_RX_BUFFER_NUM: u32 = 32;
pub const CONFIG_ESP32_WIFI_DYNAMIC_TX_BUFFER: u32 = 1;
pub const CONFIG_ESP32_WIFI_TX_BUFFER_TYPE: u32 = 1;
pub const CONFIG_ESP32_WIFI_DYNAMIC_TX_BUFFER_NUM: u32 = 32;
pub const CONFIG_ESP32_WIFI_AMPDU_TX_ENABLED: u32 = 1;
pub const CONFIG_ESP32_WIFI_TX_BA_WIN: u32 = 6;
pub const CONFIG_ESP32_WIFI_AMPDU_RX_ENABLED: u32 = 1;
pub const CONFIG_ESP32_WIFI_RX_BA_WIN: u32 = 6;
pub const CONFIG_ESP32_WIFI_NVS_ENABLED: u32 = 1;
pub const CONFIG_ESP32_WIFI_TASK_PINNED_TO_CORE_0: u32 = 1;
pub const CONFIG_ESP32_WIFI_SOFTAP_BEACON_MAX_LEN: u32 = 752;
pub const CONFIG_ESP32_WIFI_MGMT_SBUF_NUM: u32 = 32;
pub const CONFIG_WIFI_LOG_DEFAULT_LEVEL_INFO: u32 = 1;
pub const CONFIG_ESP32_WIFI_IRAM_OPT: u32 = 1;
pub const CONFIG_ESP32_WIFI_RX_IRAM_OPT: u32 = 1;
pub const CONFIG_ESP32_WIFI_ENABLE_WPA3_SAE: u32 = 1;
pub const CONFIG_ESP32_PHY_CALIBRATION_AND_DATA_STORAGE: u32 = 1;
pub const CONFIG_ESP32_PHY_MAX_WIFI_TX_POWER: u32 = 20;
pub const CONFIG_ESP32_PHY_MAX_TX_POWER: u32 = 20;
pub const CONFIG_ESP_COREDUMP_ENABLE_TO_NONE: u32 = 1;
pub const CONFIG_FATFS_CODEPAGE_437: u32 = 1;
pub const CONFIG_FATFS_CODEPAGE: u32 = 437;
pub const CONFIG_FATFS_LFN_NONE: u32 = 1;
pub const CONFIG_FATFS_FS_LOCK: u32 = 0;
pub const CONFIG_FATFS_TIMEOUT_MS: u32 = 10000;
pub const CONFIG_FATFS_PER_FILE_CACHE: u32 = 1;
pub const CONFIG_FMB_COMM_MODE_TCP_EN: u32 = 1;
pub const CONFIG_FMB_TCP_PORT_DEFAULT: u32 = 502;
pub const CONFIG_FMB_TCP_PORT_MAX_CONN: u32 = 5;
pub const CONFIG_FMB_TCP_CONNECTION_TOUT_SEC: u32 = 20;
pub const CONFIG_FMB_COMM_MODE_RTU_EN: u32 = 1;
pub const CONFIG_FMB_COMM_MODE_ASCII_EN: u32 = 1;
pub const CONFIG_FMB_MASTER_TIMEOUT_MS_RESPOND: u32 = 150;
pub const CONFIG_FMB_MASTER_DELAY_MS_CONVERT: u32 = 200;
pub const CONFIG_FMB_QUEUE_LENGTH: u32 = 20;
pub const CONFIG_FMB_PORT_TASK_STACK_SIZE: u32 = 4096;
pub const CONFIG_FMB_SERIAL_BUF_SIZE: u32 = 256;
pub const CONFIG_FMB_SERIAL_ASCII_BITS_PER_SYMB: u32 = 8;
pub const CONFIG_FMB_SERIAL_ASCII_TIMEOUT_RESPOND_MS: u32 = 1000;
pub const CONFIG_FMB_PORT_TASK_PRIO: u32 = 10;
pub const CONFIG_FMB_PORT_TASK_AFFINITY_CPU0: u32 = 1;
pub const CONFIG_FMB_PORT_TASK_AFFINITY: u32 = 0;
pub const CONFIG_FMB_CONTROLLER_SLAVE_ID_SUPPORT: u32 = 1;
pub const CONFIG_FMB_CONTROLLER_SLAVE_ID: u32 = 1122867;
pub const CONFIG_FMB_CONTROLLER_NOTIFY_TIMEOUT: u32 = 20;
pub const CONFIG_FMB_CONTROLLER_NOTIFY_QUEUE_SIZE: u32 = 20;
pub const CONFIG_FMB_CONTROLLER_STACK_SIZE: u32 = 4096;
pub const CONFIG_FMB_EVENT_QUEUE_TIMEOUT: u32 = 20;
pub const CONFIG_FMB_TIMER_GROUP: u32 = 0;
pub const CONFIG_FMB_TIMER_INDEX: u32 = 0;
pub const CONFIG_FMB_MASTER_TIMER_GROUP: u32 = 0;
pub const CONFIG_FMB_MASTER_TIMER_INDEX: u32 = 0;
pub const CONFIG_FREERTOS_NO_AFFINITY: u32 = 2147483647;
pub const CONFIG_FREERTOS_CORETIMER_0: u32 = 1;
pub const CONFIG_FREERTOS_HZ: u32 = 100;
pub const CONFIG_FREERTOS_ASSERT_ON_UNTESTED_FUNCTION: u32 = 1;
pub const CONFIG_FREERTOS_CHECK_STACKOVERFLOW_CANARY: u32 = 1;
pub const CONFIG_FREERTOS_INTERRUPT_BACKTRACE: u32 = 1;
pub const CONFIG_FREERTOS_THREAD_LOCAL_STORAGE_POINTERS: u32 = 1;
pub const CONFIG_FREERTOS_ASSERT_FAIL_ABORT: u32 = 1;
pub const CONFIG_FREERTOS_IDLE_TASK_STACKSIZE: u32 = 2304;
pub const CONFIG_FREERTOS_ISR_STACKSIZE: u32 = 1536;
pub const CONFIG_FREERTOS_MAX_TASK_NAME_LEN: u32 = 16;
pub const CONFIG_FREERTOS_SUPPORT_STATIC_ALLOCATION: u32 = 1;
pub const CONFIG_FREERTOS_TIMER_TASK_PRIORITY: u32 = 1;
pub const CONFIG_FREERTOS_TIMER_TASK_STACK_DEPTH: u32 = 2048;
pub const CONFIG_FREERTOS_TIMER_QUEUE_LENGTH: u32 = 10;
pub const CONFIG_FREERTOS_QUEUE_REGISTRY_SIZE: u32 = 0;
pub const CONFIG_FREERTOS_TASK_FUNCTION_WRAPPER: u32 = 1;
pub const CONFIG_FREERTOS_CHECK_MUTEX_GIVEN_BY_OWNER: u32 = 1;
pub const CONFIG_FREERTOS_DEBUG_OCDAWARE: u32 = 1;
pub const CONFIG_HEAP_POISONING_DISABLED: u32 = 1;
pub const CONFIG_HEAP_TRACING_OFF: u32 = 1;
pub const CONFIG_LOG_DEFAULT_LEVEL_INFO: u32 = 1;
pub const CONFIG_LOG_DEFAULT_LEVEL: u32 = 3;
pub const CONFIG_LOG_COLORS: u32 = 1;
pub const CONFIG_LOG_TIMESTAMP_SOURCE_RTOS: u32 = 1;
pub const CONFIG_LWIP_LOCAL_HOSTNAME: &'static [u8; 10usize] = b"espressif\0";
pub const CONFIG_LWIP_DNS_SUPPORT_MDNS_QUERIES: u32 = 1;
pub const CONFIG_LWIP_TIMERS_ONDEMAND: u32 = 1;
pub const CONFIG_LWIP_MAX_SOCKETS: u32 = 10;
pub const CONFIG_LWIP_SO_REUSE: u32 = 1;
pub const CONFIG_LWIP_SO_REUSE_RXTOALL: u32 = 1;
pub const CONFIG_LWIP_IP4_FRAG: u32 = 1;
pub const CONFIG_LWIP_IP6_FRAG: u32 = 1;
pub const CONFIG_LWIP_ESP_GRATUITOUS_ARP: u32 = 1;
pub const CONFIG_LWIP_GARP_TMR_INTERVAL: u32 = 60;
pub const CONFIG_LWIP_TCPIP_RECVMBOX_SIZE: u32 = 32;
pub const CONFIG_LWIP_DHCP_DOES_ARP_CHECK: u32 = 1;
pub const CONFIG_LWIP_DHCPS: u32 = 1;
pub const CONFIG_LWIP_DHCPS_LEASE_UNIT: u32 = 60;
pub const CONFIG_LWIP_DHCPS_MAX_STATION_NUM: u32 = 8;
pub const CONFIG_LWIP_IPV6: u32 = 1;
pub const CONFIG_LWIP_NETIF_LOOPBACK: u32 = 1;
pub const CONFIG_LWIP_LOOPBACK_MAX_PBUFS: u32 = 8;
pub const CONFIG_LWIP_MAX_ACTIVE_TCP: u32 = 16;
pub const CONFIG_LWIP_MAX_LISTENING_TCP: u32 = 16;
pub const CONFIG_LWIP_TCP_HIGH_SPEED_RETRANSMISSION: u32 = 1;
pub const CONFIG_LWIP_TCP_MAXRTX: u32 = 12;
pub const CONFIG_LWIP_TCP_SYNMAXRTX: u32 = 12;
pub const CONFIG_LWIP_TCP_MSS: u32 = 1440;
pub const CONFIG_LWIP_TCP_TMR_INTERVAL: u32 = 250;
pub const CONFIG_LWIP_TCP_MSL: u32 = 60000;
pub const CONFIG_LWIP_TCP_SND_BUF_DEFAULT: u32 = 5744;
pub const CONFIG_LWIP_TCP_WND_DEFAULT: u32 = 5744;
pub const CONFIG_LWIP_TCP_RECVMBOX_SIZE: u32 = 6;
pub const CONFIG_LWIP_TCP_QUEUE_OOSEQ: u32 = 1;
pub const CONFIG_LWIP_TCP_OVERSIZE_MSS: u32 = 1;
pub const CONFIG_LWIP_TCP_RTO_TIME: u32 = 1500;
pub const CONFIG_LWIP_MAX_UDP_PCBS: u32 = 16;
pub const CONFIG_LWIP_UDP_RECVMBOX_SIZE: u32 = 6;
pub const CONFIG_LWIP_CHECKSUM_CHECK_ICMP: u32 = 1;
pub const CONFIG_LWIP_TCPIP_TASK_STACK_SIZE: u32 = 3072;
pub const CONFIG_LWIP_TCPIP_TASK_AFFINITY_NO_AFFINITY: u32 = 1;
pub const CONFIG_LWIP_TCPIP_TASK_AFFINITY: u32 = 2147483647;
pub const CONFIG_LWIP_IPV6_MEMP_NUM_ND6_QUEUE: u32 = 3;
pub const CONFIG_LWIP_IPV6_ND6_NUM_NEIGHBORS: u32 = 5;
pub const CONFIG_LWIP_ICMP: u32 = 1;
pub const CONFIG_LWIP_MAX_RAW_PCBS: u32 = 16;
pub const CONFIG_LWIP_DHCP_MAX_NTP_SERVERS: u32 = 1;
pub const CONFIG_LWIP_SNTP_UPDATE_DELAY: u32 = 3600000;
pub const CONFIG_LWIP_ESP_LWIP_ASSERT: u32 = 1;
pub const CONFIG_LWIP_HOOK_TCP_ISN_DEFAULT: u32 = 1;
pub const CONFIG_LWIP_HOOK_IP6_ROUTE_NONE: u32 = 1;
pub const CONFIG_LWIP_HOOK_NETCONN_EXT_RESOLVE_NONE: u32 = 1;
pub const CONFIG_MBEDTLS_INTERNAL_MEM_ALLOC: u32 = 1;
pub const CONFIG_MBEDTLS_ASYMMETRIC_CONTENT_LEN: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_IN_CONTENT_LEN: u32 = 16384;
pub const CONFIG_MBEDTLS_SSL_OUT_CONTENT_LEN: u32 = 4096;
pub const CONFIG_MBEDTLS_CERTIFICATE_BUNDLE: u32 = 1;
pub const CONFIG_MBEDTLS_CERTIFICATE_BUNDLE_DEFAULT_FULL: u32 = 1;
pub const CONFIG_MBEDTLS_HARDWARE_AES: u32 = 1;
pub const CONFIG_MBEDTLS_HARDWARE_MPI: u32 = 1;
pub const CONFIG_MBEDTLS_HARDWARE_SHA: u32 = 1;
pub const CONFIG_MBEDTLS_ROM_MD5: u32 = 1;
pub const CONFIG_MBEDTLS_HAVE_TIME: u32 = 1;
pub const CONFIG_MBEDTLS_ECDSA_DETERMINISTIC: u32 = 1;
pub const CONFIG_MBEDTLS_SHA512_C: u32 = 1;
pub const CONFIG_MBEDTLS_TLS_SERVER_AND_CLIENT: u32 = 1;
pub const CONFIG_MBEDTLS_TLS_SERVER: u32 = 1;
pub const CONFIG_MBEDTLS_TLS_CLIENT: u32 = 1;
pub const CONFIG_MBEDTLS_TLS_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_RSA: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_DHE_RSA: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ELLIPTIC_CURVE: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ECDHE_RSA: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ECDH_RSA: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_RENEGOTIATION: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_PROTO_TLS1: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_PROTO_TLS1_1: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_PROTO_TLS1_2: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_ALPN: u32 = 1;
pub const CONFIG_MBEDTLS_CLIENT_SSL_SESSION_TICKETS: u32 = 1;
pub const CONFIG_MBEDTLS_X509_CHECK_KEY_USAGE: u32 = 1;
pub const CONFIG_MBEDTLS_X509_CHECK_EXTENDED_KEY_USAGE: u32 = 1;
pub const CONFIG_MBEDTLS_SERVER_SSL_SESSION_TICKETS: u32 = 1;
pub const CONFIG_MBEDTLS_AES_C: u32 = 1;
pub const CONFIG_MBEDTLS_RC4_DISABLED: u32 = 1;
pub const CONFIG_MBEDTLS_CCM_C: u32 = 1;
pub const CONFIG_MBEDTLS_GCM_C: u32 = 1;
pub const CONFIG_MBEDTLS_PEM_PARSE_C: u32 = 1;
pub const CONFIG_MBEDTLS_PEM_WRITE_C: u32 = 1;
pub const CONFIG_MBEDTLS_X509_CRL_PARSE_C: u32 = 1;
pub const CONFIG_MBEDTLS_X509_CSR_PARSE_C: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_C: u32 = 1;
pub const CONFIG_MBEDTLS_ECDH_C: u32 = 1;
pub const CONFIG_MBEDTLS_ECDSA_C: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP192R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP224R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP256R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP384R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP521R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP192K1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP224K1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP256K1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_BP256R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_BP384R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_BP512R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_CURVE25519_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_NIST_OPTIM: u32 = 1;
pub const CONFIG_MDNS_MAX_SERVICES: u32 = 10;
pub const CONFIG_MDNS_TASK_PRIORITY: u32 = 1;
pub const CONFIG_MDNS_TASK_STACK_SIZE: u32 = 4096;
pub const CONFIG_MDNS_TASK_AFFINITY_CPU0: u32 = 1;
pub const CONFIG_MDNS_TASK_AFFINITY: u32 = 0;
pub const CONFIG_MDNS_SERVICE_ADD_TIMEOUT_MS: u32 = 2000;
pub const CONFIG_MDNS_TIMER_PERIOD_MS: u32 = 100;
pub const CONFIG_MQTT_PROTOCOL_311: u32 = 1;
pub const CONFIG_MQTT_TRANSPORT_SSL: u32 = 1;
pub const CONFIG_MQTT_TRANSPORT_WEBSOCKET: u32 = 1;
pub const CONFIG_MQTT_TRANSPORT_WEBSOCKET_SECURE: u32 = 1;
pub const CONFIG_NEWLIB_STDOUT_LINE_ENDING_CRLF: u32 = 1;
pub const CONFIG_NEWLIB_STDIN_LINE_ENDING_CR: u32 = 1;
pub const CONFIG_OPENSSL_ERROR_STACK: u32 = 1;
pub const CONFIG_OPENSSL_ASSERT_EXIT: u32 = 1;
pub const CONFIG_PTHREAD_TASK_PRIO_DEFAULT: u32 = 5;
pub const CONFIG_PTHREAD_TASK_STACK_SIZE_DEFAULT: u32 = 3072;
pub const CONFIG_PTHREAD_STACK_MIN: u32 = 768;
pub const CONFIG_PTHREAD_DEFAULT_CORE_NO_AFFINITY: u32 = 1;
pub const CONFIG_PTHREAD_TASK_CORE_DEFAULT: i32 = -1;
pub const CONFIG_PTHREAD_TASK_NAME_DEFAULT: &'static [u8; 8usize] = b"pthread\0";
pub const CONFIG_SPI_FLASH_ROM_DRIVER_PATCH: u32 = 1;
pub const CONFIG_SPI_FLASH_DANGEROUS_WRITE_ABORTS: u32 = 1;
pub const CONFIG_SPI_FLASH_YIELD_DURING_ERASE: u32 = 1;
pub const CONFIG_SPI_FLASH_ERASE_YIELD_DURATION_MS: u32 = 20;
pub const CONFIG_SPI_FLASH_ERASE_YIELD_TICKS: u32 = 1;
pub const CONFIG_SPI_FLASH_WRITE_CHUNK_SIZE: u32 = 8192;
pub const CONFIG_SPI_FLASH_SUPPORT_ISSI_CHIP: u32 = 1;
pub const CONFIG_SPI_FLASH_SUPPORT_MXIC_CHIP: u32 = 1;
pub const CONFIG_SPI_FLASH_SUPPORT_GD_CHIP: u32 = 1;
pub const CONFIG_SPI_FLASH_SUPPORT_WINBOND_CHIP: u32 = 1;
pub const CONFIG_SPI_FLASH_ENABLE_ENCRYPTED_READ_WRITE: u32 = 1;
pub const CONFIG_SPIFFS_MAX_PARTITIONS: u32 = 3;
pub const CONFIG_SPIFFS_CACHE: u32 = 1;
pub const CONFIG_SPIFFS_CACHE_WR: u32 = 1;
pub const CONFIG_SPIFFS_PAGE_CHECK: u32 = 1;
pub const CONFIG_SPIFFS_GC_MAX_RUNS: u32 = 10;
pub const CONFIG_SPIFFS_PAGE_SIZE: u32 = 256;
pub const CONFIG_SPIFFS_OBJ_NAME_LEN: u32 = 32;
pub const CONFIG_SPIFFS_USE_MAGIC: u32 = 1;
pub const CONFIG_SPIFFS_USE_MAGIC_LENGTH: u32 = 1;
pub const CONFIG_SPIFFS_META_LENGTH: u32 = 4;
pub const CONFIG_SPIFFS_USE_MTIME: u32 = 1;
pub const CONFIG_WS_TRANSPORT: u32 = 1;
pub const CONFIG_WS_BUFFER_SIZE: u32 = 1024;
pub const CONFIG_UNITY_ENABLE_FLOAT: u32 = 1;
pub const CONFIG_UNITY_ENABLE_DOUBLE: u32 = 1;
pub const CONFIG_UNITY_ENABLE_IDF_TEST_RUNNER: u32 = 1;
pub const CONFIG_VFS_SUPPORT_IO: u32 = 1;
pub const CONFIG_VFS_SUPPORT_DIR: u32 = 1;
pub const CONFIG_VFS_SUPPORT_SELECT: u32 = 1;
pub const CONFIG_VFS_SUPPRESS_SELECT_DEBUG_OUTPUT: u32 = 1;
pub const CONFIG_VFS_SUPPORT_TERMIOS: u32 = 1;
pub const CONFIG_VFS_SEMIHOSTFS_MAX_MOUNT_POINTS: u32 = 1;
pub const CONFIG_VFS_SEMIHOSTFS_HOST_PATH_MAX_LEN: u32 = 128;
pub const CONFIG_WL_SECTOR_SIZE_4096: u32 = 1;
pub const CONFIG_WL_SECTOR_SIZE: u32 = 4096;
pub const CONFIG_WIFI_PROV_SCAN_MAX_ENTRIES: u32 = 16;
pub const CONFIG_WIFI_PROV_AUTOSTOP_TIMEOUT: u32 = 30;
pub const CONFIG_WPA_MBEDTLS_CRYPTO: u32 = 1;
pub const CONFIG_ADC2_DISABLE_DAC: u32 = 1;
pub const CONFIG_BROWNOUT_DET: u32 = 1;
pub const CONFIG_BROWNOUT_DET_LVL_SEL_0: u32 = 1;
pub const CONFIG_COMPILER_OPTIMIZATION_LEVEL_DEBUG: u32 = 1;
pub const CONFIG_CONSOLE_UART_DEFAULT: u32 = 1;
pub const CONFIG_ESP32S2_PANIC_PRINT_REBOOT: u32 = 1;
pub const CONFIG_ESP32_APPTRACE_DEST_NONE: u32 = 1;
pub const CONFIG_ESP32_DEFAULT_PTHREAD_CORE_NO_AFFINITY: u32 = 1;
pub const CONFIG_ESP32_ENABLE_COREDUMP_TO_NONE: u32 = 1;
pub const CONFIG_ESP32_PANIC_PRINT_REBOOT: u32 = 1;
pub const CONFIG_ESP32_PTHREAD_STACK_MIN: u32 = 768;
pub const CONFIG_ESP32_PTHREAD_TASK_NAME_DEFAULT: &'static [u8; 8usize] = b"pthread\0";
pub const CONFIG_ESP32_PTHREAD_TASK_PRIO_DEFAULT: u32 = 5;
pub const CONFIG_ESP32_PTHREAD_TASK_STACK_SIZE_DEFAULT: u32 = 3072;
pub const CONFIG_ESP32_RTC_CLOCK_SOURCE_INTERNAL_RC: u32 = 1;
pub const CONFIG_ESP_GRATUITOUS_ARP: u32 = 1;
pub const CONFIG_FLASHMODE_DIO: u32 = 1;
pub const CONFIG_FOUR_UNIVERSAL_MAC_ADDRESS: u32 = 1;
pub const CONFIG_GARP_TMR_INTERVAL: u32 = 60;
pub const CONFIG_INT_WDT: u32 = 1;
pub const CONFIG_INT_WDT_CHECK_CPU1: u32 = 1;
pub const CONFIG_INT_WDT_TIMEOUT_MS: u32 = 300;
pub const CONFIG_IPC_TASK_STACK_SIZE: u32 = 1024;
pub const CONFIG_LOG_BOOTLOADER_LEVEL_INFO: u32 = 1;
pub const CONFIG_MAIN_TASK_STACK_SIZE: u32 = 3584;
pub const CONFIG_MB_CONTROLLER_NOTIFY_QUEUE_SIZE: u32 = 20;
pub const CONFIG_MB_CONTROLLER_NOTIFY_TIMEOUT: u32 = 20;
pub const CONFIG_MB_CONTROLLER_SLAVE_ID: u32 = 1122867;
pub const CONFIG_MB_CONTROLLER_SLAVE_ID_SUPPORT: u32 = 1;
pub const CONFIG_MB_CONTROLLER_STACK_SIZE: u32 = 4096;
pub const CONFIG_MB_EVENT_QUEUE_TIMEOUT: u32 = 20;
pub const CONFIG_MB_MASTER_DELAY_MS_CONVERT: u32 = 200;
pub const CONFIG_MB_MASTER_TIMEOUT_MS_RESPOND: u32 = 150;
pub const CONFIG_MB_QUEUE_LENGTH: u32 = 20;
pub const CONFIG_MB_SERIAL_BUF_SIZE: u32 = 256;
pub const CONFIG_MB_SERIAL_TASK_PRIO: u32 = 10;
pub const CONFIG_MB_SERIAL_TASK_STACK_SIZE: u32 = 4096;
pub const CONFIG_MB_TIMER_GROUP: u32 = 0;
pub const CONFIG_MB_TIMER_INDEX: u32 = 0;
pub const CONFIG_MONITOR_BAUD_115200B: u32 = 1;
pub const CONFIG_OPTIMIZATION_ASSERTIONS_ENABLED: u32 = 1;
pub const CONFIG_OPTIMIZATION_LEVEL_DEBUG: u32 = 1;
pub const CONFIG_POST_EVENTS_FROM_IRAM_ISR: u32 = 1;
pub const CONFIG_POST_EVENTS_FROM_ISR: u32 = 1;
pub const CONFIG_REDUCE_PHY_TX_POWER: u32 = 1;
pub const CONFIG_SEMIHOSTFS_HOST_PATH_MAX_LEN: u32 = 128;
pub const CONFIG_SEMIHOSTFS_MAX_MOUNT_POINTS: u32 = 1;
pub const CONFIG_SPI_FLASH_WRITING_DANGEROUS_REGIONS_ABORTS: u32 = 1;
pub const CONFIG_STACK_CHECK_NONE: u32 = 1;
pub const CONFIG_SUPPORT_TERMIOS: u32 = 1;
pub const CONFIG_SUPPRESS_SELECT_DEBUG_OUTPUT: u32 = 1;
pub const CONFIG_SYSTEM_EVENT_QUEUE_SIZE: u32 = 32;
pub const CONFIG_SYSTEM_EVENT_TASK_STACK_SIZE: u32 = 2304;
pub const CONFIG_TASK_WDT: u32 = 1;
pub const CONFIG_TASK_WDT_CHECK_IDLE_TASK_CPU0: u32 = 1;
pub const CONFIG_TASK_WDT_CHECK_IDLE_TASK_CPU1: u32 = 1;
pub const CONFIG_TASK_WDT_TIMEOUT_S: u32 = 5;
pub const CONFIG_TCPIP_RECVMBOX_SIZE: u32 = 32;
pub const CONFIG_TCPIP_TASK_AFFINITY_NO_AFFINITY: u32 = 1;
pub const CONFIG_TCPIP_TASK_STACK_SIZE: u32 = 3072;
pub const CONFIG_TCP_MAXRTX: u32 = 12;
pub const CONFIG_TCP_MSL: u32 = 60000;
pub const CONFIG_TCP_MSS: u32 = 1440;
pub const CONFIG_TCP_OVERSIZE_MSS: u32 = 1;
pub const CONFIG_TCP_QUEUE_OOSEQ: u32 = 1;
pub const CONFIG_TCP_RECVMBOX_SIZE: u32 = 6;
pub const CONFIG_TCP_SND_BUF_DEFAULT: u32 = 5744;
pub const CONFIG_TCP_SYNMAXRTX: u32 = 12;
pub const CONFIG_TCP_WND_DEFAULT: u32 = 5744;
pub const CONFIG_TIMER_QUEUE_LENGTH: u32 = 10;
pub const CONFIG_TIMER_TASK_PRIORITY: u32 = 1;
pub const CONFIG_TIMER_TASK_STACK_DEPTH: u32 = 2048;
pub const CONFIG_TIMER_TASK_STACK_SIZE: u32 = 3584;
pub const CONFIG_TOOLPREFIX: &'static [u8; 18usize] = b"xtensa-esp32-elf-\0";
pub const CONFIG_UDP_RECVMBOX_SIZE: u32 = 6;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _LITTLE_ENDIAN: u32 = 1234;
pub const _BIG_ENDIAN: u32 = 4321;
pub const _PDP_ENDIAN: u32 = 3412;
pub const _BYTE_ORDER: u32 = 1234;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const FD_SETSIZE: u32 = 64;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const PTHREAD_SCOPE_PROCESS: u32 = 0;
pub const PTHREAD_SCOPE_SYSTEM: u32 = 1;
pub const PTHREAD_INHERIT_SCHED: u32 = 1;
pub const PTHREAD_EXPLICIT_SCHED: u32 = 2;
pub const PTHREAD_CREATE_DETACHED: u32 = 0;
pub const PTHREAD_CREATE_JOINABLE: u32 = 1;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SORD: u32 = 8192;
pub const __SL64: u32 = 32768;
pub const __SNLK: u32 = 1;
pub const __SWID: u32 = 8192;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const EOF: i32 = -1;
pub const BUFSIZ: u32 = 1024;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const L_tmpnam: u32 = 1024;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const TMP_MAX: u32 = 26;
pub const L_ctermid: u32 = 16;
pub const ESP_OK: u32 = 0;
pub const ESP_FAIL: i32 = -1;
pub const ESP_ERR_NO_MEM: u32 = 257;
pub const ESP_ERR_INVALID_ARG: u32 = 258;
pub const ESP_ERR_INVALID_STATE: u32 = 259;
pub const ESP_ERR_INVALID_SIZE: u32 = 260;
pub const ESP_ERR_NOT_FOUND: u32 = 261;
pub const ESP_ERR_NOT_SUPPORTED: u32 = 262;
pub const ESP_ERR_TIMEOUT: u32 = 263;
pub const ESP_ERR_INVALID_RESPONSE: u32 = 264;
pub const ESP_ERR_INVALID_CRC: u32 = 265;
pub const ESP_ERR_INVALID_VERSION: u32 = 266;
pub const ESP_ERR_INVALID_MAC: u32 = 267;
pub const ESP_ERR_WIFI_BASE: u32 = 12288;
pub const ESP_ERR_MESH_BASE: u32 = 16384;
pub const ESP_ERR_FLASH_BASE: u32 = 24576;
pub const ESP_ERR_HW_CRYPTO_BASE: u32 = 49152;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const ESP_INTR_FLAG_LEVEL1: u32 = 2;
pub const ESP_INTR_FLAG_LEVEL2: u32 = 4;
pub const ESP_INTR_FLAG_LEVEL3: u32 = 8;
pub const ESP_INTR_FLAG_LEVEL4: u32 = 16;
pub const ESP_INTR_FLAG_LEVEL5: u32 = 32;
pub const ESP_INTR_FLAG_LEVEL6: u32 = 64;
pub const ESP_INTR_FLAG_NMI: u32 = 128;
pub const ESP_INTR_FLAG_SHARED: u32 = 256;
pub const ESP_INTR_FLAG_EDGE: u32 = 512;
pub const ESP_INTR_FLAG_IRAM: u32 = 1024;
pub const ESP_INTR_FLAG_INTRDISABLED: u32 = 2048;
pub const ESP_INTR_FLAG_LOWMED: u32 = 14;
pub const ESP_INTR_FLAG_HIGH: u32 = 240;
pub const ESP_INTR_FLAG_LEVELMASK: u32 = 254;
pub const ETS_INTERNAL_TIMER0_INTR_SOURCE: i32 = -1;
pub const ETS_INTERNAL_TIMER1_INTR_SOURCE: i32 = -2;
pub const ETS_INTERNAL_TIMER2_INTR_SOURCE: i32 = -3;
pub const ETS_INTERNAL_SW0_INTR_SOURCE: i32 = -4;
pub const ETS_INTERNAL_SW1_INTR_SOURCE: i32 = -5;
pub const ETS_INTERNAL_PROFILING_INTR_SOURCE: i32 = -6;
pub const ETS_INTERNAL_INTR_SOURCE_OFF: u32 = 6;
pub const BIT31: u32 = 2147483648;
pub const BIT30: u32 = 1073741824;
pub const BIT29: u32 = 536870912;
pub const BIT28: u32 = 268435456;
pub const BIT27: u32 = 134217728;
pub const BIT26: u32 = 67108864;
pub const BIT25: u32 = 33554432;
pub const BIT24: u32 = 16777216;
pub const BIT23: u32 = 8388608;
pub const BIT22: u32 = 4194304;
pub const BIT21: u32 = 2097152;
pub const BIT20: u32 = 1048576;
pub const BIT19: u32 = 524288;
pub const BIT18: u32 = 262144;
pub const BIT17: u32 = 131072;
pub const BIT16: u32 = 65536;
pub const BIT15: u32 = 32768;
pub const BIT14: u32 = 16384;
pub const BIT13: u32 = 8192;
pub const BIT12: u32 = 4096;
pub const BIT11: u32 = 2048;
pub const BIT10: u32 = 1024;
pub const BIT9: u32 = 512;
pub const BIT8: u32 = 256;
pub const BIT7: u32 = 128;
pub const BIT6: u32 = 64;
pub const BIT5: u32 = 32;
pub const BIT4: u32 = 16;
pub const BIT3: u32 = 8;
pub const BIT2: u32 = 4;
pub const BIT1: u32 = 2;
pub const BIT0: u32 = 1;
pub const BIT63: i64 = -9223372036854775808;
pub const BIT62: u64 = 4611686018427387904;
pub const BIT61: u64 = 2305843009213693952;
pub const BIT60: u64 = 1152921504606846976;
pub const BIT59: u64 = 576460752303423488;
pub const BIT58: u64 = 288230376151711744;
pub const BIT57: u64 = 144115188075855872;
pub const BIT56: u64 = 72057594037927936;
pub const BIT55: u64 = 36028797018963968;
pub const BIT54: u64 = 18014398509481984;
pub const BIT53: u64 = 9007199254740992;
pub const BIT52: u64 = 4503599627370496;
pub const BIT51: u64 = 2251799813685248;
pub const BIT50: u64 = 1125899906842624;
pub const BIT49: u64 = 562949953421312;
pub const BIT48: u64 = 281474976710656;
pub const BIT47: u64 = 140737488355328;
pub const BIT46: u64 = 70368744177664;
pub const BIT45: u64 = 35184372088832;
pub const BIT44: u64 = 17592186044416;
pub const BIT43: u64 = 8796093022208;
pub const BIT42: u64 = 4398046511104;
pub const BIT41: u64 = 2199023255552;
pub const BIT40: u64 = 1099511627776;
pub const BIT39: u64 = 549755813888;
pub const BIT38: u64 = 274877906944;
pub const BIT37: u64 = 137438953472;
pub const BIT36: u64 = 68719476736;
pub const BIT35: u64 = 34359738368;
pub const BIT34: u64 = 17179869184;
pub const BIT33: u64 = 8589934592;
pub const BIT32: u64 = 4294967296;
pub const PRO_CPU_NUM: u32 = 0;
pub const APP_CPU_NUM: u32 = 1;
pub const SOC_MAX_CONTIGUOUS_RAM_SIZE: u32 = 4194304;
pub const DR_REG_DPORT_BASE: u32 = 1072693248;
pub const DR_REG_AES_BASE: u32 = 1072697344;
pub const DR_REG_RSA_BASE: u32 = 1072701440;
pub const DR_REG_SHA_BASE: u32 = 1072705536;
pub const DR_REG_FLASH_MMU_TABLE_PRO: u32 = 1072758784;
pub const DR_REG_FLASH_MMU_TABLE_APP: u32 = 1072766976;
pub const DR_REG_DPORT_END: u32 = 1072775164;
pub const DR_REG_UART_BASE: u32 = 1072955392;
pub const DR_REG_SPI1_BASE: u32 = 1072963584;
pub const DR_REG_SPI0_BASE: u32 = 1072967680;
pub const DR_REG_GPIO_BASE: u32 = 1072971776;
pub const DR_REG_GPIO_SD_BASE: u32 = 1072975616;
pub const DR_REG_FE2_BASE: u32 = 1072975872;
pub const DR_REG_FE_BASE: u32 = 1072979968;
pub const DR_REG_FRC_TIMER_BASE: u32 = 1072984064;
pub const DR_REG_RTCCNTL_BASE: u32 = 1072988160;
pub const DR_REG_RTCIO_BASE: u32 = 1072989184;
pub const DR_REG_SENS_BASE: u32 = 1072990208;
pub const DR_REG_RTC_I2C_BASE: u32 = 1072991232;
pub const DR_REG_IO_MUX_BASE: u32 = 1072992256;
pub const DR_REG_HINF_BASE: u32 = 1073000448;
pub const DR_REG_UHCI1_BASE: u32 = 1073004544;
pub const DR_REG_I2S_BASE: u32 = 1073016832;
pub const DR_REG_UART1_BASE: u32 = 1073020928;
pub const DR_REG_BT_BASE: u32 = 1073025024;
pub const DR_REG_I2C_EXT_BASE: u32 = 1073033216;
pub const DR_REG_UHCI0_BASE: u32 = 1073037312;
pub const DR_REG_SLCHOST_BASE: u32 = 1073041408;
pub const DR_REG_RMT_BASE: u32 = 1073045504;
pub const DR_REG_PCNT_BASE: u32 = 1073049600;
pub const DR_REG_SLC_BASE: u32 = 1073053696;
pub const DR_REG_LEDC_BASE: u32 = 1073057792;
pub const DR_REG_EFUSE_BASE: u32 = 1073061888;
pub const DR_REG_SPI_ENCRYPT_BASE: u32 = 1073065984;
pub const DR_REG_NRX_BASE: u32 = 1073073152;
pub const DR_REG_BB_BASE: u32 = 1073074176;
pub const DR_REG_PWM_BASE: u32 = 1073078272;
pub const DR_REG_TIMERGROUP0_BASE: u32 = 1073082368;
pub const DR_REG_TIMERGROUP1_BASE: u32 = 1073086464;
pub const DR_REG_RTCMEM0_BASE: u32 = 1073090560;
pub const DR_REG_RTCMEM1_BASE: u32 = 1073094656;
pub const DR_REG_RTCMEM2_BASE: u32 = 1073098752;
pub const DR_REG_SPI2_BASE: u32 = 1073102848;
pub const DR_REG_SPI3_BASE: u32 = 1073106944;
pub const DR_REG_SYSCON_BASE: u32 = 1073111040;
pub const DR_REG_APB_CTRL_BASE: u32 = 1073111040;
pub const DR_REG_I2C1_EXT_BASE: u32 = 1073115136;
pub const DR_REG_SDMMC_BASE: u32 = 1073119232;
pub const DR_REG_EMAC_BASE: u32 = 1073123328;
pub const DR_REG_CAN_BASE: u32 = 1073131520;
pub const DR_REG_PWM1_BASE: u32 = 1073135616;
pub const DR_REG_I2S1_BASE: u32 = 1073139712;
pub const DR_REG_UART2_BASE: u32 = 1073143808;
pub const DR_REG_PWM2_BASE: u32 = 1073147904;
pub const DR_REG_PWM3_BASE: u32 = 1073152000;
pub const PERIPHS_SPI_ENCRYPT_BASEADDR: u32 = 1073065984;
pub const APB_CLK_FREQ_ROM: u32 = 26000000;
pub const CPU_CLK_FREQ_ROM: u32 = 26000000;
pub const APB_CLK_FREQ: u32 = 80000000;
pub const REF_CLK_FREQ: u32 = 1000000;
pub const UART_CLK_FREQ: u32 = 80000000;
pub const WDT_CLK_FREQ: u32 = 80000000;
pub const TIMER_CLK_FREQ: u32 = 5000000;
pub const SPI_CLK_DIV: u32 = 4;
pub const TICKS_PER_US_ROM: u32 = 26;
pub const GPIO_MATRIX_DELAY_NS: u32 = 25;
pub const SOC_DROM_LOW: u32 = 1061158912;
pub const SOC_DROM_HIGH: u32 = 1065353216;
pub const SOC_DRAM_LOW: u32 = 1073405952;
pub const SOC_DRAM_HIGH: u32 = 1073741824;
pub const SOC_IROM_LOW: u32 = 1074593792;
pub const SOC_IROM_HIGH: u32 = 1077936128;
pub const SOC_IROM_MASK_LOW: u32 = 1073741824;
pub const SOC_IROM_MASK_HIGH: u32 = 1074155264;
pub const SOC_CACHE_PRO_LOW: u32 = 1074200576;
pub const SOC_CACHE_PRO_HIGH: u32 = 1074233344;
pub const SOC_CACHE_APP_LOW: u32 = 1074233344;
pub const SOC_CACHE_APP_HIGH: u32 = 1074266112;
pub const SOC_IRAM_LOW: u32 = 1074266112;
pub const SOC_IRAM_HIGH: u32 = 1074397184;
pub const SOC_RTC_IRAM_LOW: u32 = 1074528256;
pub const SOC_RTC_IRAM_HIGH: u32 = 1074536448;
pub const SOC_RTC_DRAM_LOW: u32 = 1073217536;
pub const SOC_RTC_DRAM_HIGH: u32 = 1073225728;
pub const SOC_RTC_DATA_LOW: u32 = 1342177280;
pub const SOC_RTC_DATA_HIGH: u32 = 1342185472;
pub const SOC_EXTRAM_DATA_LOW: u32 = 1065353216;
pub const SOC_EXTRAM_DATA_HIGH: u32 = 1069547520;
pub const SOC_EXTRAM_DATA_SIZE: u32 = 4194304;
pub const SOC_DIRAM_IRAM_LOW: u32 = 1074397184;
pub const SOC_DIRAM_IRAM_HIGH: u32 = 1074528256;
pub const SOC_DIRAM_DRAM_LOW: u32 = 1073610752;
pub const SOC_DIRAM_DRAM_HIGH: u32 = 1073741824;
pub const SOC_DIRAM_INVERTED: u32 = 1;
pub const SOC_DMA_LOW: u32 = 1073405952;
pub const SOC_DMA_HIGH: u32 = 1073741824;
pub const SOC_BYTE_ACCESSIBLE_LOW: u32 = 1073283072;
pub const SOC_BYTE_ACCESSIBLE_HIGH: u32 = 1073741824;
pub const SOC_MEM_INTERNAL_LOW: u32 = 1073283072;
pub const SOC_MEM_INTERNAL_HIGH: u32 = 1074536448;
pub const SOC_ROM_STACK_START: u32 = 1073626912;
pub const ETS_WIFI_MAC_INTR_SOURCE: u32 = 0;
pub const ETS_WIFI_MAC_NMI_SOURCE: u32 = 1;
pub const ETS_WIFI_BB_INTR_SOURCE: u32 = 2;
pub const ETS_BT_MAC_INTR_SOURCE: u32 = 3;
pub const ETS_BT_BB_INTR_SOURCE: u32 = 4;
pub const ETS_BT_BB_NMI_SOURCE: u32 = 5;
pub const ETS_RWBT_INTR_SOURCE: u32 = 6;
pub const ETS_RWBLE_INTR_SOURCE: u32 = 7;
pub const ETS_RWBT_NMI_SOURCE: u32 = 8;
pub const ETS_RWBLE_NMI_SOURCE: u32 = 9;
pub const ETS_SLC0_INTR_SOURCE: u32 = 10;
pub const ETS_SLC1_INTR_SOURCE: u32 = 11;
pub const ETS_UHCI0_INTR_SOURCE: u32 = 12;
pub const ETS_UHCI1_INTR_SOURCE: u32 = 13;
pub const ETS_TG0_T0_LEVEL_INTR_SOURCE: u32 = 14;
pub const ETS_TG0_T1_LEVEL_INTR_SOURCE: u32 = 15;
pub const ETS_TG0_WDT_LEVEL_INTR_SOURCE: u32 = 16;
pub const ETS_TG0_LACT_LEVEL_INTR_SOURCE: u32 = 17;
pub const ETS_TG1_T0_LEVEL_INTR_SOURCE: u32 = 18;
pub const ETS_TG1_T1_LEVEL_INTR_SOURCE: u32 = 19;
pub const ETS_TG1_WDT_LEVEL_INTR_SOURCE: u32 = 20;
pub const ETS_TG1_LACT_LEVEL_INTR_SOURCE: u32 = 21;
pub const ETS_GPIO_INTR_SOURCE: u32 = 22;
pub const ETS_GPIO_NMI_SOURCE: u32 = 23;
pub const ETS_FROM_CPU_INTR0_SOURCE: u32 = 24;
pub const ETS_FROM_CPU_INTR1_SOURCE: u32 = 25;
pub const ETS_FROM_CPU_INTR2_SOURCE: u32 = 26;
pub const ETS_FROM_CPU_INTR3_SOURCE: u32 = 27;
pub const ETS_SPI0_INTR_SOURCE: u32 = 28;
pub const ETS_SPI1_INTR_SOURCE: u32 = 29;
pub const ETS_SPI2_INTR_SOURCE: u32 = 30;
pub const ETS_SPI3_INTR_SOURCE: u32 = 31;
pub const ETS_I2S0_INTR_SOURCE: u32 = 32;
pub const ETS_I2S1_INTR_SOURCE: u32 = 33;
pub const ETS_UART0_INTR_SOURCE: u32 = 34;
pub const ETS_UART1_INTR_SOURCE: u32 = 35;
pub const ETS_UART2_INTR_SOURCE: u32 = 36;
pub const ETS_SDIO_HOST_INTR_SOURCE: u32 = 37;
pub const ETS_ETH_MAC_INTR_SOURCE: u32 = 38;
pub const ETS_PWM0_INTR_SOURCE: u32 = 39;
pub const ETS_PWM1_INTR_SOURCE: u32 = 40;
pub const ETS_PWM2_INTR_SOURCE: u32 = 41;
pub const ETS_PWM3_INTR_SOURCE: u32 = 42;
pub const ETS_LEDC_INTR_SOURCE: u32 = 43;
pub const ETS_EFUSE_INTR_SOURCE: u32 = 44;
pub const ETS_TWAI_INTR_SOURCE: u32 = 45;
pub const ETS_CAN_INTR_SOURCE: u32 = 45;
pub const ETS_RTC_CORE_INTR_SOURCE: u32 = 46;
pub const ETS_RMT_INTR_SOURCE: u32 = 47;
pub const ETS_PCNT_INTR_SOURCE: u32 = 48;
pub const ETS_I2C_EXT0_INTR_SOURCE: u32 = 49;
pub const ETS_I2C_EXT1_INTR_SOURCE: u32 = 50;
pub const ETS_RSA_INTR_SOURCE: u32 = 51;
pub const ETS_SPI1_DMA_INTR_SOURCE: u32 = 52;
pub const ETS_SPI2_DMA_INTR_SOURCE: u32 = 53;
pub const ETS_SPI3_DMA_INTR_SOURCE: u32 = 54;
pub const ETS_WDT_INTR_SOURCE: u32 = 55;
pub const ETS_TIMER1_INTR_SOURCE: u32 = 56;
pub const ETS_TIMER2_INTR_SOURCE: u32 = 57;
pub const ETS_TG0_T0_EDGE_INTR_SOURCE: u32 = 58;
pub const ETS_TG0_T1_EDGE_INTR_SOURCE: u32 = 59;
pub const ETS_TG0_WDT_EDGE_INTR_SOURCE: u32 = 60;
pub const ETS_TG0_LACT_EDGE_INTR_SOURCE: u32 = 61;
pub const ETS_TG1_T0_EDGE_INTR_SOURCE: u32 = 62;
pub const ETS_TG1_T1_EDGE_INTR_SOURCE: u32 = 63;
pub const ETS_TG1_WDT_EDGE_INTR_SOURCE: u32 = 64;
pub const ETS_TG1_LACT_EDGE_INTR_SOURCE: u32 = 65;
pub const ETS_MMU_IA_INTR_SOURCE: u32 = 66;
pub const ETS_MPU_IA_INTR_SOURCE: u32 = 67;
pub const ETS_CACHE_IA_INTR_SOURCE: u32 = 68;
pub const ETS_MAX_INTR_SOURCE: u32 = 69;
pub const ETS_WMAC_INUM: u32 = 0;
pub const ETS_BT_HOST_INUM: u32 = 1;
pub const ETS_WBB_INUM: u32 = 4;
pub const ETS_TG0_T1_INUM: u32 = 10;
pub const ETS_FRC1_INUM: u32 = 22;
pub const ETS_T1_WDT_INUM: u32 = 24;
pub const ETS_MEMACCESS_ERR_INUM: u32 = 25;
pub const ETS_CACHEERR_INUM: u32 = 25;
pub const ETS_DPORT_INUM: u32 = 28;
pub const ETS_SLC_INUM: u32 = 1;
pub const ETS_UART0_INUM: u32 = 5;
pub const ETS_UART1_INUM: u32 = 5;
pub const ETS_INVALID_INUM: u32 = 6;
pub const SOC_CAPS_ECO_VER: u32 = 0;
pub const SOC_CAPS_ECO_VER_MAX: u32 = 3;
pub const SOC_MCPWM_SUPPORTED: u32 = 1;
pub const SOC_SDMMC_HOST_SUPPORTED: u32 = 1;
pub const SOC_BT_SUPPORTED: u32 = 1;
pub const SOC_CLASSIC_BT_SUPPORTED: u32 = 1;
pub const SOC_PCNT_SUPPORTED: u32 = 1;
pub const SOC_SDIO_SLAVE_SUPPORTED: u32 = 1;
pub const SOC_TWAI_SUPPORTED: u32 = 1;
pub const SOC_EMAC_SUPPORTED: u32 = 1;
pub const SOC_RISCV_COPROC_SUPPORTED: u32 = 0;
pub const SOC_CPU_CORES_NUM: u32 = 2;
pub const SOC_ULP_SUPPORTED: u32 = 1;
pub const SOC_RTC_SLOW_MEM_SUPPORTED: u32 = 1;
pub const SOC_CCOMP_TIMER_SUPPORTED: u32 = 1;
pub const SOC_EFUSE_SECURE_BOOT_KEY_DIGESTS: u32 = 1;
pub const SOC_ADC_PERIPH_NUM: u32 = 2;
pub const SOC_ADC_PATT_LEN_MAX: u32 = 16;
pub const SOC_ADC_MAX_CHANNEL_NUM: u32 = 10;
pub const SOC_ADC_MAX_BITWIDTH: u32 = 12;
pub const SOC_ADC_SUPPORT_RTC_CTRL: u32 = 1;
pub const SOC_CPU_BREAKPOINTS_NUM: u32 = 2;
pub const SOC_CPU_WATCHPOINTS_NUM: u32 = 2;
pub const SOC_CPU_WATCHPOINT_SIZE: u32 = 64;
pub const SOC_DAC_PERIPH_NUM: u32 = 2;
pub const SOC_DAC_RESOLUTION: u32 = 8;
pub const SOC_GPIO_PORT: u32 = 1;
pub const SOC_GPIO_PIN_COUNT: u32 = 40;
pub const SOC_GPIO_VALID_GPIO_MASK: u64 = 1095468318719;
pub const SOC_GPIO_VALID_OUTPUT_GPIO_MASK: u64 = 13136560127;
pub const SOC_GPIO_SUPPORT_SLP_SWITCH: u32 = 1;
pub const SOC_I2C_NUM: u32 = 2;
pub const SOC_I2C_FIFO_LEN: u32 = 32;
pub const SOC_I2C_SUPPORT_APB: u32 = 1;
pub const SOC_I2S_NUM: u32 = 2;
pub const SOC_I2S_SUPPORTS_PDM: u32 = 1;
pub const SOC_I2S_SUPPORTS_ADC_DAC: u32 = 1;
pub const SOC_I2S_MAX_BUFFER_SIZE: u32 = 4194304;
pub const SOC_I2S_APLL_MIN_FREQ: u32 = 250000000;
pub const SOC_I2S_APLL_MAX_FREQ: u32 = 500000000;
pub const SOC_I2S_APLL_MIN_RATE: u32 = 10675;
pub const SOC_LEDC_SUPPORT_HS_MODE: u32 = 1;
pub const SOC_LEDC_CHANNEL_NUM: u32 = 8;
pub const SOC_LEDC_TIMER_BIT_WIDE_NUM: u32 = 20;
pub const SOC_MCPWM_PERIPH_NUM: u32 = 2;
pub const SOC_MCPWM_TIMER_NUM: u32 = 3;
pub const SOC_MCPWM_OP_NUM: u32 = 3;
pub const SOC_MCPWM_COMPARATOR_NUM: u32 = 2;
pub const SOC_MCPWM_GENERATOR_NUM: u32 = 2;
pub const SOC_MCPWM_FAULT_SIG_NUM: u32 = 3;
pub const SOC_MPU_CONFIGURABLE_REGIONS_SUPPORTED: u32 = 0;
pub const SOC_MPU_MIN_REGION_SIZE: u32 = 536870912;
pub const SOC_MPU_REGIONS_MAX_NUM: u32 = 8;
pub const SOC_MPU_REGION_RO_SUPPORTED: u32 = 0;
pub const SOC_MPU_REGION_WO_SUPPORTED: u32 = 0;
pub const SOC_PCNT_PORT_NUM: u32 = 1;
pub const SOC_PCNT_UNIT_NUM: u32 = 8;
pub const SOC_PCNT_UNIT_CHANNEL_NUM: u32 = 2;
pub const SOC_RMT_CHANNEL_MEM_WORDS: u32 = 64;
pub const SOC_RMT_TX_CHANNELS_NUM: u32 = 8;
pub const SOC_RMT_RX_CHANNELS_NUM: u32 = 8;
pub const SOC_RMT_CHANNELS_NUM: u32 = 8;
pub const SOC_RMT_SUPPORT_REF_TICK: u32 = 1;
pub const SOC_RMT_SOURCE_CLK_INDEPENDENT: u32 = 1;
pub const SOC_RTCIO_PIN_COUNT: u32 = 18;
pub const SOC_RTCIO_INPUT_OUTPUT_SUPPORTED: u32 = 1;
pub const SOC_RTCIO_HOLD_SUPPORTED: u32 = 1;
pub const SOC_RTCIO_WAKE_SUPPORTED: u32 = 1;
pub const SOC_SIGMADELTA_NUM: u32 = 1;
pub const SOC_SIGMADELTA_CHANNEL_NUM: u32 = 8;
pub const SOC_SPI_PERIPH_NUM: u32 = 3;
pub const SOC_SPI_DMA_CHAN_NUM: u32 = 2;
pub const SOC_SPI_MAXIMUM_BUFFER_SIZE: u32 = 64;
pub const SOC_SPI_MAX_PRE_DIVIDER: u32 = 8192;
pub const SOC_SPI_SUPPORT_AS_CS: u32 = 1;
pub const SOC_TIMER_GROUP_COUNTER_BIT_WIDTH: u32 = 64;
pub const SOC_TIMER_GROUP_PRESCALE_BIT_WIDTH: u32 = 16;
pub const SOC_TIMER_GROUPS: u32 = 2;
pub const SOC_TIMER_GROUP_TIMERS_PER_GROUP: u32 = 2;
pub const SOC_TIMER_GROUP_TOTAL_TIMERS: u32 = 4;
pub const SOC_TOUCH_SENSOR_NUM: u32 = 10;
pub const SOC_TOUCH_PAD_MEASURE_WAIT_MAX: u32 = 255;
pub const SOC_TOUCH_PAD_THRESHOLD_MAX: u32 = 0;
pub const SOC_TOUCH_PAD_WAKE_SUPPORTED: u32 = 1;
pub const SOC_TWAI_BRP_MIN: u32 = 2;
pub const SOC_TWAI_BRP_MAX: u32 = 128;
pub const SOC_TWAI_SUPPORT_MULTI_ADDRESS_LAYOUT: u32 = 1;
pub const SOC_UART_NUM: u32 = 3;
pub const SOC_UART_SUPPORT_REF_TICK: u32 = 1;
pub const SOC_UART_FIFO_LEN: u32 = 128;
pub const SOC_UART_BITRATE_MAX: u32 = 5000000;
pub const SOC_SPIRAM_SUPPORTED: u32 = 1;
pub const SOC_SHA_SUPPORT_PARALLEL_ENG: u32 = 1;
pub const SOC_SHA_SUPPORT_SHA1: u32 = 1;
pub const SOC_SHA_SUPPORT_SHA256: u32 = 1;
pub const SOC_SHA_SUPPORT_SHA384: u32 = 1;
pub const SOC_SHA_SUPPORT_SHA512: u32 = 1;
pub const SOC_RSA_MAX_BIT_LEN: u32 = 4096;
pub const SOC_AES_SUPPORT_AES_128: u32 = 1;
pub const SOC_AES_SUPPORT_AES_192: u32 = 1;
pub const SOC_AES_SUPPORT_AES_256: u32 = 1;
pub const SOC_PHY_DIG_REGS_MEM_SIZE: u32 = 84;
pub const SOC_PM_SUPPORT_EXT_WAKEUP: u32 = 1;
pub const SOC_CAN_SUPPORTED: u32 = 1;
pub const CAN_BRP_MIN: u32 = 2;
pub const CAN_BRP_MAX: u32 = 128;
pub const CAN_SUPPORT_MULTI_ADDRESS_LAYOUT: u32 = 1;
pub const SOC_BLE_DONT_UPDATE_OWN_RPA: u32 = 1;
pub const SLP_OE_V: u32 = 1;
pub const SLP_OE_S: u32 = 0;
pub const SLP_SEL_V: u32 = 1;
pub const SLP_SEL_S: u32 = 1;
pub const SLP_PD_V: u32 = 1;
pub const SLP_PD_S: u32 = 2;
pub const SLP_PU_V: u32 = 1;
pub const SLP_PU_S: u32 = 3;
pub const SLP_IE_V: u32 = 1;
pub const SLP_IE_S: u32 = 4;
pub const SLP_DRV: u32 = 3;
pub const SLP_DRV_V: u32 = 3;
pub const SLP_DRV_S: u32 = 5;
pub const FUN_PD_V: u32 = 1;
pub const FUN_PD_S: u32 = 7;
pub const FUN_PU_V: u32 = 1;
pub const FUN_PU_S: u32 = 8;
pub const FUN_IE_V: u32 = 1;
pub const FUN_IE_S: u32 = 9;
pub const FUN_DRV: u32 = 3;
pub const FUN_DRV_V: u32 = 3;
pub const FUN_DRV_S: u32 = 10;
pub const MCU_SEL: u32 = 7;
pub const MCU_SEL_V: u32 = 7;
pub const MCU_SEL_S: u32 = 12;
pub const PIN_FUNC_GPIO: u32 = 2;
pub const SPI_CLK_GPIO_NUM: u32 = 6;
pub const SPI_CS0_GPIO_NUM: u32 = 11;
pub const SPI_Q_GPIO_NUM: u32 = 7;
pub const SPI_D_GPIO_NUM: u32 = 8;
pub const SPI_WP_GPIO_NUM: u32 = 10;
pub const SPI_HD_GPIO_NUM: u32 = 9;
pub const PIN_CTRL: u32 = 1072992256;
pub const CLK_OUT3: u32 = 15;
pub const CLK_OUT3_V: u32 = 15;
pub const CLK_OUT3_S: u32 = 8;
pub const CLK_OUT3_M: u32 = 3840;
pub const CLK_OUT2: u32 = 15;
pub const CLK_OUT2_V: u32 = 15;
pub const CLK_OUT2_S: u32 = 4;
pub const CLK_OUT2_M: u32 = 240;
pub const CLK_OUT1: u32 = 15;
pub const CLK_OUT1_V: u32 = 15;
pub const CLK_OUT1_S: u32 = 0;
pub const CLK_OUT1_M: u32 = 15;
pub const PERIPHS_IO_MUX_GPIO0_U: u32 = 1072992324;
pub const IO_MUX_GPIO0_REG: u32 = 1072992324;
pub const FUNC_GPIO0_EMAC_TX_CLK: u32 = 5;
pub const FUNC_GPIO0_GPIO0: u32 = 2;
pub const FUNC_GPIO0_CLK_OUT1: u32 = 1;
pub const FUNC_GPIO0_GPIO0_0: u32 = 0;
pub const PERIPHS_IO_MUX_U0TXD_U: u32 = 1072992392;
pub const IO_MUX_GPIO1_REG: u32 = 1072992392;
pub const FUNC_U0TXD_EMAC_RXD2: u32 = 5;
pub const FUNC_U0TXD_GPIO1: u32 = 2;
pub const FUNC_U0TXD_CLK_OUT3: u32 = 1;
pub const FUNC_U0TXD_U0TXD: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO2_U: u32 = 1072992320;
pub const IO_MUX_GPIO2_REG: u32 = 1072992320;
pub const FUNC_GPIO2_SD_DATA0: u32 = 4;
pub const FUNC_GPIO2_HS2_DATA0: u32 = 3;
pub const FUNC_GPIO2_GPIO2: u32 = 2;
pub const FUNC_GPIO2_HSPIWP: u32 = 1;
pub const FUNC_GPIO2_GPIO2_0: u32 = 0;
pub const PERIPHS_IO_MUX_U0RXD_U: u32 = 1072992388;
pub const IO_MUX_GPIO3_REG: u32 = 1072992388;
pub const FUNC_U0RXD_GPIO3: u32 = 2;
pub const FUNC_U0RXD_CLK_OUT2: u32 = 1;
pub const FUNC_U0RXD_U0RXD: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO4_U: u32 = 1072992328;
pub const IO_MUX_GPIO4_REG: u32 = 1072992328;
pub const FUNC_GPIO4_EMAC_TX_ER: u32 = 5;
pub const FUNC_GPIO4_SD_DATA1: u32 = 4;
pub const FUNC_GPIO4_HS2_DATA1: u32 = 3;
pub const FUNC_GPIO4_GPIO4: u32 = 2;
pub const FUNC_GPIO4_HSPIHD: u32 = 1;
pub const FUNC_GPIO4_GPIO4_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO5_U: u32 = 1072992364;
pub const IO_MUX_GPIO5_REG: u32 = 1072992364;
pub const FUNC_GPIO5_EMAC_RX_CLK: u32 = 5;
pub const FUNC_GPIO5_HS1_DATA6: u32 = 3;
pub const FUNC_GPIO5_GPIO5: u32 = 2;
pub const FUNC_GPIO5_VSPICS0: u32 = 1;
pub const FUNC_GPIO5_GPIO5_0: u32 = 0;
pub const PERIPHS_IO_MUX_SD_CLK_U: u32 = 1072992352;
pub const IO_MUX_GPIO6_REG: u32 = 1072992352;
pub const FUNC_SD_CLK_U1CTS: u32 = 4;
pub const FUNC_SD_CLK_HS1_CLK: u32 = 3;
pub const FUNC_SD_CLK_GPIO6: u32 = 2;
pub const FUNC_SD_CLK_SPICLK: u32 = 1;
pub const FUNC_SD_CLK_SD_CLK: u32 = 0;
pub const PERIPHS_IO_MUX_SD_DATA0_U: u32 = 1072992356;
pub const IO_MUX_GPIO7_REG: u32 = 1072992356;
pub const FUNC_SD_DATA0_U2RTS: u32 = 4;
pub const FUNC_SD_DATA0_HS1_DATA0: u32 = 3;
pub const FUNC_SD_DATA0_GPIO7: u32 = 2;
pub const FUNC_SD_DATA0_SPIQ: u32 = 1;
pub const FUNC_SD_DATA0_SD_DATA0: u32 = 0;
pub const PERIPHS_IO_MUX_SD_DATA1_U: u32 = 1072992360;
pub const IO_MUX_GPIO8_REG: u32 = 1072992360;
pub const FUNC_SD_DATA1_U2CTS: u32 = 4;
pub const FUNC_SD_DATA1_HS1_DATA1: u32 = 3;
pub const FUNC_SD_DATA1_GPIO8: u32 = 2;
pub const FUNC_SD_DATA1_SPID: u32 = 1;
pub const FUNC_SD_DATA1_SD_DATA1: u32 = 0;
pub const PERIPHS_IO_MUX_SD_DATA2_U: u32 = 1072992340;
pub const IO_MUX_GPIO9_REG: u32 = 1072992340;
pub const FUNC_SD_DATA2_U1RXD: u32 = 4;
pub const FUNC_SD_DATA2_HS1_DATA2: u32 = 3;
pub const FUNC_SD_DATA2_GPIO9: u32 = 2;
pub const FUNC_SD_DATA2_SPIHD: u32 = 1;
pub const FUNC_SD_DATA2_SD_DATA2: u32 = 0;
pub const PERIPHS_IO_MUX_SD_DATA3_U: u32 = 1072992344;
pub const IO_MUX_GPIO10_REG: u32 = 1072992344;
pub const FUNC_SD_DATA3_U1TXD: u32 = 4;
pub const FUNC_SD_DATA3_HS1_DATA3: u32 = 3;
pub const FUNC_SD_DATA3_GPIO10: u32 = 2;
pub const FUNC_SD_DATA3_SPIWP: u32 = 1;
pub const FUNC_SD_DATA3_SD_DATA3: u32 = 0;
pub const PERIPHS_IO_MUX_SD_CMD_U: u32 = 1072992348;
pub const IO_MUX_GPIO11_REG: u32 = 1072992348;
pub const FUNC_SD_CMD_U1RTS: u32 = 4;
pub const FUNC_SD_CMD_HS1_CMD: u32 = 3;
pub const FUNC_SD_CMD_GPIO11: u32 = 2;
pub const FUNC_SD_CMD_SPICS0: u32 = 1;
pub const FUNC_SD_CMD_SD_CMD: u32 = 0;
pub const PERIPHS_IO_MUX_MTDI_U: u32 = 1072992308;
pub const IO_MUX_GPIO12_REG: u32 = 1072992308;
pub const FUNC_MTDI_EMAC_TXD3: u32 = 5;
pub const FUNC_MTDI_SD_DATA2: u32 = 4;
pub const FUNC_MTDI_HS2_DATA2: u32 = 3;
pub const FUNC_MTDI_GPIO12: u32 = 2;
pub const FUNC_MTDI_HSPIQ: u32 = 1;
pub const FUNC_MTDI_MTDI: u32 = 0;
pub const PERIPHS_IO_MUX_MTCK_U: u32 = 1072992312;
pub const IO_MUX_GPIO13_REG: u32 = 1072992312;
pub const FUNC_MTCK_EMAC_RX_ER: u32 = 5;
pub const FUNC_MTCK_SD_DATA3: u32 = 4;
pub const FUNC_MTCK_HS2_DATA3: u32 = 3;
pub const FUNC_MTCK_GPIO13: u32 = 2;
pub const FUNC_MTCK_HSPID: u32 = 1;
pub const FUNC_MTCK_MTCK: u32 = 0;
pub const PERIPHS_IO_MUX_MTMS_U: u32 = 1072992304;
pub const IO_MUX_GPIO14_REG: u32 = 1072992304;
pub const FUNC_MTMS_EMAC_TXD2: u32 = 5;
pub const FUNC_MTMS_SD_CLK: u32 = 4;
pub const FUNC_MTMS_HS2_CLK: u32 = 3;
pub const FUNC_MTMS_GPIO14: u32 = 2;
pub const FUNC_MTMS_HSPICLK: u32 = 1;
pub const FUNC_MTMS_MTMS: u32 = 0;
pub const PERIPHS_IO_MUX_MTDO_U: u32 = 1072992316;
pub const IO_MUX_GPIO15_REG: u32 = 1072992316;
pub const FUNC_MTDO_EMAC_RXD3: u32 = 5;
pub const FUNC_MTDO_SD_CMD: u32 = 4;
pub const FUNC_MTDO_HS2_CMD: u32 = 3;
pub const FUNC_MTDO_GPIO15: u32 = 2;
pub const FUNC_MTDO_HSPICS0: u32 = 1;
pub const FUNC_MTDO_MTDO: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO16_U: u32 = 1072992332;
pub const IO_MUX_GPIO16_REG: u32 = 1072992332;
pub const FUNC_GPIO16_EMAC_CLK_OUT: u32 = 5;
pub const FUNC_GPIO16_U2RXD: u32 = 4;
pub const FUNC_GPIO16_HS1_DATA4: u32 = 3;
pub const FUNC_GPIO16_GPIO16: u32 = 2;
pub const FUNC_GPIO16_GPIO16_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO17_U: u32 = 1072992336;
pub const IO_MUX_GPIO17_REG: u32 = 1072992336;
pub const FUNC_GPIO17_EMAC_CLK_OUT_180: u32 = 5;
pub const FUNC_GPIO17_U2TXD: u32 = 4;
pub const FUNC_GPIO17_HS1_DATA5: u32 = 3;
pub const FUNC_GPIO17_GPIO17: u32 = 2;
pub const FUNC_GPIO17_GPIO17_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO18_U: u32 = 1072992368;
pub const IO_MUX_GPIO18_REG: u32 = 1072992368;
pub const FUNC_GPIO18_HS1_DATA7: u32 = 3;
pub const FUNC_GPIO18_GPIO18: u32 = 2;
pub const FUNC_GPIO18_VSPICLK: u32 = 1;
pub const FUNC_GPIO18_GPIO18_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO19_U: u32 = 1072992372;
pub const IO_MUX_GPIO19_REG: u32 = 1072992372;
pub const FUNC_GPIO19_EMAC_TXD0: u32 = 5;
pub const FUNC_GPIO19_U0CTS: u32 = 3;
pub const FUNC_GPIO19_GPIO19: u32 = 2;
pub const FUNC_GPIO19_VSPIQ: u32 = 1;
pub const FUNC_GPIO19_GPIO19_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO20_U: u32 = 1072992376;
pub const IO_MUX_GPIO20_REG: u32 = 1072992376;
pub const FUNC_GPIO20_GPIO20: u32 = 2;
pub const FUNC_GPIO20_GPIO20_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO21_U: u32 = 1072992380;
pub const IO_MUX_GPIO21_REG: u32 = 1072992380;
pub const FUNC_GPIO21_EMAC_TX_EN: u32 = 5;
pub const FUNC_GPIO21_GPIO21: u32 = 2;
pub const FUNC_GPIO21_VSPIHD: u32 = 1;
pub const FUNC_GPIO21_GPIO21_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO22_U: u32 = 1072992384;
pub const IO_MUX_GPIO22_REG: u32 = 1072992384;
pub const FUNC_GPIO22_EMAC_TXD1: u32 = 5;
pub const FUNC_GPIO22_U0RTS: u32 = 3;
pub const FUNC_GPIO22_GPIO22: u32 = 2;
pub const FUNC_GPIO22_VSPIWP: u32 = 1;
pub const FUNC_GPIO22_GPIO22_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO23_U: u32 = 1072992396;
pub const IO_MUX_GPIO23_REG: u32 = 1072992396;
pub const FUNC_GPIO23_HS1_STROBE: u32 = 3;
pub const FUNC_GPIO23_GPIO23: u32 = 2;
pub const FUNC_GPIO23_VSPID: u32 = 1;
pub const FUNC_GPIO23_GPIO23_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO24_U: u32 = 1072992400;
pub const IO_MUX_GPIO24_REG: u32 = 1072992400;
pub const FUNC_GPIO24_GPIO24: u32 = 2;
pub const FUNC_GPIO24_GPIO24_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO25_U: u32 = 1072992292;
pub const IO_MUX_GPIO25_REG: u32 = 1072992292;
pub const FUNC_GPIO25_EMAC_RXD0: u32 = 5;
pub const FUNC_GPIO25_GPIO25: u32 = 2;
pub const FUNC_GPIO25_GPIO25_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO26_U: u32 = 1072992296;
pub const IO_MUX_GPIO26_REG: u32 = 1072992296;
pub const FUNC_GPIO26_EMAC_RXD1: u32 = 5;
pub const FUNC_GPIO26_GPIO26: u32 = 2;
pub const FUNC_GPIO26_GPIO26_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO27_U: u32 = 1072992300;
pub const IO_MUX_GPIO27_REG: u32 = 1072992300;
pub const FUNC_GPIO27_EMAC_RX_DV: u32 = 5;
pub const FUNC_GPIO27_GPIO27: u32 = 2;
pub const FUNC_GPIO27_GPIO27_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO32_U: u32 = 1072992284;
pub const IO_MUX_GPIO32_REG: u32 = 1072992284;
pub const FUNC_GPIO32_GPIO32: u32 = 2;
pub const FUNC_GPIO32_GPIO32_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO33_U: u32 = 1072992288;
pub const IO_MUX_GPIO33_REG: u32 = 1072992288;
pub const FUNC_GPIO33_GPIO33: u32 = 2;
pub const FUNC_GPIO33_GPIO33_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO34_U: u32 = 1072992276;
pub const IO_MUX_GPIO34_REG: u32 = 1072992276;
pub const FUNC_GPIO34_GPIO34: u32 = 2;
pub const FUNC_GPIO34_GPIO34_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO35_U: u32 = 1072992280;
pub const IO_MUX_GPIO35_REG: u32 = 1072992280;
pub const FUNC_GPIO35_GPIO35: u32 = 2;
pub const FUNC_GPIO35_GPIO35_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO36_U: u32 = 1072992260;
pub const IO_MUX_GPIO36_REG: u32 = 1072992260;
pub const FUNC_GPIO36_GPIO36: u32 = 2;
pub const FUNC_GPIO36_GPIO36_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO37_U: u32 = 1072992264;
pub const IO_MUX_GPIO37_REG: u32 = 1072992264;
pub const FUNC_GPIO37_GPIO37: u32 = 2;
pub const FUNC_GPIO37_GPIO37_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO38_U: u32 = 1072992268;
pub const IO_MUX_GPIO38_REG: u32 = 1072992268;
pub const FUNC_GPIO38_GPIO38: u32 = 2;
pub const FUNC_GPIO38_GPIO38_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO39_U: u32 = 1072992272;
pub const IO_MUX_GPIO39_REG: u32 = 1072992272;
pub const FUNC_GPIO39_GPIO39: u32 = 2;
pub const FUNC_GPIO39_GPIO39_0: u32 = 0;
pub const GPIO_BT_SELECT_REG: u32 = 1072971776;
pub const GPIO_BT_SEL: u32 = 4294967295;
pub const GPIO_BT_SEL_V: u32 = 4294967295;
pub const GPIO_BT_SEL_S: u32 = 0;
pub const GPIO_OUT_REG: u32 = 1072971780;
pub const GPIO_OUT_DATA: u32 = 4294967295;
pub const GPIO_OUT_DATA_V: u32 = 4294967295;
pub const GPIO_OUT_DATA_S: u32 = 0;
pub const GPIO_OUT_W1TS_REG: u32 = 1072971784;
pub const GPIO_OUT_DATA_W1TS: u32 = 4294967295;
pub const GPIO_OUT_DATA_W1TS_V: u32 = 4294967295;
pub const GPIO_OUT_DATA_W1TS_S: u32 = 0;
pub const GPIO_OUT_W1TC_REG: u32 = 1072971788;
pub const GPIO_OUT_DATA_W1TC: u32 = 4294967295;
pub const GPIO_OUT_DATA_W1TC_V: u32 = 4294967295;
pub const GPIO_OUT_DATA_W1TC_S: u32 = 0;
pub const GPIO_OUT1_REG: u32 = 1072971792;
pub const GPIO_OUT1_DATA: u32 = 255;
pub const GPIO_OUT1_DATA_V: u32 = 255;
pub const GPIO_OUT1_DATA_S: u32 = 0;
pub const GPIO_OUT1_W1TS_REG: u32 = 1072971796;
pub const GPIO_OUT1_DATA_W1TS: u32 = 255;
pub const GPIO_OUT1_DATA_W1TS_V: u32 = 255;
pub const GPIO_OUT1_DATA_W1TS_S: u32 = 0;
pub const GPIO_OUT1_W1TC_REG: u32 = 1072971800;
pub const GPIO_OUT1_DATA_W1TC: u32 = 255;
pub const GPIO_OUT1_DATA_W1TC_V: u32 = 255;
pub const GPIO_OUT1_DATA_W1TC_S: u32 = 0;
pub const GPIO_SDIO_SELECT_REG: u32 = 1072971804;
pub const GPIO_SDIO_SEL: u32 = 255;
pub const GPIO_SDIO_SEL_V: u32 = 255;
pub const GPIO_SDIO_SEL_S: u32 = 0;
pub const GPIO_ENABLE_REG: u32 = 1072971808;
pub const GPIO_ENABLE_DATA: u32 = 4294967295;
pub const GPIO_ENABLE_DATA_V: u32 = 4294967295;
pub const GPIO_ENABLE_DATA_S: u32 = 0;
pub const GPIO_ENABLE_W1TS_REG: u32 = 1072971812;
pub const GPIO_ENABLE_DATA_W1TS: u32 = 4294967295;
pub const GPIO_ENABLE_DATA_W1TS_V: u32 = 4294967295;
pub const GPIO_ENABLE_DATA_W1TS_S: u32 = 0;
pub const GPIO_ENABLE_W1TC_REG: u32 = 1072971816;
pub const GPIO_ENABLE_DATA_W1TC: u32 = 4294967295;
pub const GPIO_ENABLE_DATA_W1TC_V: u32 = 4294967295;
pub const GPIO_ENABLE_DATA_W1TC_S: u32 = 0;
pub const GPIO_ENABLE1_REG: u32 = 1072971820;
pub const GPIO_ENABLE1_DATA: u32 = 255;
pub const GPIO_ENABLE1_DATA_V: u32 = 255;
pub const GPIO_ENABLE1_DATA_S: u32 = 0;
pub const GPIO_ENABLE1_W1TS_REG: u32 = 1072971824;
pub const GPIO_ENABLE1_DATA_W1TS: u32 = 255;
pub const GPIO_ENABLE1_DATA_W1TS_V: u32 = 255;
pub const GPIO_ENABLE1_DATA_W1TS_S: u32 = 0;
pub const GPIO_ENABLE1_W1TC_REG: u32 = 1072971828;
pub const GPIO_ENABLE1_DATA_W1TC: u32 = 255;
pub const GPIO_ENABLE1_DATA_W1TC_V: u32 = 255;
pub const GPIO_ENABLE1_DATA_W1TC_S: u32 = 0;
pub const GPIO_STRAP_REG: u32 = 1072971832;
pub const GPIO_STRAPPING: u32 = 65535;
pub const GPIO_STRAPPING_V: u32 = 65535;
pub const GPIO_STRAPPING_S: u32 = 0;
pub const GPIO_IN_REG: u32 = 1072971836;
pub const GPIO_IN_DATA: u32 = 4294967295;
pub const GPIO_IN_DATA_V: u32 = 4294967295;
pub const GPIO_IN_DATA_S: u32 = 0;
pub const GPIO_IN1_REG: u32 = 1072971840;
pub const GPIO_IN1_DATA: u32 = 255;
pub const GPIO_IN1_DATA_V: u32 = 255;
pub const GPIO_IN1_DATA_S: u32 = 0;
pub const GPIO_STATUS_REG: u32 = 1072971844;
pub const GPIO_STATUS_INT: u32 = 4294967295;
pub const GPIO_STATUS_INT_V: u32 = 4294967295;
pub const GPIO_STATUS_INT_S: u32 = 0;
pub const GPIO_STATUS_W1TS_REG: u32 = 1072971848;
pub const GPIO_STATUS_INT_W1TS: u32 = 4294967295;
pub const GPIO_STATUS_INT_W1TS_V: u32 = 4294967295;
pub const GPIO_STATUS_INT_W1TS_S: u32 = 0;
pub const GPIO_STATUS_W1TC_REG: u32 = 1072971852;
pub const GPIO_STATUS_INT_W1TC: u32 = 4294967295;
pub const GPIO_STATUS_INT_W1TC_V: u32 = 4294967295;
pub const GPIO_STATUS_INT_W1TC_S: u32 = 0;
pub const GPIO_STATUS1_REG: u32 = 1072971856;
pub const GPIO_STATUS1_INT: u32 = 255;
pub const GPIO_STATUS1_INT_V: u32 = 255;
pub const GPIO_STATUS1_INT_S: u32 = 0;
pub const GPIO_STATUS1_W1TS_REG: u32 = 1072971860;
pub const GPIO_STATUS1_INT_W1TS: u32 = 255;
pub const GPIO_STATUS1_INT_W1TS_V: u32 = 255;
pub const GPIO_STATUS1_INT_W1TS_S: u32 = 0;
pub const GPIO_STATUS1_W1TC_REG: u32 = 1072971864;
pub const GPIO_STATUS1_INT_W1TC: u32 = 255;
pub const GPIO_STATUS1_INT_W1TC_V: u32 = 255;
pub const GPIO_STATUS1_INT_W1TC_S: u32 = 0;
pub const GPIO_ACPU_INT_REG: u32 = 1072971872;
pub const GPIO_APPCPU_INT: u32 = 4294967295;
pub const GPIO_APPCPU_INT_V: u32 = 4294967295;
pub const GPIO_APPCPU_INT_S: u32 = 0;
pub const GPIO_ACPU_NMI_INT_REG: u32 = 1072971876;
pub const GPIO_APPCPU_NMI_INT: u32 = 4294967295;
pub const GPIO_APPCPU_NMI_INT_V: u32 = 4294967295;
pub const GPIO_APPCPU_NMI_INT_S: u32 = 0;
pub const GPIO_PCPU_INT_REG: u32 = 1072971880;
pub const GPIO_PROCPU_INT: u32 = 4294967295;
pub const GPIO_PROCPU_INT_V: u32 = 4294967295;
pub const GPIO_PROCPU_INT_S: u32 = 0;
pub const GPIO_PCPU_NMI_INT_REG: u32 = 1072971884;
pub const GPIO_PROCPU_NMI_INT: u32 = 4294967295;
pub const GPIO_PROCPU_NMI_INT_V: u32 = 4294967295;
pub const GPIO_PROCPU_NMI_INT_S: u32 = 0;
pub const GPIO_CPUSDIO_INT_REG: u32 = 1072971888;
pub const GPIO_SDIO_INT: u32 = 4294967295;
pub const GPIO_SDIO_INT_V: u32 = 4294967295;
pub const GPIO_SDIO_INT_S: u32 = 0;
pub const GPIO_ACPU_INT1_REG: u32 = 1072971892;
pub const GPIO_APPCPU_INT_H: u32 = 255;
pub const GPIO_APPCPU_INT_H_V: u32 = 255;
pub const GPIO_APPCPU_INT_H_S: u32 = 0;
pub const GPIO_ACPU_NMI_INT1_REG: u32 = 1072971896;
pub const GPIO_APPCPU_NMI_INT_H: u32 = 255;
pub const GPIO_APPCPU_NMI_INT_H_V: u32 = 255;
pub const GPIO_APPCPU_NMI_INT_H_S: u32 = 0;
pub const GPIO_PCPU_INT1_REG: u32 = 1072971900;
pub const GPIO_PROCPU_INT_H: u32 = 255;
pub const GPIO_PROCPU_INT_H_V: u32 = 255;
pub const GPIO_PROCPU_INT_H_S: u32 = 0;
pub const GPIO_PCPU_NMI_INT1_REG: u32 = 1072971904;
pub const GPIO_PROCPU_NMI_INT_H: u32 = 255;
pub const GPIO_PROCPU_NMI_INT_H_V: u32 = 255;
pub const GPIO_PROCPU_NMI_INT_H_S: u32 = 0;
pub const GPIO_CPUSDIO_INT1_REG: u32 = 1072971908;
pub const GPIO_SDIO_INT_H: u32 = 255;
pub const GPIO_SDIO_INT_H_V: u32 = 255;
pub const GPIO_SDIO_INT_H_S: u32 = 0;
pub const GPIO_PIN_INT_ENA: u32 = 31;
pub const GPIO_PIN_INT_ENA_V: u32 = 31;
pub const GPIO_PIN_INT_ENA_S: u32 = 13;
pub const GPIO_PIN_CONFIG: u32 = 3;
pub const GPIO_PIN_CONFIG_V: u32 = 3;
pub const GPIO_PIN_CONFIG_S: u32 = 11;
pub const GPIO_PIN_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN_INT_TYPE: u32 = 7;
pub const GPIO_PIN_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN0_REG: u32 = 1072971912;
pub const GPIO_PIN0_INT_ENA: u32 = 31;
pub const GPIO_PIN0_INT_ENA_V: u32 = 31;
pub const GPIO_PIN0_INT_ENA_S: u32 = 13;
pub const GPIO_PIN0_CONFIG: u32 = 3;
pub const GPIO_PIN0_CONFIG_V: u32 = 3;
pub const GPIO_PIN0_CONFIG_S: u32 = 11;
pub const GPIO_PIN0_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN0_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN0_INT_TYPE: u32 = 7;
pub const GPIO_PIN0_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN0_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN0_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN0_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN1_REG: u32 = 1072971916;
pub const GPIO_PIN1_INT_ENA: u32 = 31;
pub const GPIO_PIN1_INT_ENA_V: u32 = 31;
pub const GPIO_PIN1_INT_ENA_S: u32 = 13;
pub const GPIO_PIN1_CONFIG: u32 = 3;
pub const GPIO_PIN1_CONFIG_V: u32 = 3;
pub const GPIO_PIN1_CONFIG_S: u32 = 11;
pub const GPIO_PIN1_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN1_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN1_INT_TYPE: u32 = 7;
pub const GPIO_PIN1_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN1_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN1_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN1_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN2_REG: u32 = 1072971920;
pub const GPIO_PIN2_INT_ENA: u32 = 31;
pub const GPIO_PIN2_INT_ENA_V: u32 = 31;
pub const GPIO_PIN2_INT_ENA_S: u32 = 13;
pub const GPIO_PIN2_CONFIG: u32 = 3;
pub const GPIO_PIN2_CONFIG_V: u32 = 3;
pub const GPIO_PIN2_CONFIG_S: u32 = 11;
pub const GPIO_PIN2_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN2_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN2_INT_TYPE: u32 = 7;
pub const GPIO_PIN2_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN2_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN2_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN2_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN3_REG: u32 = 1072971924;
pub const GPIO_PIN3_INT_ENA: u32 = 31;
pub const GPIO_PIN3_INT_ENA_V: u32 = 31;
pub const GPIO_PIN3_INT_ENA_S: u32 = 13;
pub const GPIO_PIN3_CONFIG: u32 = 3;
pub const GPIO_PIN3_CONFIG_V: u32 = 3;
pub const GPIO_PIN3_CONFIG_S: u32 = 11;
pub const GPIO_PIN3_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN3_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN3_INT_TYPE: u32 = 7;
pub const GPIO_PIN3_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN3_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN3_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN3_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN4_REG: u32 = 1072971928;
pub const GPIO_PIN4_INT_ENA: u32 = 31;
pub const GPIO_PIN4_INT_ENA_V: u32 = 31;
pub const GPIO_PIN4_INT_ENA_S: u32 = 13;
pub const GPIO_PIN4_CONFIG: u32 = 3;
pub const GPIO_PIN4_CONFIG_V: u32 = 3;
pub const GPIO_PIN4_CONFIG_S: u32 = 11;
pub const GPIO_PIN4_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN4_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN4_INT_TYPE: u32 = 7;
pub const GPIO_PIN4_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN4_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN4_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN4_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN5_REG: u32 = 1072971932;
pub const GPIO_PIN5_INT_ENA: u32 = 31;
pub const GPIO_PIN5_INT_ENA_V: u32 = 31;
pub const GPIO_PIN5_INT_ENA_S: u32 = 13;
pub const GPIO_PIN5_CONFIG: u32 = 3;
pub const GPIO_PIN5_CONFIG_V: u32 = 3;
pub const GPIO_PIN5_CONFIG_S: u32 = 11;
pub const GPIO_PIN5_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN5_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN5_INT_TYPE: u32 = 7;
pub const GPIO_PIN5_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN5_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN5_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN5_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN6_REG: u32 = 1072971936;
pub const GPIO_PIN6_INT_ENA: u32 = 31;
pub const GPIO_PIN6_INT_ENA_V: u32 = 31;
pub const GPIO_PIN6_INT_ENA_S: u32 = 13;
pub const GPIO_PIN6_CONFIG: u32 = 3;
pub const GPIO_PIN6_CONFIG_V: u32 = 3;
pub const GPIO_PIN6_CONFIG_S: u32 = 11;
pub const GPIO_PIN6_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN6_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN6_INT_TYPE: u32 = 7;
pub const GPIO_PIN6_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN6_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN6_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN6_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN7_REG: u32 = 1072971940;
pub const GPIO_PIN7_INT_ENA: u32 = 31;
pub const GPIO_PIN7_INT_ENA_V: u32 = 31;
pub const GPIO_PIN7_INT_ENA_S: u32 = 13;
pub const GPIO_PIN7_CONFIG: u32 = 3;
pub const GPIO_PIN7_CONFIG_V: u32 = 3;
pub const GPIO_PIN7_CONFIG_S: u32 = 11;
pub const GPIO_PIN7_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN7_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN7_INT_TYPE: u32 = 7;
pub const GPIO_PIN7_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN7_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN7_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN7_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN8_REG: u32 = 1072971944;
pub const GPIO_PIN8_INT_ENA: u32 = 31;
pub const GPIO_PIN8_INT_ENA_V: u32 = 31;
pub const GPIO_PIN8_INT_ENA_S: u32 = 13;
pub const GPIO_PIN8_CONFIG: u32 = 3;
pub const GPIO_PIN8_CONFIG_V: u32 = 3;
pub const GPIO_PIN8_CONFIG_S: u32 = 11;
pub const GPIO_PIN8_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN8_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN8_INT_TYPE: u32 = 7;
pub const GPIO_PIN8_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN8_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN8_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN8_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN9_REG: u32 = 1072971948;
pub const GPIO_PIN9_INT_ENA: u32 = 31;
pub const GPIO_PIN9_INT_ENA_V: u32 = 31;
pub const GPIO_PIN9_INT_ENA_S: u32 = 13;
pub const GPIO_PIN9_CONFIG: u32 = 3;
pub const GPIO_PIN9_CONFIG_V: u32 = 3;
pub const GPIO_PIN9_CONFIG_S: u32 = 11;
pub const GPIO_PIN9_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN9_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN9_INT_TYPE: u32 = 7;
pub const GPIO_PIN9_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN9_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN9_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN9_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN10_REG: u32 = 1072971952;
pub const GPIO_PIN10_INT_ENA: u32 = 31;
pub const GPIO_PIN10_INT_ENA_V: u32 = 31;
pub const GPIO_PIN10_INT_ENA_S: u32 = 13;
pub const GPIO_PIN10_CONFIG: u32 = 3;
pub const GPIO_PIN10_CONFIG_V: u32 = 3;
pub const GPIO_PIN10_CONFIG_S: u32 = 11;
pub const GPIO_PIN10_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN10_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN10_INT_TYPE: u32 = 7;
pub const GPIO_PIN10_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN10_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN10_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN10_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN11_REG: u32 = 1072971956;
pub const GPIO_PIN11_INT_ENA: u32 = 31;
pub const GPIO_PIN11_INT_ENA_V: u32 = 31;
pub const GPIO_PIN11_INT_ENA_S: u32 = 13;
pub const GPIO_PIN11_CONFIG: u32 = 3;
pub const GPIO_PIN11_CONFIG_V: u32 = 3;
pub const GPIO_PIN11_CONFIG_S: u32 = 11;
pub const GPIO_PIN11_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN11_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN11_INT_TYPE: u32 = 7;
pub const GPIO_PIN11_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN11_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN11_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN11_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN12_REG: u32 = 1072971960;
pub const GPIO_PIN12_INT_ENA: u32 = 31;
pub const GPIO_PIN12_INT_ENA_V: u32 = 31;
pub const GPIO_PIN12_INT_ENA_S: u32 = 13;
pub const GPIO_PIN12_CONFIG: u32 = 3;
pub const GPIO_PIN12_CONFIG_V: u32 = 3;
pub const GPIO_PIN12_CONFIG_S: u32 = 11;
pub const GPIO_PIN12_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN12_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN12_INT_TYPE: u32 = 7;
pub const GPIO_PIN12_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN12_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN12_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN12_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN13_REG: u32 = 1072971964;
pub const GPIO_PIN13_INT_ENA: u32 = 31;
pub const GPIO_PIN13_INT_ENA_V: u32 = 31;
pub const GPIO_PIN13_INT_ENA_S: u32 = 13;
pub const GPIO_PIN13_CONFIG: u32 = 3;
pub const GPIO_PIN13_CONFIG_V: u32 = 3;
pub const GPIO_PIN13_CONFIG_S: u32 = 11;
pub const GPIO_PIN13_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN13_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN13_INT_TYPE: u32 = 7;
pub const GPIO_PIN13_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN13_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN13_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN13_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN14_REG: u32 = 1072971968;
pub const GPIO_PIN14_INT_ENA: u32 = 31;
pub const GPIO_PIN14_INT_ENA_V: u32 = 31;
pub const GPIO_PIN14_INT_ENA_S: u32 = 13;
pub const GPIO_PIN14_CONFIG: u32 = 3;
pub const GPIO_PIN14_CONFIG_V: u32 = 3;
pub const GPIO_PIN14_CONFIG_S: u32 = 11;
pub const GPIO_PIN14_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN14_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN14_INT_TYPE: u32 = 7;
pub const GPIO_PIN14_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN14_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN14_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN14_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN15_REG: u32 = 1072971972;
pub const GPIO_PIN15_INT_ENA: u32 = 31;
pub const GPIO_PIN15_INT_ENA_V: u32 = 31;
pub const GPIO_PIN15_INT_ENA_S: u32 = 13;
pub const GPIO_PIN15_CONFIG: u32 = 3;
pub const GPIO_PIN15_CONFIG_V: u32 = 3;
pub const GPIO_PIN15_CONFIG_S: u32 = 11;
pub const GPIO_PIN15_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN15_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN15_INT_TYPE: u32 = 7;
pub const GPIO_PIN15_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN15_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN15_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN15_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN16_REG: u32 = 1072971976;
pub const GPIO_PIN16_INT_ENA: u32 = 31;
pub const GPIO_PIN16_INT_ENA_V: u32 = 31;
pub const GPIO_PIN16_INT_ENA_S: u32 = 13;
pub const GPIO_PIN16_CONFIG: u32 = 3;
pub const GPIO_PIN16_CONFIG_V: u32 = 3;
pub const GPIO_PIN16_CONFIG_S: u32 = 11;
pub const GPIO_PIN16_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN16_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN16_INT_TYPE: u32 = 7;
pub const GPIO_PIN16_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN16_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN16_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN16_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN17_REG: u32 = 1072971980;
pub const GPIO_PIN17_INT_ENA: u32 = 31;
pub const GPIO_PIN17_INT_ENA_V: u32 = 31;
pub const GPIO_PIN17_INT_ENA_S: u32 = 13;
pub const GPIO_PIN17_CONFIG: u32 = 3;
pub const GPIO_PIN17_CONFIG_V: u32 = 3;
pub const GPIO_PIN17_CONFIG_S: u32 = 11;
pub const GPIO_PIN17_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN17_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN17_INT_TYPE: u32 = 7;
pub const GPIO_PIN17_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN17_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN17_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN17_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN18_REG: u32 = 1072971984;
pub const GPIO_PIN18_INT_ENA: u32 = 31;
pub const GPIO_PIN18_INT_ENA_V: u32 = 31;
pub const GPIO_PIN18_INT_ENA_S: u32 = 13;
pub const GPIO_PIN18_CONFIG: u32 = 3;
pub const GPIO_PIN18_CONFIG_V: u32 = 3;
pub const GPIO_PIN18_CONFIG_S: u32 = 11;
pub const GPIO_PIN18_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN18_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN18_INT_TYPE: u32 = 7;
pub const GPIO_PIN18_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN18_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN18_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN18_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN19_REG: u32 = 1072971988;
pub const GPIO_PIN19_INT_ENA: u32 = 31;
pub const GPIO_PIN19_INT_ENA_V: u32 = 31;
pub const GPIO_PIN19_INT_ENA_S: u32 = 13;
pub const GPIO_PIN19_CONFIG: u32 = 3;
pub const GPIO_PIN19_CONFIG_V: u32 = 3;
pub const GPIO_PIN19_CONFIG_S: u32 = 11;
pub const GPIO_PIN19_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN19_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN19_INT_TYPE: u32 = 7;
pub const GPIO_PIN19_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN19_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN19_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN19_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN20_REG: u32 = 1072971992;
pub const GPIO_PIN20_INT_ENA: u32 = 31;
pub const GPIO_PIN20_INT_ENA_V: u32 = 31;
pub const GPIO_PIN20_INT_ENA_S: u32 = 13;
pub const GPIO_PIN20_CONFIG: u32 = 3;
pub const GPIO_PIN20_CONFIG_V: u32 = 3;
pub const GPIO_PIN20_CONFIG_S: u32 = 11;
pub const GPIO_PIN20_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN20_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN20_INT_TYPE: u32 = 7;
pub const GPIO_PIN20_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN20_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN20_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN20_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN21_REG: u32 = 1072971996;
pub const GPIO_PIN21_INT_ENA: u32 = 31;
pub const GPIO_PIN21_INT_ENA_V: u32 = 31;
pub const GPIO_PIN21_INT_ENA_S: u32 = 13;
pub const GPIO_PIN21_CONFIG: u32 = 3;
pub const GPIO_PIN21_CONFIG_V: u32 = 3;
pub const GPIO_PIN21_CONFIG_S: u32 = 11;
pub const GPIO_PIN21_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN21_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN21_INT_TYPE: u32 = 7;
pub const GPIO_PIN21_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN21_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN21_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN21_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN22_REG: u32 = 1072972000;
pub const GPIO_PIN22_INT_ENA: u32 = 31;
pub const GPIO_PIN22_INT_ENA_V: u32 = 31;
pub const GPIO_PIN22_INT_ENA_S: u32 = 13;
pub const GPIO_PIN22_CONFIG: u32 = 3;
pub const GPIO_PIN22_CONFIG_V: u32 = 3;
pub const GPIO_PIN22_CONFIG_S: u32 = 11;
pub const GPIO_PIN22_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN22_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN22_INT_TYPE: u32 = 7;
pub const GPIO_PIN22_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN22_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN22_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN22_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN23_REG: u32 = 1072972004;
pub const GPIO_PIN23_INT_ENA: u32 = 31;
pub const GPIO_PIN23_INT_ENA_V: u32 = 31;
pub const GPIO_PIN23_INT_ENA_S: u32 = 13;
pub const GPIO_PIN23_CONFIG: u32 = 3;
pub const GPIO_PIN23_CONFIG_V: u32 = 3;
pub const GPIO_PIN23_CONFIG_S: u32 = 11;
pub const GPIO_PIN23_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN23_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN23_INT_TYPE: u32 = 7;
pub const GPIO_PIN23_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN23_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN23_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN23_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN24_REG: u32 = 1072972008;
pub const GPIO_PIN24_INT_ENA: u32 = 31;
pub const GPIO_PIN24_INT_ENA_V: u32 = 31;
pub const GPIO_PIN24_INT_ENA_S: u32 = 13;
pub const GPIO_PIN24_CONFIG: u32 = 3;
pub const GPIO_PIN24_CONFIG_V: u32 = 3;
pub const GPIO_PIN24_CONFIG_S: u32 = 11;
pub const GPIO_PIN24_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN24_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN24_INT_TYPE: u32 = 7;
pub const GPIO_PIN24_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN24_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN24_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN24_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN25_REG: u32 = 1072972012;
pub const GPIO_PIN25_INT_ENA: u32 = 31;
pub const GPIO_PIN25_INT_ENA_V: u32 = 31;
pub const GPIO_PIN25_INT_ENA_S: u32 = 13;
pub const GPIO_PIN25_CONFIG: u32 = 3;
pub const GPIO_PIN25_CONFIG_V: u32 = 3;
pub const GPIO_PIN25_CONFIG_S: u32 = 11;
pub const GPIO_PIN25_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN25_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN25_INT_TYPE: u32 = 7;
pub const GPIO_PIN25_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN25_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN25_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN25_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN26_REG: u32 = 1072972016;
pub const GPIO_PIN26_INT_ENA: u32 = 31;
pub const GPIO_PIN26_INT_ENA_V: u32 = 31;
pub const GPIO_PIN26_INT_ENA_S: u32 = 13;
pub const GPIO_PIN26_CONFIG: u32 = 3;
pub const GPIO_PIN26_CONFIG_V: u32 = 3;
pub const GPIO_PIN26_CONFIG_S: u32 = 11;
pub const GPIO_PIN26_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN26_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN26_INT_TYPE: u32 = 7;
pub const GPIO_PIN26_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN26_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN26_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN26_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN27_REG: u32 = 1072972020;
pub const GPIO_PIN27_INT_ENA: u32 = 31;
pub const GPIO_PIN27_INT_ENA_V: u32 = 31;
pub const GPIO_PIN27_INT_ENA_S: u32 = 13;
pub const GPIO_PIN27_CONFIG: u32 = 3;
pub const GPIO_PIN27_CONFIG_V: u32 = 3;
pub const GPIO_PIN27_CONFIG_S: u32 = 11;
pub const GPIO_PIN27_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN27_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN27_INT_TYPE: u32 = 7;
pub const GPIO_PIN27_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN27_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN27_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN27_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN28_REG: u32 = 1072972024;
pub const GPIO_PIN28_INT_ENA: u32 = 31;
pub const GPIO_PIN28_INT_ENA_V: u32 = 31;
pub const GPIO_PIN28_INT_ENA_S: u32 = 13;
pub const GPIO_PIN28_CONFIG: u32 = 3;
pub const GPIO_PIN28_CONFIG_V: u32 = 3;
pub const GPIO_PIN28_CONFIG_S: u32 = 11;
pub const GPIO_PIN28_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN28_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN28_INT_TYPE: u32 = 7;
pub const GPIO_PIN28_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN28_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN28_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN28_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN29_REG: u32 = 1072972028;
pub const GPIO_PIN29_INT_ENA: u32 = 31;
pub const GPIO_PIN29_INT_ENA_V: u32 = 31;
pub const GPIO_PIN29_INT_ENA_S: u32 = 13;
pub const GPIO_PIN29_CONFIG: u32 = 3;
pub const GPIO_PIN29_CONFIG_V: u32 = 3;
pub const GPIO_PIN29_CONFIG_S: u32 = 11;
pub const GPIO_PIN29_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN29_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN29_INT_TYPE: u32 = 7;
pub const GPIO_PIN29_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN29_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN29_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN29_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN30_REG: u32 = 1072972032;
pub const GPIO_PIN30_INT_ENA: u32 = 31;
pub const GPIO_PIN30_INT_ENA_V: u32 = 31;
pub const GPIO_PIN30_INT_ENA_S: u32 = 13;
pub const GPIO_PIN30_CONFIG: u32 = 3;
pub const GPIO_PIN30_CONFIG_V: u32 = 3;
pub const GPIO_PIN30_CONFIG_S: u32 = 11;
pub const GPIO_PIN30_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN30_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN30_INT_TYPE: u32 = 7;
pub const GPIO_PIN30_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN30_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN30_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN30_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN31_REG: u32 = 1072972036;
pub const GPIO_PIN31_INT_ENA: u32 = 31;
pub const GPIO_PIN31_INT_ENA_V: u32 = 31;
pub const GPIO_PIN31_INT_ENA_S: u32 = 13;
pub const GPIO_PIN31_CONFIG: u32 = 3;
pub const GPIO_PIN31_CONFIG_V: u32 = 3;
pub const GPIO_PIN31_CONFIG_S: u32 = 11;
pub const GPIO_PIN31_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN31_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN31_INT_TYPE: u32 = 7;
pub const GPIO_PIN31_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN31_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN31_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN31_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN32_REG: u32 = 1072972040;
pub const GPIO_PIN32_INT_ENA: u32 = 31;
pub const GPIO_PIN32_INT_ENA_V: u32 = 31;
pub const GPIO_PIN32_INT_ENA_S: u32 = 13;
pub const GPIO_PIN32_CONFIG: u32 = 3;
pub const GPIO_PIN32_CONFIG_V: u32 = 3;
pub const GPIO_PIN32_CONFIG_S: u32 = 11;
pub const GPIO_PIN32_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN32_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN32_INT_TYPE: u32 = 7;
pub const GPIO_PIN32_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN32_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN32_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN32_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN33_REG: u32 = 1072972044;
pub const GPIO_PIN33_INT_ENA: u32 = 31;
pub const GPIO_PIN33_INT_ENA_V: u32 = 31;
pub const GPIO_PIN33_INT_ENA_S: u32 = 13;
pub const GPIO_PIN33_CONFIG: u32 = 3;
pub const GPIO_PIN33_CONFIG_V: u32 = 3;
pub const GPIO_PIN33_CONFIG_S: u32 = 11;
pub const GPIO_PIN33_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN33_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN33_INT_TYPE: u32 = 7;
pub const GPIO_PIN33_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN33_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN33_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN33_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN34_REG: u32 = 1072972048;
pub const GPIO_PIN34_INT_ENA: u32 = 31;
pub const GPIO_PIN34_INT_ENA_V: u32 = 31;
pub const GPIO_PIN34_INT_ENA_S: u32 = 13;
pub const GPIO_PIN34_CONFIG: u32 = 3;
pub const GPIO_PIN34_CONFIG_V: u32 = 3;
pub const GPIO_PIN34_CONFIG_S: u32 = 11;
pub const GPIO_PIN34_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN34_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN34_INT_TYPE: u32 = 7;
pub const GPIO_PIN34_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN34_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN34_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN34_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN35_REG: u32 = 1072972052;
pub const GPIO_PIN35_INT_ENA: u32 = 31;
pub const GPIO_PIN35_INT_ENA_V: u32 = 31;
pub const GPIO_PIN35_INT_ENA_S: u32 = 13;
pub const GPIO_PIN35_CONFIG: u32 = 3;
pub const GPIO_PIN35_CONFIG_V: u32 = 3;
pub const GPIO_PIN35_CONFIG_S: u32 = 11;
pub const GPIO_PIN35_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN35_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN35_INT_TYPE: u32 = 7;
pub const GPIO_PIN35_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN35_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN35_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN35_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN36_REG: u32 = 1072972056;
pub const GPIO_PIN36_INT_ENA: u32 = 31;
pub const GPIO_PIN36_INT_ENA_V: u32 = 31;
pub const GPIO_PIN36_INT_ENA_S: u32 = 13;
pub const GPIO_PIN36_CONFIG: u32 = 3;
pub const GPIO_PIN36_CONFIG_V: u32 = 3;
pub const GPIO_PIN36_CONFIG_S: u32 = 11;
pub const GPIO_PIN36_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN36_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN36_INT_TYPE: u32 = 7;
pub const GPIO_PIN36_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN36_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN36_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN36_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN37_REG: u32 = 1072972060;
pub const GPIO_PIN37_INT_ENA: u32 = 31;
pub const GPIO_PIN37_INT_ENA_V: u32 = 31;
pub const GPIO_PIN37_INT_ENA_S: u32 = 13;
pub const GPIO_PIN37_CONFIG: u32 = 3;
pub const GPIO_PIN37_CONFIG_V: u32 = 3;
pub const GPIO_PIN37_CONFIG_S: u32 = 11;
pub const GPIO_PIN37_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN37_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN37_INT_TYPE: u32 = 7;
pub const GPIO_PIN37_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN37_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN37_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN37_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN38_REG: u32 = 1072972064;
pub const GPIO_PIN38_INT_ENA: u32 = 31;
pub const GPIO_PIN38_INT_ENA_V: u32 = 31;
pub const GPIO_PIN38_INT_ENA_S: u32 = 13;
pub const GPIO_PIN38_CONFIG: u32 = 3;
pub const GPIO_PIN38_CONFIG_V: u32 = 3;
pub const GPIO_PIN38_CONFIG_S: u32 = 11;
pub const GPIO_PIN38_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN38_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN38_INT_TYPE: u32 = 7;
pub const GPIO_PIN38_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN38_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN38_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN38_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN39_REG: u32 = 1072972068;
pub const GPIO_PIN39_INT_ENA: u32 = 31;
pub const GPIO_PIN39_INT_ENA_V: u32 = 31;
pub const GPIO_PIN39_INT_ENA_S: u32 = 13;
pub const GPIO_PIN39_CONFIG: u32 = 3;
pub const GPIO_PIN39_CONFIG_V: u32 = 3;
pub const GPIO_PIN39_CONFIG_S: u32 = 11;
pub const GPIO_PIN39_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN39_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN39_INT_TYPE: u32 = 7;
pub const GPIO_PIN39_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN39_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN39_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN39_PAD_DRIVER_S: u32 = 2;
pub const GPIO_cali_conf_REG: u32 = 1072972072;
pub const GPIO_CALI_START_V: u32 = 1;
pub const GPIO_CALI_START_S: u32 = 31;
pub const GPIO_CALI_RTC_MAX: u32 = 1023;
pub const GPIO_CALI_RTC_MAX_V: u32 = 1023;
pub const GPIO_CALI_RTC_MAX_S: u32 = 0;
pub const GPIO_cali_data_REG: u32 = 1072972076;
pub const GPIO_CALI_RDY_SYNC2_V: u32 = 1;
pub const GPIO_CALI_RDY_SYNC2_S: u32 = 31;
pub const GPIO_CALI_RDY_REAL_V: u32 = 1;
pub const GPIO_CALI_RDY_REAL_S: u32 = 30;
pub const GPIO_CALI_VALUE_SYNC2: u32 = 1048575;
pub const GPIO_CALI_VALUE_SYNC2_V: u32 = 1048575;
pub const GPIO_CALI_VALUE_SYNC2_S: u32 = 0;
pub const GPIO_FUNC0_IN_SEL_CFG_REG: u32 = 1072972080;
pub const GPIO_SIG0_IN_SEL_V: u32 = 1;
pub const GPIO_SIG0_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC0_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC0_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC0_IN_SEL: u32 = 63;
pub const GPIO_FUNC0_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC0_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC1_IN_SEL_CFG_REG: u32 = 1072972084;
pub const GPIO_SIG1_IN_SEL_V: u32 = 1;
pub const GPIO_SIG1_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC1_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC1_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC1_IN_SEL: u32 = 63;
pub const GPIO_FUNC1_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC1_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC2_IN_SEL_CFG_REG: u32 = 1072972088;
pub const GPIO_SIG2_IN_SEL_V: u32 = 1;
pub const GPIO_SIG2_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC2_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC2_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC2_IN_SEL: u32 = 63;
pub const GPIO_FUNC2_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC2_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC3_IN_SEL_CFG_REG: u32 = 1072972092;
pub const GPIO_SIG3_IN_SEL_V: u32 = 1;
pub const GPIO_SIG3_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC3_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC3_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC3_IN_SEL: u32 = 63;
pub const GPIO_FUNC3_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC3_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC4_IN_SEL_CFG_REG: u32 = 1072972096;
pub const GPIO_SIG4_IN_SEL_V: u32 = 1;
pub const GPIO_SIG4_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC4_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC4_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC4_IN_SEL: u32 = 63;
pub const GPIO_FUNC4_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC4_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC5_IN_SEL_CFG_REG: u32 = 1072972100;
pub const GPIO_SIG5_IN_SEL_V: u32 = 1;
pub const GPIO_SIG5_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC5_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC5_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC5_IN_SEL: u32 = 63;
pub const GPIO_FUNC5_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC5_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC6_IN_SEL_CFG_REG: u32 = 1072972104;
pub const GPIO_SIG6_IN_SEL_V: u32 = 1;
pub const GPIO_SIG6_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC6_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC6_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC6_IN_SEL: u32 = 63;
pub const GPIO_FUNC6_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC6_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC7_IN_SEL_CFG_REG: u32 = 1072972108;
pub const GPIO_SIG7_IN_SEL_V: u32 = 1;
pub const GPIO_SIG7_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC7_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC7_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC7_IN_SEL: u32 = 63;
pub const GPIO_FUNC7_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC7_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC8_IN_SEL_CFG_REG: u32 = 1072972112;
pub const GPIO_SIG8_IN_SEL_V: u32 = 1;
pub const GPIO_SIG8_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC8_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC8_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC8_IN_SEL: u32 = 63;
pub const GPIO_FUNC8_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC8_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC9_IN_SEL_CFG_REG: u32 = 1072972116;
pub const GPIO_SIG9_IN_SEL_V: u32 = 1;
pub const GPIO_SIG9_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC9_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC9_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC9_IN_SEL: u32 = 63;
pub const GPIO_FUNC9_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC9_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC10_IN_SEL_CFG_REG: u32 = 1072972120;
pub const GPIO_SIG10_IN_SEL_V: u32 = 1;
pub const GPIO_SIG10_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC10_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC10_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC10_IN_SEL: u32 = 63;
pub const GPIO_FUNC10_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC10_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC11_IN_SEL_CFG_REG: u32 = 1072972124;
pub const GPIO_SIG11_IN_SEL_V: u32 = 1;
pub const GPIO_SIG11_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC11_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC11_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC11_IN_SEL: u32 = 63;
pub const GPIO_FUNC11_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC11_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC12_IN_SEL_CFG_REG: u32 = 1072972128;
pub const GPIO_SIG12_IN_SEL_V: u32 = 1;
pub const GPIO_SIG12_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC12_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC12_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC12_IN_SEL: u32 = 63;
pub const GPIO_FUNC12_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC12_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC13_IN_SEL_CFG_REG: u32 = 1072972132;
pub const GPIO_SIG13_IN_SEL_V: u32 = 1;
pub const GPIO_SIG13_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC13_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC13_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC13_IN_SEL: u32 = 63;
pub const GPIO_FUNC13_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC13_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC14_IN_SEL_CFG_REG: u32 = 1072972136;
pub const GPIO_SIG14_IN_SEL_V: u32 = 1;
pub const GPIO_SIG14_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC14_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC14_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC14_IN_SEL: u32 = 63;
pub const GPIO_FUNC14_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC14_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC15_IN_SEL_CFG_REG: u32 = 1072972140;
pub const GPIO_SIG15_IN_SEL_V: u32 = 1;
pub const GPIO_SIG15_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC15_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC15_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC15_IN_SEL: u32 = 63;
pub const GPIO_FUNC15_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC15_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC16_IN_SEL_CFG_REG: u32 = 1072972144;
pub const GPIO_SIG16_IN_SEL_V: u32 = 1;
pub const GPIO_SIG16_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC16_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC16_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC16_IN_SEL: u32 = 63;
pub const GPIO_FUNC16_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC16_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC17_IN_SEL_CFG_REG: u32 = 1072972148;
pub const GPIO_SIG17_IN_SEL_V: u32 = 1;
pub const GPIO_SIG17_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC17_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC17_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC17_IN_SEL: u32 = 63;
pub const GPIO_FUNC17_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC17_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC18_IN_SEL_CFG_REG: u32 = 1072972152;
pub const GPIO_SIG18_IN_SEL_V: u32 = 1;
pub const GPIO_SIG18_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC18_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC18_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC18_IN_SEL: u32 = 63;
pub const GPIO_FUNC18_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC18_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC19_IN_SEL_CFG_REG: u32 = 1072972156;
pub const GPIO_SIG19_IN_SEL_V: u32 = 1;
pub const GPIO_SIG19_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC19_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC19_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC19_IN_SEL: u32 = 63;
pub const GPIO_FUNC19_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC19_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC20_IN_SEL_CFG_REG: u32 = 1072972160;
pub const GPIO_SIG20_IN_SEL_V: u32 = 1;
pub const GPIO_SIG20_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC20_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC20_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC20_IN_SEL: u32 = 63;
pub const GPIO_FUNC20_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC20_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC21_IN_SEL_CFG_REG: u32 = 1072972164;
pub const GPIO_SIG21_IN_SEL_V: u32 = 1;
pub const GPIO_SIG21_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC21_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC21_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC21_IN_SEL: u32 = 63;
pub const GPIO_FUNC21_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC21_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC22_IN_SEL_CFG_REG: u32 = 1072972168;
pub const GPIO_SIG22_IN_SEL_V: u32 = 1;
pub const GPIO_SIG22_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC22_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC22_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC22_IN_SEL: u32 = 63;
pub const GPIO_FUNC22_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC22_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC23_IN_SEL_CFG_REG: u32 = 1072972172;
pub const GPIO_SIG23_IN_SEL_V: u32 = 1;
pub const GPIO_SIG23_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC23_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC23_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC23_IN_SEL: u32 = 63;
pub const GPIO_FUNC23_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC23_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC24_IN_SEL_CFG_REG: u32 = 1072972176;
pub const GPIO_SIG24_IN_SEL_V: u32 = 1;
pub const GPIO_SIG24_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC24_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC24_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC24_IN_SEL: u32 = 63;
pub const GPIO_FUNC24_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC24_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC25_IN_SEL_CFG_REG: u32 = 1072972180;
pub const GPIO_SIG25_IN_SEL_V: u32 = 1;
pub const GPIO_SIG25_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC25_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC25_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC25_IN_SEL: u32 = 63;
pub const GPIO_FUNC25_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC25_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC26_IN_SEL_CFG_REG: u32 = 1072972184;
pub const GPIO_SIG26_IN_SEL_V: u32 = 1;
pub const GPIO_SIG26_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC26_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC26_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC26_IN_SEL: u32 = 63;
pub const GPIO_FUNC26_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC26_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC27_IN_SEL_CFG_REG: u32 = 1072972188;
pub const GPIO_SIG27_IN_SEL_V: u32 = 1;
pub const GPIO_SIG27_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC27_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC27_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC27_IN_SEL: u32 = 63;
pub const GPIO_FUNC27_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC27_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC28_IN_SEL_CFG_REG: u32 = 1072972192;
pub const GPIO_SIG28_IN_SEL_V: u32 = 1;
pub const GPIO_SIG28_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC28_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC28_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC28_IN_SEL: u32 = 63;
pub const GPIO_FUNC28_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC28_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC29_IN_SEL_CFG_REG: u32 = 1072972196;
pub const GPIO_SIG29_IN_SEL_V: u32 = 1;
pub const GPIO_SIG29_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC29_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC29_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC29_IN_SEL: u32 = 63;
pub const GPIO_FUNC29_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC29_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC30_IN_SEL_CFG_REG: u32 = 1072972200;
pub const GPIO_SIG30_IN_SEL_V: u32 = 1;
pub const GPIO_SIG30_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC30_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC30_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC30_IN_SEL: u32 = 63;
pub const GPIO_FUNC30_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC30_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC31_IN_SEL_CFG_REG: u32 = 1072972204;
pub const GPIO_SIG31_IN_SEL_V: u32 = 1;
pub const GPIO_SIG31_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC31_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC31_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC31_IN_SEL: u32 = 63;
pub const GPIO_FUNC31_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC31_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC32_IN_SEL_CFG_REG: u32 = 1072972208;
pub const GPIO_SIG32_IN_SEL_V: u32 = 1;
pub const GPIO_SIG32_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC32_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC32_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC32_IN_SEL: u32 = 63;
pub const GPIO_FUNC32_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC32_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC33_IN_SEL_CFG_REG: u32 = 1072972212;
pub const GPIO_SIG33_IN_SEL_V: u32 = 1;
pub const GPIO_SIG33_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC33_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC33_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC33_IN_SEL: u32 = 63;
pub const GPIO_FUNC33_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC33_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC34_IN_SEL_CFG_REG: u32 = 1072972216;
pub const GPIO_SIG34_IN_SEL_V: u32 = 1;
pub const GPIO_SIG34_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC34_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC34_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC34_IN_SEL: u32 = 63;
pub const GPIO_FUNC34_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC34_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC35_IN_SEL_CFG_REG: u32 = 1072972220;
pub const GPIO_SIG35_IN_SEL_V: u32 = 1;
pub const GPIO_SIG35_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC35_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC35_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC35_IN_SEL: u32 = 63;
pub const GPIO_FUNC35_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC35_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC36_IN_SEL_CFG_REG: u32 = 1072972224;
pub const GPIO_SIG36_IN_SEL_V: u32 = 1;
pub const GPIO_SIG36_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC36_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC36_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC36_IN_SEL: u32 = 63;
pub const GPIO_FUNC36_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC36_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC37_IN_SEL_CFG_REG: u32 = 1072972228;
pub const GPIO_SIG37_IN_SEL_V: u32 = 1;
pub const GPIO_SIG37_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC37_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC37_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC37_IN_SEL: u32 = 63;
pub const GPIO_FUNC37_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC37_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC38_IN_SEL_CFG_REG: u32 = 1072972232;
pub const GPIO_SIG38_IN_SEL_V: u32 = 1;
pub const GPIO_SIG38_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC38_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC38_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC38_IN_SEL: u32 = 63;
pub const GPIO_FUNC38_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC38_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC39_IN_SEL_CFG_REG: u32 = 1072972236;
pub const GPIO_SIG39_IN_SEL_V: u32 = 1;
pub const GPIO_SIG39_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC39_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC39_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC39_IN_SEL: u32 = 63;
pub const GPIO_FUNC39_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC39_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC40_IN_SEL_CFG_REG: u32 = 1072972240;
pub const GPIO_SIG40_IN_SEL_V: u32 = 1;
pub const GPIO_SIG40_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC40_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC40_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC40_IN_SEL: u32 = 63;
pub const GPIO_FUNC40_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC40_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC41_IN_SEL_CFG_REG: u32 = 1072972244;
pub const GPIO_SIG41_IN_SEL_V: u32 = 1;
pub const GPIO_SIG41_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC41_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC41_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC41_IN_SEL: u32 = 63;
pub const GPIO_FUNC41_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC41_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC42_IN_SEL_CFG_REG: u32 = 1072972248;
pub const GPIO_SIG42_IN_SEL_V: u32 = 1;
pub const GPIO_SIG42_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC42_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC42_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC42_IN_SEL: u32 = 63;
pub const GPIO_FUNC42_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC42_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC43_IN_SEL_CFG_REG: u32 = 1072972252;
pub const GPIO_SIG43_IN_SEL_V: u32 = 1;
pub const GPIO_SIG43_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC43_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC43_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC43_IN_SEL: u32 = 63;
pub const GPIO_FUNC43_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC43_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC44_IN_SEL_CFG_REG: u32 = 1072972256;
pub const GPIO_SIG44_IN_SEL_V: u32 = 1;
pub const GPIO_SIG44_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC44_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC44_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC44_IN_SEL: u32 = 63;
pub const GPIO_FUNC44_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC44_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC45_IN_SEL_CFG_REG: u32 = 1072972260;
pub const GPIO_SIG45_IN_SEL_V: u32 = 1;
pub const GPIO_SIG45_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC45_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC45_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC45_IN_SEL: u32 = 63;
pub const GPIO_FUNC45_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC45_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC46_IN_SEL_CFG_REG: u32 = 1072972264;
pub const GPIO_SIG46_IN_SEL_V: u32 = 1;
pub const GPIO_SIG46_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC46_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC46_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC46_IN_SEL: u32 = 63;
pub const GPIO_FUNC46_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC46_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC47_IN_SEL_CFG_REG: u32 = 1072972268;
pub const GPIO_SIG47_IN_SEL_V: u32 = 1;
pub const GPIO_SIG47_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC47_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC47_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC47_IN_SEL: u32 = 63;
pub const GPIO_FUNC47_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC47_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC48_IN_SEL_CFG_REG: u32 = 1072972272;
pub const GPIO_SIG48_IN_SEL_V: u32 = 1;
pub const GPIO_SIG48_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC48_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC48_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC48_IN_SEL: u32 = 63;
pub const GPIO_FUNC48_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC48_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC49_IN_SEL_CFG_REG: u32 = 1072972276;
pub const GPIO_SIG49_IN_SEL_V: u32 = 1;
pub const GPIO_SIG49_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC49_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC49_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC49_IN_SEL: u32 = 63;
pub const GPIO_FUNC49_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC49_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC50_IN_SEL_CFG_REG: u32 = 1072972280;
pub const GPIO_SIG50_IN_SEL_V: u32 = 1;
pub const GPIO_SIG50_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC50_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC50_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC50_IN_SEL: u32 = 63;
pub const GPIO_FUNC50_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC50_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC51_IN_SEL_CFG_REG: u32 = 1072972284;
pub const GPIO_SIG51_IN_SEL_V: u32 = 1;
pub const GPIO_SIG51_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC51_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC51_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC51_IN_SEL: u32 = 63;
pub const GPIO_FUNC51_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC51_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC52_IN_SEL_CFG_REG: u32 = 1072972288;
pub const GPIO_SIG52_IN_SEL_V: u32 = 1;
pub const GPIO_SIG52_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC52_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC52_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC52_IN_SEL: u32 = 63;
pub const GPIO_FUNC52_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC52_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC53_IN_SEL_CFG_REG: u32 = 1072972292;
pub const GPIO_SIG53_IN_SEL_V: u32 = 1;
pub const GPIO_SIG53_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC53_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC53_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC53_IN_SEL: u32 = 63;
pub const GPIO_FUNC53_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC53_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC54_IN_SEL_CFG_REG: u32 = 1072972296;
pub const GPIO_SIG54_IN_SEL_V: u32 = 1;
pub const GPIO_SIG54_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC54_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC54_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC54_IN_SEL: u32 = 63;
pub const GPIO_FUNC54_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC54_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC55_IN_SEL_CFG_REG: u32 = 1072972300;
pub const GPIO_SIG55_IN_SEL_V: u32 = 1;
pub const GPIO_SIG55_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC55_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC55_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC55_IN_SEL: u32 = 63;
pub const GPIO_FUNC55_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC55_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC56_IN_SEL_CFG_REG: u32 = 1072972304;
pub const GPIO_SIG56_IN_SEL_V: u32 = 1;
pub const GPIO_SIG56_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC56_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC56_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC56_IN_SEL: u32 = 63;
pub const GPIO_FUNC56_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC56_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC57_IN_SEL_CFG_REG: u32 = 1072972308;
pub const GPIO_SIG57_IN_SEL_V: u32 = 1;
pub const GPIO_SIG57_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC57_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC57_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC57_IN_SEL: u32 = 63;
pub const GPIO_FUNC57_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC57_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC58_IN_SEL_CFG_REG: u32 = 1072972312;
pub const GPIO_SIG58_IN_SEL_V: u32 = 1;
pub const GPIO_SIG58_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC58_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC58_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC58_IN_SEL: u32 = 63;
pub const GPIO_FUNC58_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC58_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC59_IN_SEL_CFG_REG: u32 = 1072972316;
pub const GPIO_SIG59_IN_SEL_V: u32 = 1;
pub const GPIO_SIG59_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC59_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC59_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC59_IN_SEL: u32 = 63;
pub const GPIO_FUNC59_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC59_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC60_IN_SEL_CFG_REG: u32 = 1072972320;
pub const GPIO_SIG60_IN_SEL_V: u32 = 1;
pub const GPIO_SIG60_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC60_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC60_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC60_IN_SEL: u32 = 63;
pub const GPIO_FUNC60_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC60_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC61_IN_SEL_CFG_REG: u32 = 1072972324;
pub const GPIO_SIG61_IN_SEL_V: u32 = 1;
pub const GPIO_SIG61_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC61_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC61_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC61_IN_SEL: u32 = 63;
pub const GPIO_FUNC61_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC61_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC62_IN_SEL_CFG_REG: u32 = 1072972328;
pub const GPIO_SIG62_IN_SEL_V: u32 = 1;
pub const GPIO_SIG62_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC62_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC62_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC62_IN_SEL: u32 = 63;
pub const GPIO_FUNC62_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC62_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC63_IN_SEL_CFG_REG: u32 = 1072972332;
pub const GPIO_SIG63_IN_SEL_V: u32 = 1;
pub const GPIO_SIG63_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC63_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC63_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC63_IN_SEL: u32 = 63;
pub const GPIO_FUNC63_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC63_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC64_IN_SEL_CFG_REG: u32 = 1072972336;
pub const GPIO_SIG64_IN_SEL_V: u32 = 1;
pub const GPIO_SIG64_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC64_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC64_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC64_IN_SEL: u32 = 63;
pub const GPIO_FUNC64_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC64_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC65_IN_SEL_CFG_REG: u32 = 1072972340;
pub const GPIO_SIG65_IN_SEL_V: u32 = 1;
pub const GPIO_SIG65_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC65_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC65_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC65_IN_SEL: u32 = 63;
pub const GPIO_FUNC65_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC65_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC66_IN_SEL_CFG_REG: u32 = 1072972344;
pub const GPIO_SIG66_IN_SEL_V: u32 = 1;
pub const GPIO_SIG66_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC66_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC66_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC66_IN_SEL: u32 = 63;
pub const GPIO_FUNC66_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC66_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC67_IN_SEL_CFG_REG: u32 = 1072972348;
pub const GPIO_SIG67_IN_SEL_V: u32 = 1;
pub const GPIO_SIG67_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC67_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC67_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC67_IN_SEL: u32 = 63;
pub const GPIO_FUNC67_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC67_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC68_IN_SEL_CFG_REG: u32 = 1072972352;
pub const GPIO_SIG68_IN_SEL_V: u32 = 1;
pub const GPIO_SIG68_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC68_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC68_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC68_IN_SEL: u32 = 63;
pub const GPIO_FUNC68_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC68_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC69_IN_SEL_CFG_REG: u32 = 1072972356;
pub const GPIO_SIG69_IN_SEL_V: u32 = 1;
pub const GPIO_SIG69_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC69_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC69_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC69_IN_SEL: u32 = 63;
pub const GPIO_FUNC69_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC69_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC70_IN_SEL_CFG_REG: u32 = 1072972360;
pub const GPIO_SIG70_IN_SEL_V: u32 = 1;
pub const GPIO_SIG70_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC70_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC70_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC70_IN_SEL: u32 = 63;
pub const GPIO_FUNC70_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC70_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC71_IN_SEL_CFG_REG: u32 = 1072972364;
pub const GPIO_SIG71_IN_SEL_V: u32 = 1;
pub const GPIO_SIG71_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC71_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC71_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC71_IN_SEL: u32 = 63;
pub const GPIO_FUNC71_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC71_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC72_IN_SEL_CFG_REG: u32 = 1072972368;
pub const GPIO_SIG72_IN_SEL_V: u32 = 1;
pub const GPIO_SIG72_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC72_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC72_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC72_IN_SEL: u32 = 63;
pub const GPIO_FUNC72_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC72_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC73_IN_SEL_CFG_REG: u32 = 1072972372;
pub const GPIO_SIG73_IN_SEL_V: u32 = 1;
pub const GPIO_SIG73_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC73_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC73_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC73_IN_SEL: u32 = 63;
pub const GPIO_FUNC73_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC73_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC74_IN_SEL_CFG_REG: u32 = 1072972376;
pub const GPIO_SIG74_IN_SEL_V: u32 = 1;
pub const GPIO_SIG74_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC74_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC74_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC74_IN_SEL: u32 = 63;
pub const GPIO_FUNC74_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC74_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC75_IN_SEL_CFG_REG: u32 = 1072972380;
pub const GPIO_SIG75_IN_SEL_V: u32 = 1;
pub const GPIO_SIG75_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC75_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC75_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC75_IN_SEL: u32 = 63;
pub const GPIO_FUNC75_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC75_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC76_IN_SEL_CFG_REG: u32 = 1072972384;
pub const GPIO_SIG76_IN_SEL_V: u32 = 1;
pub const GPIO_SIG76_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC76_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC76_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC76_IN_SEL: u32 = 63;
pub const GPIO_FUNC76_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC76_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC77_IN_SEL_CFG_REG: u32 = 1072972388;
pub const GPIO_SIG77_IN_SEL_V: u32 = 1;
pub const GPIO_SIG77_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC77_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC77_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC77_IN_SEL: u32 = 63;
pub const GPIO_FUNC77_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC77_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC78_IN_SEL_CFG_REG: u32 = 1072972392;
pub const GPIO_SIG78_IN_SEL_V: u32 = 1;
pub const GPIO_SIG78_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC78_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC78_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC78_IN_SEL: u32 = 63;
pub const GPIO_FUNC78_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC78_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC79_IN_SEL_CFG_REG: u32 = 1072972396;
pub const GPIO_SIG79_IN_SEL_V: u32 = 1;
pub const GPIO_SIG79_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC79_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC79_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC79_IN_SEL: u32 = 63;
pub const GPIO_FUNC79_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC79_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC80_IN_SEL_CFG_REG: u32 = 1072972400;
pub const GPIO_SIG80_IN_SEL_V: u32 = 1;
pub const GPIO_SIG80_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC80_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC80_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC80_IN_SEL: u32 = 63;
pub const GPIO_FUNC80_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC80_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC81_IN_SEL_CFG_REG: u32 = 1072972404;
pub const GPIO_SIG81_IN_SEL_V: u32 = 1;
pub const GPIO_SIG81_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC81_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC81_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC81_IN_SEL: u32 = 63;
pub const GPIO_FUNC81_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC81_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC82_IN_SEL_CFG_REG: u32 = 1072972408;
pub const GPIO_SIG82_IN_SEL_V: u32 = 1;
pub const GPIO_SIG82_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC82_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC82_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC82_IN_SEL: u32 = 63;
pub const GPIO_FUNC82_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC82_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC83_IN_SEL_CFG_REG: u32 = 1072972412;
pub const GPIO_SIG83_IN_SEL_V: u32 = 1;
pub const GPIO_SIG83_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC83_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC83_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC83_IN_SEL: u32 = 63;
pub const GPIO_FUNC83_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC83_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC84_IN_SEL_CFG_REG: u32 = 1072972416;
pub const GPIO_SIG84_IN_SEL_V: u32 = 1;
pub const GPIO_SIG84_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC84_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC84_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC84_IN_SEL: u32 = 63;
pub const GPIO_FUNC84_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC84_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC85_IN_SEL_CFG_REG: u32 = 1072972420;
pub const GPIO_SIG85_IN_SEL_V: u32 = 1;
pub const GPIO_SIG85_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC85_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC85_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC85_IN_SEL: u32 = 63;
pub const GPIO_FUNC85_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC85_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC86_IN_SEL_CFG_REG: u32 = 1072972424;
pub const GPIO_SIG86_IN_SEL_V: u32 = 1;
pub const GPIO_SIG86_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC86_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC86_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC86_IN_SEL: u32 = 63;
pub const GPIO_FUNC86_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC86_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC87_IN_SEL_CFG_REG: u32 = 1072972428;
pub const GPIO_SIG87_IN_SEL_V: u32 = 1;
pub const GPIO_SIG87_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC87_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC87_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC87_IN_SEL: u32 = 63;
pub const GPIO_FUNC87_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC87_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC88_IN_SEL_CFG_REG: u32 = 1072972432;
pub const GPIO_SIG88_IN_SEL_V: u32 = 1;
pub const GPIO_SIG88_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC88_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC88_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC88_IN_SEL: u32 = 63;
pub const GPIO_FUNC88_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC88_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC89_IN_SEL_CFG_REG: u32 = 1072972436;
pub const GPIO_SIG89_IN_SEL_V: u32 = 1;
pub const GPIO_SIG89_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC89_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC89_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC89_IN_SEL: u32 = 63;
pub const GPIO_FUNC89_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC89_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC90_IN_SEL_CFG_REG: u32 = 1072972440;
pub const GPIO_SIG90_IN_SEL_V: u32 = 1;
pub const GPIO_SIG90_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC90_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC90_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC90_IN_SEL: u32 = 63;
pub const GPIO_FUNC90_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC90_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC91_IN_SEL_CFG_REG: u32 = 1072972444;
pub const GPIO_SIG91_IN_SEL_V: u32 = 1;
pub const GPIO_SIG91_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC91_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC91_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC91_IN_SEL: u32 = 63;
pub const GPIO_FUNC91_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC91_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC92_IN_SEL_CFG_REG: u32 = 1072972448;
pub const GPIO_SIG92_IN_SEL_V: u32 = 1;
pub const GPIO_SIG92_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC92_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC92_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC92_IN_SEL: u32 = 63;
pub const GPIO_FUNC92_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC92_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC93_IN_SEL_CFG_REG: u32 = 1072972452;
pub const GPIO_SIG93_IN_SEL_V: u32 = 1;
pub const GPIO_SIG93_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC93_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC93_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC93_IN_SEL: u32 = 63;
pub const GPIO_FUNC93_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC93_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC94_IN_SEL_CFG_REG: u32 = 1072972456;
pub const GPIO_SIG94_IN_SEL_V: u32 = 1;
pub const GPIO_SIG94_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC94_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC94_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC94_IN_SEL: u32 = 63;
pub const GPIO_FUNC94_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC94_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC95_IN_SEL_CFG_REG: u32 = 1072972460;
pub const GPIO_SIG95_IN_SEL_V: u32 = 1;
pub const GPIO_SIG95_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC95_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC95_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC95_IN_SEL: u32 = 63;
pub const GPIO_FUNC95_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC95_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC96_IN_SEL_CFG_REG: u32 = 1072972464;
pub const GPIO_SIG96_IN_SEL_V: u32 = 1;
pub const GPIO_SIG96_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC96_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC96_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC96_IN_SEL: u32 = 63;
pub const GPIO_FUNC96_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC96_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC97_IN_SEL_CFG_REG: u32 = 1072972468;
pub const GPIO_SIG97_IN_SEL_V: u32 = 1;
pub const GPIO_SIG97_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC97_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC97_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC97_IN_SEL: u32 = 63;
pub const GPIO_FUNC97_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC97_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC98_IN_SEL_CFG_REG: u32 = 1072972472;
pub const GPIO_SIG98_IN_SEL_V: u32 = 1;
pub const GPIO_SIG98_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC98_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC98_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC98_IN_SEL: u32 = 63;
pub const GPIO_FUNC98_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC98_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC99_IN_SEL_CFG_REG: u32 = 1072972476;
pub const GPIO_SIG99_IN_SEL_V: u32 = 1;
pub const GPIO_SIG99_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC99_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC99_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC99_IN_SEL: u32 = 63;
pub const GPIO_FUNC99_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC99_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC100_IN_SEL_CFG_REG: u32 = 1072972480;
pub const GPIO_SIG100_IN_SEL_V: u32 = 1;
pub const GPIO_SIG100_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC100_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC100_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC100_IN_SEL: u32 = 63;
pub const GPIO_FUNC100_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC100_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC101_IN_SEL_CFG_REG: u32 = 1072972484;
pub const GPIO_SIG101_IN_SEL_V: u32 = 1;
pub const GPIO_SIG101_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC101_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC101_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC101_IN_SEL: u32 = 63;
pub const GPIO_FUNC101_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC101_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC102_IN_SEL_CFG_REG: u32 = 1072972488;
pub const GPIO_SIG102_IN_SEL_V: u32 = 1;
pub const GPIO_SIG102_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC102_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC102_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC102_IN_SEL: u32 = 63;
pub const GPIO_FUNC102_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC102_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC103_IN_SEL_CFG_REG: u32 = 1072972492;
pub const GPIO_SIG103_IN_SEL_V: u32 = 1;
pub const GPIO_SIG103_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC103_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC103_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC103_IN_SEL: u32 = 63;
pub const GPIO_FUNC103_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC103_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC104_IN_SEL_CFG_REG: u32 = 1072972496;
pub const GPIO_SIG104_IN_SEL_V: u32 = 1;
pub const GPIO_SIG104_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC104_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC104_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC104_IN_SEL: u32 = 63;
pub const GPIO_FUNC104_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC104_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC105_IN_SEL_CFG_REG: u32 = 1072972500;
pub const GPIO_SIG105_IN_SEL_V: u32 = 1;
pub const GPIO_SIG105_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC105_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC105_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC105_IN_SEL: u32 = 63;
pub const GPIO_FUNC105_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC105_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC106_IN_SEL_CFG_REG: u32 = 1072972504;
pub const GPIO_SIG106_IN_SEL_V: u32 = 1;
pub const GPIO_SIG106_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC106_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC106_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC106_IN_SEL: u32 = 63;
pub const GPIO_FUNC106_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC106_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC107_IN_SEL_CFG_REG: u32 = 1072972508;
pub const GPIO_SIG107_IN_SEL_V: u32 = 1;
pub const GPIO_SIG107_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC107_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC107_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC107_IN_SEL: u32 = 63;
pub const GPIO_FUNC107_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC107_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC108_IN_SEL_CFG_REG: u32 = 1072972512;
pub const GPIO_SIG108_IN_SEL_V: u32 = 1;
pub const GPIO_SIG108_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC108_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC108_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC108_IN_SEL: u32 = 63;
pub const GPIO_FUNC108_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC108_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC109_IN_SEL_CFG_REG: u32 = 1072972516;
pub const GPIO_SIG109_IN_SEL_V: u32 = 1;
pub const GPIO_SIG109_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC109_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC109_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC109_IN_SEL: u32 = 63;
pub const GPIO_FUNC109_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC109_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC110_IN_SEL_CFG_REG: u32 = 1072972520;
pub const GPIO_SIG110_IN_SEL_V: u32 = 1;
pub const GPIO_SIG110_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC110_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC110_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC110_IN_SEL: u32 = 63;
pub const GPIO_FUNC110_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC110_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC111_IN_SEL_CFG_REG: u32 = 1072972524;
pub const GPIO_SIG111_IN_SEL_V: u32 = 1;
pub const GPIO_SIG111_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC111_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC111_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC111_IN_SEL: u32 = 63;
pub const GPIO_FUNC111_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC111_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC112_IN_SEL_CFG_REG: u32 = 1072972528;
pub const GPIO_SIG112_IN_SEL_V: u32 = 1;
pub const GPIO_SIG112_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC112_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC112_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC112_IN_SEL: u32 = 63;
pub const GPIO_FUNC112_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC112_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC113_IN_SEL_CFG_REG: u32 = 1072972532;
pub const GPIO_SIG113_IN_SEL_V: u32 = 1;
pub const GPIO_SIG113_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC113_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC113_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC113_IN_SEL: u32 = 63;
pub const GPIO_FUNC113_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC113_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC114_IN_SEL_CFG_REG: u32 = 1072972536;
pub const GPIO_SIG114_IN_SEL_V: u32 = 1;
pub const GPIO_SIG114_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC114_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC114_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC114_IN_SEL: u32 = 63;
pub const GPIO_FUNC114_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC114_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC115_IN_SEL_CFG_REG: u32 = 1072972540;
pub const GPIO_SIG115_IN_SEL_V: u32 = 1;
pub const GPIO_SIG115_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC115_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC115_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC115_IN_SEL: u32 = 63;
pub const GPIO_FUNC115_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC115_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC116_IN_SEL_CFG_REG: u32 = 1072972544;
pub const GPIO_SIG116_IN_SEL_V: u32 = 1;
pub const GPIO_SIG116_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC116_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC116_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC116_IN_SEL: u32 = 63;
pub const GPIO_FUNC116_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC116_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC117_IN_SEL_CFG_REG: u32 = 1072972548;
pub const GPIO_SIG117_IN_SEL_V: u32 = 1;
pub const GPIO_SIG117_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC117_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC117_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC117_IN_SEL: u32 = 63;
pub const GPIO_FUNC117_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC117_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC118_IN_SEL_CFG_REG: u32 = 1072972552;
pub const GPIO_SIG118_IN_SEL_V: u32 = 1;
pub const GPIO_SIG118_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC118_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC118_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC118_IN_SEL: u32 = 63;
pub const GPIO_FUNC118_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC118_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC119_IN_SEL_CFG_REG: u32 = 1072972556;
pub const GPIO_SIG119_IN_SEL_V: u32 = 1;
pub const GPIO_SIG119_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC119_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC119_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC119_IN_SEL: u32 = 63;
pub const GPIO_FUNC119_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC119_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC120_IN_SEL_CFG_REG: u32 = 1072972560;
pub const GPIO_SIG120_IN_SEL_V: u32 = 1;
pub const GPIO_SIG120_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC120_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC120_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC120_IN_SEL: u32 = 63;
pub const GPIO_FUNC120_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC120_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC121_IN_SEL_CFG_REG: u32 = 1072972564;
pub const GPIO_SIG121_IN_SEL_V: u32 = 1;
pub const GPIO_SIG121_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC121_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC121_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC121_IN_SEL: u32 = 63;
pub const GPIO_FUNC121_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC121_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC122_IN_SEL_CFG_REG: u32 = 1072972568;
pub const GPIO_SIG122_IN_SEL_V: u32 = 1;
pub const GPIO_SIG122_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC122_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC122_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC122_IN_SEL: u32 = 63;
pub const GPIO_FUNC122_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC122_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC123_IN_SEL_CFG_REG: u32 = 1072972572;
pub const GPIO_SIG123_IN_SEL_V: u32 = 1;
pub const GPIO_SIG123_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC123_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC123_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC123_IN_SEL: u32 = 63;
pub const GPIO_FUNC123_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC123_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC124_IN_SEL_CFG_REG: u32 = 1072972576;
pub const GPIO_SIG124_IN_SEL_V: u32 = 1;
pub const GPIO_SIG124_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC124_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC124_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC124_IN_SEL: u32 = 63;
pub const GPIO_FUNC124_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC124_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC125_IN_SEL_CFG_REG: u32 = 1072972580;
pub const GPIO_SIG125_IN_SEL_V: u32 = 1;
pub const GPIO_SIG125_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC125_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC125_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC125_IN_SEL: u32 = 63;
pub const GPIO_FUNC125_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC125_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC126_IN_SEL_CFG_REG: u32 = 1072972584;
pub const GPIO_SIG126_IN_SEL_V: u32 = 1;
pub const GPIO_SIG126_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC126_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC126_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC126_IN_SEL: u32 = 63;
pub const GPIO_FUNC126_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC126_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC127_IN_SEL_CFG_REG: u32 = 1072972588;
pub const GPIO_SIG127_IN_SEL_V: u32 = 1;
pub const GPIO_SIG127_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC127_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC127_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC127_IN_SEL: u32 = 63;
pub const GPIO_FUNC127_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC127_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC128_IN_SEL_CFG_REG: u32 = 1072972592;
pub const GPIO_SIG128_IN_SEL_V: u32 = 1;
pub const GPIO_SIG128_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC128_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC128_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC128_IN_SEL: u32 = 63;
pub const GPIO_FUNC128_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC128_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC129_IN_SEL_CFG_REG: u32 = 1072972596;
pub const GPIO_SIG129_IN_SEL_V: u32 = 1;
pub const GPIO_SIG129_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC129_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC129_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC129_IN_SEL: u32 = 63;
pub const GPIO_FUNC129_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC129_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC130_IN_SEL_CFG_REG: u32 = 1072972600;
pub const GPIO_SIG130_IN_SEL_V: u32 = 1;
pub const GPIO_SIG130_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC130_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC130_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC130_IN_SEL: u32 = 63;
pub const GPIO_FUNC130_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC130_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC131_IN_SEL_CFG_REG: u32 = 1072972604;
pub const GPIO_SIG131_IN_SEL_V: u32 = 1;
pub const GPIO_SIG131_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC131_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC131_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC131_IN_SEL: u32 = 63;
pub const GPIO_FUNC131_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC131_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC132_IN_SEL_CFG_REG: u32 = 1072972608;
pub const GPIO_SIG132_IN_SEL_V: u32 = 1;
pub const GPIO_SIG132_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC132_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC132_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC132_IN_SEL: u32 = 63;
pub const GPIO_FUNC132_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC132_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC133_IN_SEL_CFG_REG: u32 = 1072972612;
pub const GPIO_SIG133_IN_SEL_V: u32 = 1;
pub const GPIO_SIG133_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC133_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC133_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC133_IN_SEL: u32 = 63;
pub const GPIO_FUNC133_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC133_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC134_IN_SEL_CFG_REG: u32 = 1072972616;
pub const GPIO_SIG134_IN_SEL_V: u32 = 1;
pub const GPIO_SIG134_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC134_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC134_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC134_IN_SEL: u32 = 63;
pub const GPIO_FUNC134_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC134_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC135_IN_SEL_CFG_REG: u32 = 1072972620;
pub const GPIO_SIG135_IN_SEL_V: u32 = 1;
pub const GPIO_SIG135_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC135_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC135_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC135_IN_SEL: u32 = 63;
pub const GPIO_FUNC135_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC135_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC136_IN_SEL_CFG_REG: u32 = 1072972624;
pub const GPIO_SIG136_IN_SEL_V: u32 = 1;
pub const GPIO_SIG136_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC136_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC136_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC136_IN_SEL: u32 = 63;
pub const GPIO_FUNC136_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC136_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC137_IN_SEL_CFG_REG: u32 = 1072972628;
pub const GPIO_SIG137_IN_SEL_V: u32 = 1;
pub const GPIO_SIG137_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC137_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC137_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC137_IN_SEL: u32 = 63;
pub const GPIO_FUNC137_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC137_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC138_IN_SEL_CFG_REG: u32 = 1072972632;
pub const GPIO_SIG138_IN_SEL_V: u32 = 1;
pub const GPIO_SIG138_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC138_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC138_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC138_IN_SEL: u32 = 63;
pub const GPIO_FUNC138_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC138_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC139_IN_SEL_CFG_REG: u32 = 1072972636;
pub const GPIO_SIG139_IN_SEL_V: u32 = 1;
pub const GPIO_SIG139_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC139_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC139_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC139_IN_SEL: u32 = 63;
pub const GPIO_FUNC139_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC139_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC140_IN_SEL_CFG_REG: u32 = 1072972640;
pub const GPIO_SIG140_IN_SEL_V: u32 = 1;
pub const GPIO_SIG140_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC140_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC140_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC140_IN_SEL: u32 = 63;
pub const GPIO_FUNC140_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC140_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC141_IN_SEL_CFG_REG: u32 = 1072972644;
pub const GPIO_SIG141_IN_SEL_V: u32 = 1;
pub const GPIO_SIG141_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC141_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC141_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC141_IN_SEL: u32 = 63;
pub const GPIO_FUNC141_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC141_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC142_IN_SEL_CFG_REG: u32 = 1072972648;
pub const GPIO_SIG142_IN_SEL_V: u32 = 1;
pub const GPIO_SIG142_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC142_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC142_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC142_IN_SEL: u32 = 63;
pub const GPIO_FUNC142_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC142_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC143_IN_SEL_CFG_REG: u32 = 1072972652;
pub const GPIO_SIG143_IN_SEL_V: u32 = 1;
pub const GPIO_SIG143_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC143_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC143_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC143_IN_SEL: u32 = 63;
pub const GPIO_FUNC143_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC143_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC144_IN_SEL_CFG_REG: u32 = 1072972656;
pub const GPIO_SIG144_IN_SEL_V: u32 = 1;
pub const GPIO_SIG144_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC144_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC144_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC144_IN_SEL: u32 = 63;
pub const GPIO_FUNC144_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC144_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC145_IN_SEL_CFG_REG: u32 = 1072972660;
pub const GPIO_SIG145_IN_SEL_V: u32 = 1;
pub const GPIO_SIG145_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC145_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC145_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC145_IN_SEL: u32 = 63;
pub const GPIO_FUNC145_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC145_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC146_IN_SEL_CFG_REG: u32 = 1072972664;
pub const GPIO_SIG146_IN_SEL_V: u32 = 1;
pub const GPIO_SIG146_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC146_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC146_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC146_IN_SEL: u32 = 63;
pub const GPIO_FUNC146_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC146_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC147_IN_SEL_CFG_REG: u32 = 1072972668;
pub const GPIO_SIG147_IN_SEL_V: u32 = 1;
pub const GPIO_SIG147_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC147_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC147_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC147_IN_SEL: u32 = 63;
pub const GPIO_FUNC147_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC147_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC148_IN_SEL_CFG_REG: u32 = 1072972672;
pub const GPIO_SIG148_IN_SEL_V: u32 = 1;
pub const GPIO_SIG148_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC148_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC148_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC148_IN_SEL: u32 = 63;
pub const GPIO_FUNC148_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC148_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC149_IN_SEL_CFG_REG: u32 = 1072972676;
pub const GPIO_SIG149_IN_SEL_V: u32 = 1;
pub const GPIO_SIG149_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC149_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC149_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC149_IN_SEL: u32 = 63;
pub const GPIO_FUNC149_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC149_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC150_IN_SEL_CFG_REG: u32 = 1072972680;
pub const GPIO_SIG150_IN_SEL_V: u32 = 1;
pub const GPIO_SIG150_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC150_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC150_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC150_IN_SEL: u32 = 63;
pub const GPIO_FUNC150_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC150_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC151_IN_SEL_CFG_REG: u32 = 1072972684;
pub const GPIO_SIG151_IN_SEL_V: u32 = 1;
pub const GPIO_SIG151_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC151_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC151_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC151_IN_SEL: u32 = 63;
pub const GPIO_FUNC151_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC151_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC152_IN_SEL_CFG_REG: u32 = 1072972688;
pub const GPIO_SIG152_IN_SEL_V: u32 = 1;
pub const GPIO_SIG152_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC152_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC152_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC152_IN_SEL: u32 = 63;
pub const GPIO_FUNC152_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC152_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC153_IN_SEL_CFG_REG: u32 = 1072972692;
pub const GPIO_SIG153_IN_SEL_V: u32 = 1;
pub const GPIO_SIG153_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC153_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC153_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC153_IN_SEL: u32 = 63;
pub const GPIO_FUNC153_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC153_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC154_IN_SEL_CFG_REG: u32 = 1072972696;
pub const GPIO_SIG154_IN_SEL_V: u32 = 1;
pub const GPIO_SIG154_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC154_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC154_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC154_IN_SEL: u32 = 63;
pub const GPIO_FUNC154_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC154_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC155_IN_SEL_CFG_REG: u32 = 1072972700;
pub const GPIO_SIG155_IN_SEL_V: u32 = 1;
pub const GPIO_SIG155_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC155_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC155_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC155_IN_SEL: u32 = 63;
pub const GPIO_FUNC155_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC155_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC156_IN_SEL_CFG_REG: u32 = 1072972704;
pub const GPIO_SIG156_IN_SEL_V: u32 = 1;
pub const GPIO_SIG156_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC156_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC156_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC156_IN_SEL: u32 = 63;
pub const GPIO_FUNC156_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC156_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC157_IN_SEL_CFG_REG: u32 = 1072972708;
pub const GPIO_SIG157_IN_SEL_V: u32 = 1;
pub const GPIO_SIG157_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC157_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC157_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC157_IN_SEL: u32 = 63;
pub const GPIO_FUNC157_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC157_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC158_IN_SEL_CFG_REG: u32 = 1072972712;
pub const GPIO_SIG158_IN_SEL_V: u32 = 1;
pub const GPIO_SIG158_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC158_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC158_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC158_IN_SEL: u32 = 63;
pub const GPIO_FUNC158_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC158_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC159_IN_SEL_CFG_REG: u32 = 1072972716;
pub const GPIO_SIG159_IN_SEL_V: u32 = 1;
pub const GPIO_SIG159_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC159_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC159_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC159_IN_SEL: u32 = 63;
pub const GPIO_FUNC159_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC159_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC160_IN_SEL_CFG_REG: u32 = 1072972720;
pub const GPIO_SIG160_IN_SEL_V: u32 = 1;
pub const GPIO_SIG160_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC160_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC160_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC160_IN_SEL: u32 = 63;
pub const GPIO_FUNC160_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC160_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC161_IN_SEL_CFG_REG: u32 = 1072972724;
pub const GPIO_SIG161_IN_SEL_V: u32 = 1;
pub const GPIO_SIG161_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC161_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC161_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC161_IN_SEL: u32 = 63;
pub const GPIO_FUNC161_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC161_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC162_IN_SEL_CFG_REG: u32 = 1072972728;
pub const GPIO_SIG162_IN_SEL_V: u32 = 1;
pub const GPIO_SIG162_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC162_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC162_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC162_IN_SEL: u32 = 63;
pub const GPIO_FUNC162_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC162_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC163_IN_SEL_CFG_REG: u32 = 1072972732;
pub const GPIO_SIG163_IN_SEL_V: u32 = 1;
pub const GPIO_SIG163_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC163_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC163_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC163_IN_SEL: u32 = 63;
pub const GPIO_FUNC163_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC163_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC164_IN_SEL_CFG_REG: u32 = 1072972736;
pub const GPIO_SIG164_IN_SEL_V: u32 = 1;
pub const GPIO_SIG164_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC164_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC164_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC164_IN_SEL: u32 = 63;
pub const GPIO_FUNC164_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC164_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC165_IN_SEL_CFG_REG: u32 = 1072972740;
pub const GPIO_SIG165_IN_SEL_V: u32 = 1;
pub const GPIO_SIG165_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC165_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC165_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC165_IN_SEL: u32 = 63;
pub const GPIO_FUNC165_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC165_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC166_IN_SEL_CFG_REG: u32 = 1072972744;
pub const GPIO_SIG166_IN_SEL_V: u32 = 1;
pub const GPIO_SIG166_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC166_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC166_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC166_IN_SEL: u32 = 63;
pub const GPIO_FUNC166_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC166_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC167_IN_SEL_CFG_REG: u32 = 1072972748;
pub const GPIO_SIG167_IN_SEL_V: u32 = 1;
pub const GPIO_SIG167_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC167_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC167_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC167_IN_SEL: u32 = 63;
pub const GPIO_FUNC167_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC167_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC168_IN_SEL_CFG_REG: u32 = 1072972752;
pub const GPIO_SIG168_IN_SEL_V: u32 = 1;
pub const GPIO_SIG168_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC168_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC168_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC168_IN_SEL: u32 = 63;
pub const GPIO_FUNC168_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC168_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC169_IN_SEL_CFG_REG: u32 = 1072972756;
pub const GPIO_SIG169_IN_SEL_V: u32 = 1;
pub const GPIO_SIG169_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC169_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC169_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC169_IN_SEL: u32 = 63;
pub const GPIO_FUNC169_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC169_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC170_IN_SEL_CFG_REG: u32 = 1072972760;
pub const GPIO_SIG170_IN_SEL_V: u32 = 1;
pub const GPIO_SIG170_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC170_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC170_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC170_IN_SEL: u32 = 63;
pub const GPIO_FUNC170_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC170_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC171_IN_SEL_CFG_REG: u32 = 1072972764;
pub const GPIO_SIG171_IN_SEL_V: u32 = 1;
pub const GPIO_SIG171_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC171_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC171_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC171_IN_SEL: u32 = 63;
pub const GPIO_FUNC171_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC171_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC172_IN_SEL_CFG_REG: u32 = 1072972768;
pub const GPIO_SIG172_IN_SEL_V: u32 = 1;
pub const GPIO_SIG172_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC172_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC172_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC172_IN_SEL: u32 = 63;
pub const GPIO_FUNC172_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC172_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC173_IN_SEL_CFG_REG: u32 = 1072972772;
pub const GPIO_SIG173_IN_SEL_V: u32 = 1;
pub const GPIO_SIG173_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC173_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC173_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC173_IN_SEL: u32 = 63;
pub const GPIO_FUNC173_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC173_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC174_IN_SEL_CFG_REG: u32 = 1072972776;
pub const GPIO_SIG174_IN_SEL_V: u32 = 1;
pub const GPIO_SIG174_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC174_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC174_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC174_IN_SEL: u32 = 63;
pub const GPIO_FUNC174_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC174_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC175_IN_SEL_CFG_REG: u32 = 1072972780;
pub const GPIO_SIG175_IN_SEL_V: u32 = 1;
pub const GPIO_SIG175_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC175_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC175_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC175_IN_SEL: u32 = 63;
pub const GPIO_FUNC175_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC175_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC176_IN_SEL_CFG_REG: u32 = 1072972784;
pub const GPIO_SIG176_IN_SEL_V: u32 = 1;
pub const GPIO_SIG176_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC176_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC176_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC176_IN_SEL: u32 = 63;
pub const GPIO_FUNC176_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC176_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC177_IN_SEL_CFG_REG: u32 = 1072972788;
pub const GPIO_SIG177_IN_SEL_V: u32 = 1;
pub const GPIO_SIG177_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC177_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC177_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC177_IN_SEL: u32 = 63;
pub const GPIO_FUNC177_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC177_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC178_IN_SEL_CFG_REG: u32 = 1072972792;
pub const GPIO_SIG178_IN_SEL_V: u32 = 1;
pub const GPIO_SIG178_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC178_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC178_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC178_IN_SEL: u32 = 63;
pub const GPIO_FUNC178_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC178_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC179_IN_SEL_CFG_REG: u32 = 1072972796;
pub const GPIO_SIG179_IN_SEL_V: u32 = 1;
pub const GPIO_SIG179_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC179_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC179_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC179_IN_SEL: u32 = 63;
pub const GPIO_FUNC179_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC179_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC180_IN_SEL_CFG_REG: u32 = 1072972800;
pub const GPIO_SIG180_IN_SEL_V: u32 = 1;
pub const GPIO_SIG180_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC180_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC180_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC180_IN_SEL: u32 = 63;
pub const GPIO_FUNC180_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC180_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC181_IN_SEL_CFG_REG: u32 = 1072972804;
pub const GPIO_SIG181_IN_SEL_V: u32 = 1;
pub const GPIO_SIG181_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC181_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC181_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC181_IN_SEL: u32 = 63;
pub const GPIO_FUNC181_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC181_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC182_IN_SEL_CFG_REG: u32 = 1072972808;
pub const GPIO_SIG182_IN_SEL_V: u32 = 1;
pub const GPIO_SIG182_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC182_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC182_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC182_IN_SEL: u32 = 63;
pub const GPIO_FUNC182_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC182_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC183_IN_SEL_CFG_REG: u32 = 1072972812;
pub const GPIO_SIG183_IN_SEL_V: u32 = 1;
pub const GPIO_SIG183_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC183_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC183_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC183_IN_SEL: u32 = 63;
pub const GPIO_FUNC183_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC183_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC184_IN_SEL_CFG_REG: u32 = 1072972816;
pub const GPIO_SIG184_IN_SEL_V: u32 = 1;
pub const GPIO_SIG184_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC184_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC184_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC184_IN_SEL: u32 = 63;
pub const GPIO_FUNC184_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC184_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC185_IN_SEL_CFG_REG: u32 = 1072972820;
pub const GPIO_SIG185_IN_SEL_V: u32 = 1;
pub const GPIO_SIG185_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC185_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC185_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC185_IN_SEL: u32 = 63;
pub const GPIO_FUNC185_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC185_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC186_IN_SEL_CFG_REG: u32 = 1072972824;
pub const GPIO_SIG186_IN_SEL_V: u32 = 1;
pub const GPIO_SIG186_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC186_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC186_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC186_IN_SEL: u32 = 63;
pub const GPIO_FUNC186_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC186_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC187_IN_SEL_CFG_REG: u32 = 1072972828;
pub const GPIO_SIG187_IN_SEL_V: u32 = 1;
pub const GPIO_SIG187_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC187_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC187_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC187_IN_SEL: u32 = 63;
pub const GPIO_FUNC187_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC187_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC188_IN_SEL_CFG_REG: u32 = 1072972832;
pub const GPIO_SIG188_IN_SEL_V: u32 = 1;
pub const GPIO_SIG188_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC188_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC188_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC188_IN_SEL: u32 = 63;
pub const GPIO_FUNC188_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC188_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC189_IN_SEL_CFG_REG: u32 = 1072972836;
pub const GPIO_SIG189_IN_SEL_V: u32 = 1;
pub const GPIO_SIG189_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC189_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC189_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC189_IN_SEL: u32 = 63;
pub const GPIO_FUNC189_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC189_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC190_IN_SEL_CFG_REG: u32 = 1072972840;
pub const GPIO_SIG190_IN_SEL_V: u32 = 1;
pub const GPIO_SIG190_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC190_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC190_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC190_IN_SEL: u32 = 63;
pub const GPIO_FUNC190_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC190_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC191_IN_SEL_CFG_REG: u32 = 1072972844;
pub const GPIO_SIG191_IN_SEL_V: u32 = 1;
pub const GPIO_SIG191_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC191_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC191_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC191_IN_SEL: u32 = 63;
pub const GPIO_FUNC191_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC191_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC192_IN_SEL_CFG_REG: u32 = 1072972848;
pub const GPIO_SIG192_IN_SEL_V: u32 = 1;
pub const GPIO_SIG192_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC192_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC192_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC192_IN_SEL: u32 = 63;
pub const GPIO_FUNC192_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC192_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC193_IN_SEL_CFG_REG: u32 = 1072972852;
pub const GPIO_SIG193_IN_SEL_V: u32 = 1;
pub const GPIO_SIG193_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC193_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC193_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC193_IN_SEL: u32 = 63;
pub const GPIO_FUNC193_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC193_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC194_IN_SEL_CFG_REG: u32 = 1072972856;
pub const GPIO_SIG194_IN_SEL_V: u32 = 1;
pub const GPIO_SIG194_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC194_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC194_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC194_IN_SEL: u32 = 63;
pub const GPIO_FUNC194_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC194_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC195_IN_SEL_CFG_REG: u32 = 1072972860;
pub const GPIO_SIG195_IN_SEL_V: u32 = 1;
pub const GPIO_SIG195_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC195_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC195_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC195_IN_SEL: u32 = 63;
pub const GPIO_FUNC195_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC195_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC196_IN_SEL_CFG_REG: u32 = 1072972864;
pub const GPIO_SIG196_IN_SEL_V: u32 = 1;
pub const GPIO_SIG196_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC196_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC196_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC196_IN_SEL: u32 = 63;
pub const GPIO_FUNC196_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC196_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC197_IN_SEL_CFG_REG: u32 = 1072972868;
pub const GPIO_SIG197_IN_SEL_V: u32 = 1;
pub const GPIO_SIG197_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC197_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC197_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC197_IN_SEL: u32 = 63;
pub const GPIO_FUNC197_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC197_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC198_IN_SEL_CFG_REG: u32 = 1072972872;
pub const GPIO_SIG198_IN_SEL_V: u32 = 1;
pub const GPIO_SIG198_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC198_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC198_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC198_IN_SEL: u32 = 63;
pub const GPIO_FUNC198_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC198_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC199_IN_SEL_CFG_REG: u32 = 1072972876;
pub const GPIO_SIG199_IN_SEL_V: u32 = 1;
pub const GPIO_SIG199_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC199_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC199_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC199_IN_SEL: u32 = 63;
pub const GPIO_FUNC199_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC199_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC200_IN_SEL_CFG_REG: u32 = 1072972880;
pub const GPIO_SIG200_IN_SEL_V: u32 = 1;
pub const GPIO_SIG200_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC200_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC200_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC200_IN_SEL: u32 = 63;
pub const GPIO_FUNC200_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC200_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC201_IN_SEL_CFG_REG: u32 = 1072972884;
pub const GPIO_SIG201_IN_SEL_V: u32 = 1;
pub const GPIO_SIG201_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC201_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC201_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC201_IN_SEL: u32 = 63;
pub const GPIO_FUNC201_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC201_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC202_IN_SEL_CFG_REG: u32 = 1072972888;
pub const GPIO_SIG202_IN_SEL_V: u32 = 1;
pub const GPIO_SIG202_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC202_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC202_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC202_IN_SEL: u32 = 63;
pub const GPIO_FUNC202_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC202_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC203_IN_SEL_CFG_REG: u32 = 1072972892;
pub const GPIO_SIG203_IN_SEL_V: u32 = 1;
pub const GPIO_SIG203_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC203_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC203_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC203_IN_SEL: u32 = 63;
pub const GPIO_FUNC203_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC203_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC204_IN_SEL_CFG_REG: u32 = 1072972896;
pub const GPIO_SIG204_IN_SEL_V: u32 = 1;
pub const GPIO_SIG204_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC204_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC204_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC204_IN_SEL: u32 = 63;
pub const GPIO_FUNC204_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC204_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC205_IN_SEL_CFG_REG: u32 = 1072972900;
pub const GPIO_SIG205_IN_SEL_V: u32 = 1;
pub const GPIO_SIG205_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC205_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC205_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC205_IN_SEL: u32 = 63;
pub const GPIO_FUNC205_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC205_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC206_IN_SEL_CFG_REG: u32 = 1072972904;
pub const GPIO_SIG206_IN_SEL_V: u32 = 1;
pub const GPIO_SIG206_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC206_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC206_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC206_IN_SEL: u32 = 63;
pub const GPIO_FUNC206_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC206_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC207_IN_SEL_CFG_REG: u32 = 1072972908;
pub const GPIO_SIG207_IN_SEL_V: u32 = 1;
pub const GPIO_SIG207_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC207_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC207_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC207_IN_SEL: u32 = 63;
pub const GPIO_FUNC207_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC207_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC208_IN_SEL_CFG_REG: u32 = 1072972912;
pub const GPIO_SIG208_IN_SEL_V: u32 = 1;
pub const GPIO_SIG208_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC208_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC208_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC208_IN_SEL: u32 = 63;
pub const GPIO_FUNC208_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC208_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC209_IN_SEL_CFG_REG: u32 = 1072972916;
pub const GPIO_SIG209_IN_SEL_V: u32 = 1;
pub const GPIO_SIG209_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC209_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC209_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC209_IN_SEL: u32 = 63;
pub const GPIO_FUNC209_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC209_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC210_IN_SEL_CFG_REG: u32 = 1072972920;
pub const GPIO_SIG210_IN_SEL_V: u32 = 1;
pub const GPIO_SIG210_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC210_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC210_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC210_IN_SEL: u32 = 63;
pub const GPIO_FUNC210_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC210_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC211_IN_SEL_CFG_REG: u32 = 1072972924;
pub const GPIO_SIG211_IN_SEL_V: u32 = 1;
pub const GPIO_SIG211_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC211_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC211_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC211_IN_SEL: u32 = 63;
pub const GPIO_FUNC211_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC211_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC212_IN_SEL_CFG_REG: u32 = 1072972928;
pub const GPIO_SIG212_IN_SEL_V: u32 = 1;
pub const GPIO_SIG212_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC212_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC212_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC212_IN_SEL: u32 = 63;
pub const GPIO_FUNC212_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC212_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC213_IN_SEL_CFG_REG: u32 = 1072972932;
pub const GPIO_SIG213_IN_SEL_V: u32 = 1;
pub const GPIO_SIG213_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC213_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC213_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC213_IN_SEL: u32 = 63;
pub const GPIO_FUNC213_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC213_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC214_IN_SEL_CFG_REG: u32 = 1072972936;
pub const GPIO_SIG214_IN_SEL_V: u32 = 1;
pub const GPIO_SIG214_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC214_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC214_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC214_IN_SEL: u32 = 63;
pub const GPIO_FUNC214_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC214_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC215_IN_SEL_CFG_REG: u32 = 1072972940;
pub const GPIO_SIG215_IN_SEL_V: u32 = 1;
pub const GPIO_SIG215_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC215_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC215_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC215_IN_SEL: u32 = 63;
pub const GPIO_FUNC215_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC215_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC216_IN_SEL_CFG_REG: u32 = 1072972944;
pub const GPIO_SIG216_IN_SEL_V: u32 = 1;
pub const GPIO_SIG216_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC216_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC216_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC216_IN_SEL: u32 = 63;
pub const GPIO_FUNC216_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC216_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC217_IN_SEL_CFG_REG: u32 = 1072972948;
pub const GPIO_SIG217_IN_SEL_V: u32 = 1;
pub const GPIO_SIG217_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC217_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC217_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC217_IN_SEL: u32 = 63;
pub const GPIO_FUNC217_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC217_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC218_IN_SEL_CFG_REG: u32 = 1072972952;
pub const GPIO_SIG218_IN_SEL_V: u32 = 1;
pub const GPIO_SIG218_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC218_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC218_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC218_IN_SEL: u32 = 63;
pub const GPIO_FUNC218_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC218_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC219_IN_SEL_CFG_REG: u32 = 1072972956;
pub const GPIO_SIG219_IN_SEL_V: u32 = 1;
pub const GPIO_SIG219_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC219_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC219_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC219_IN_SEL: u32 = 63;
pub const GPIO_FUNC219_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC219_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC220_IN_SEL_CFG_REG: u32 = 1072972960;
pub const GPIO_SIG220_IN_SEL_V: u32 = 1;
pub const GPIO_SIG220_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC220_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC220_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC220_IN_SEL: u32 = 63;
pub const GPIO_FUNC220_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC220_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC221_IN_SEL_CFG_REG: u32 = 1072972964;
pub const GPIO_SIG221_IN_SEL_V: u32 = 1;
pub const GPIO_SIG221_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC221_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC221_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC221_IN_SEL: u32 = 63;
pub const GPIO_FUNC221_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC221_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC222_IN_SEL_CFG_REG: u32 = 1072972968;
pub const GPIO_SIG222_IN_SEL_V: u32 = 1;
pub const GPIO_SIG222_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC222_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC222_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC222_IN_SEL: u32 = 63;
pub const GPIO_FUNC222_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC222_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC223_IN_SEL_CFG_REG: u32 = 1072972972;
pub const GPIO_SIG223_IN_SEL_V: u32 = 1;
pub const GPIO_SIG223_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC223_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC223_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC223_IN_SEL: u32 = 63;
pub const GPIO_FUNC223_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC223_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC224_IN_SEL_CFG_REG: u32 = 1072972976;
pub const GPIO_SIG224_IN_SEL_V: u32 = 1;
pub const GPIO_SIG224_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC224_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC224_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC224_IN_SEL: u32 = 63;
pub const GPIO_FUNC224_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC224_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC225_IN_SEL_CFG_REG: u32 = 1072972980;
pub const GPIO_SIG225_IN_SEL_V: u32 = 1;
pub const GPIO_SIG225_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC225_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC225_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC225_IN_SEL: u32 = 63;
pub const GPIO_FUNC225_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC225_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC226_IN_SEL_CFG_REG: u32 = 1072972984;
pub const GPIO_SIG226_IN_SEL_V: u32 = 1;
pub const GPIO_SIG226_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC226_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC226_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC226_IN_SEL: u32 = 63;
pub const GPIO_FUNC226_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC226_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC227_IN_SEL_CFG_REG: u32 = 1072972988;
pub const GPIO_SIG227_IN_SEL_V: u32 = 1;
pub const GPIO_SIG227_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC227_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC227_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC227_IN_SEL: u32 = 63;
pub const GPIO_FUNC227_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC227_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC228_IN_SEL_CFG_REG: u32 = 1072972992;
pub const GPIO_SIG228_IN_SEL_V: u32 = 1;
pub const GPIO_SIG228_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC228_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC228_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC228_IN_SEL: u32 = 63;
pub const GPIO_FUNC228_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC228_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC229_IN_SEL_CFG_REG: u32 = 1072972996;
pub const GPIO_SIG229_IN_SEL_V: u32 = 1;
pub const GPIO_SIG229_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC229_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC229_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC229_IN_SEL: u32 = 63;
pub const GPIO_FUNC229_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC229_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC230_IN_SEL_CFG_REG: u32 = 1072973000;
pub const GPIO_SIG230_IN_SEL_V: u32 = 1;
pub const GPIO_SIG230_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC230_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC230_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC230_IN_SEL: u32 = 63;
pub const GPIO_FUNC230_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC230_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC231_IN_SEL_CFG_REG: u32 = 1072973004;
pub const GPIO_SIG231_IN_SEL_V: u32 = 1;
pub const GPIO_SIG231_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC231_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC231_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC231_IN_SEL: u32 = 63;
pub const GPIO_FUNC231_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC231_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC232_IN_SEL_CFG_REG: u32 = 1072973008;
pub const GPIO_SIG232_IN_SEL_V: u32 = 1;
pub const GPIO_SIG232_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC232_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC232_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC232_IN_SEL: u32 = 63;
pub const GPIO_FUNC232_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC232_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC233_IN_SEL_CFG_REG: u32 = 1072973012;
pub const GPIO_SIG233_IN_SEL_V: u32 = 1;
pub const GPIO_SIG233_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC233_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC233_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC233_IN_SEL: u32 = 63;
pub const GPIO_FUNC233_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC233_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC234_IN_SEL_CFG_REG: u32 = 1072973016;
pub const GPIO_SIG234_IN_SEL_V: u32 = 1;
pub const GPIO_SIG234_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC234_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC234_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC234_IN_SEL: u32 = 63;
pub const GPIO_FUNC234_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC234_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC235_IN_SEL_CFG_REG: u32 = 1072973020;
pub const GPIO_SIG235_IN_SEL_V: u32 = 1;
pub const GPIO_SIG235_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC235_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC235_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC235_IN_SEL: u32 = 63;
pub const GPIO_FUNC235_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC235_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC236_IN_SEL_CFG_REG: u32 = 1072973024;
pub const GPIO_SIG236_IN_SEL_V: u32 = 1;
pub const GPIO_SIG236_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC236_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC236_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC236_IN_SEL: u32 = 63;
pub const GPIO_FUNC236_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC236_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC237_IN_SEL_CFG_REG: u32 = 1072973028;
pub const GPIO_SIG237_IN_SEL_V: u32 = 1;
pub const GPIO_SIG237_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC237_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC237_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC237_IN_SEL: u32 = 63;
pub const GPIO_FUNC237_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC237_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC238_IN_SEL_CFG_REG: u32 = 1072973032;
pub const GPIO_SIG238_IN_SEL_V: u32 = 1;
pub const GPIO_SIG238_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC238_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC238_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC238_IN_SEL: u32 = 63;
pub const GPIO_FUNC238_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC238_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC239_IN_SEL_CFG_REG: u32 = 1072973036;
pub const GPIO_SIG239_IN_SEL_V: u32 = 1;
pub const GPIO_SIG239_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC239_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC239_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC239_IN_SEL: u32 = 63;
pub const GPIO_FUNC239_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC239_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC240_IN_SEL_CFG_REG: u32 = 1072973040;
pub const GPIO_SIG240_IN_SEL_V: u32 = 1;
pub const GPIO_SIG240_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC240_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC240_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC240_IN_SEL: u32 = 63;
pub const GPIO_FUNC240_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC240_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC241_IN_SEL_CFG_REG: u32 = 1072973044;
pub const GPIO_SIG241_IN_SEL_V: u32 = 1;
pub const GPIO_SIG241_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC241_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC241_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC241_IN_SEL: u32 = 63;
pub const GPIO_FUNC241_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC241_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC242_IN_SEL_CFG_REG: u32 = 1072973048;
pub const GPIO_SIG242_IN_SEL_V: u32 = 1;
pub const GPIO_SIG242_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC242_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC242_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC242_IN_SEL: u32 = 63;
pub const GPIO_FUNC242_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC242_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC243_IN_SEL_CFG_REG: u32 = 1072973052;
pub const GPIO_SIG243_IN_SEL_V: u32 = 1;
pub const GPIO_SIG243_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC243_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC243_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC243_IN_SEL: u32 = 63;
pub const GPIO_FUNC243_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC243_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC244_IN_SEL_CFG_REG: u32 = 1072973056;
pub const GPIO_SIG244_IN_SEL_V: u32 = 1;
pub const GPIO_SIG244_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC244_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC244_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC244_IN_SEL: u32 = 63;
pub const GPIO_FUNC244_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC244_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC245_IN_SEL_CFG_REG: u32 = 1072973060;
pub const GPIO_SIG245_IN_SEL_V: u32 = 1;
pub const GPIO_SIG245_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC245_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC245_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC245_IN_SEL: u32 = 63;
pub const GPIO_FUNC245_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC245_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC246_IN_SEL_CFG_REG: u32 = 1072973064;
pub const GPIO_SIG246_IN_SEL_V: u32 = 1;
pub const GPIO_SIG246_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC246_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC246_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC246_IN_SEL: u32 = 63;
pub const GPIO_FUNC246_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC246_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC247_IN_SEL_CFG_REG: u32 = 1072973068;
pub const GPIO_SIG247_IN_SEL_V: u32 = 1;
pub const GPIO_SIG247_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC247_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC247_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC247_IN_SEL: u32 = 63;
pub const GPIO_FUNC247_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC247_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC248_IN_SEL_CFG_REG: u32 = 1072973072;
pub const GPIO_SIG248_IN_SEL_V: u32 = 1;
pub const GPIO_SIG248_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC248_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC248_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC248_IN_SEL: u32 = 63;
pub const GPIO_FUNC248_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC248_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC249_IN_SEL_CFG_REG: u32 = 1072973076;
pub const GPIO_SIG249_IN_SEL_V: u32 = 1;
pub const GPIO_SIG249_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC249_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC249_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC249_IN_SEL: u32 = 63;
pub const GPIO_FUNC249_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC249_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC250_IN_SEL_CFG_REG: u32 = 1072973080;
pub const GPIO_SIG250_IN_SEL_V: u32 = 1;
pub const GPIO_SIG250_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC250_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC250_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC250_IN_SEL: u32 = 63;
pub const GPIO_FUNC250_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC250_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC251_IN_SEL_CFG_REG: u32 = 1072973084;
pub const GPIO_SIG251_IN_SEL_V: u32 = 1;
pub const GPIO_SIG251_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC251_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC251_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC251_IN_SEL: u32 = 63;
pub const GPIO_FUNC251_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC251_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC252_IN_SEL_CFG_REG: u32 = 1072973088;
pub const GPIO_SIG252_IN_SEL_V: u32 = 1;
pub const GPIO_SIG252_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC252_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC252_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC252_IN_SEL: u32 = 63;
pub const GPIO_FUNC252_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC252_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC253_IN_SEL_CFG_REG: u32 = 1072973092;
pub const GPIO_SIG253_IN_SEL_V: u32 = 1;
pub const GPIO_SIG253_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC253_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC253_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC253_IN_SEL: u32 = 63;
pub const GPIO_FUNC253_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC253_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC254_IN_SEL_CFG_REG: u32 = 1072973096;
pub const GPIO_SIG254_IN_SEL_V: u32 = 1;
pub const GPIO_SIG254_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC254_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC254_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC254_IN_SEL: u32 = 63;
pub const GPIO_FUNC254_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC254_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC255_IN_SEL_CFG_REG: u32 = 1072973100;
pub const GPIO_SIG255_IN_SEL_V: u32 = 1;
pub const GPIO_SIG255_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC255_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC255_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC255_IN_SEL: u32 = 63;
pub const GPIO_FUNC255_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC255_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC0_OUT_SEL_CFG_REG: u32 = 1072973104;
pub const GPIO_FUNC0_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC0_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC0_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC0_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC0_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC0_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC0_OUT_SEL: u32 = 511;
pub const GPIO_FUNC0_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC0_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC1_OUT_SEL_CFG_REG: u32 = 1072973108;
pub const GPIO_FUNC1_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC1_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC1_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC1_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC1_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC1_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC1_OUT_SEL: u32 = 511;
pub const GPIO_FUNC1_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC1_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC2_OUT_SEL_CFG_REG: u32 = 1072973112;
pub const GPIO_FUNC2_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC2_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC2_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC2_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC2_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC2_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC2_OUT_SEL: u32 = 511;
pub const GPIO_FUNC2_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC2_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC3_OUT_SEL_CFG_REG: u32 = 1072973116;
pub const GPIO_FUNC3_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC3_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC3_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC3_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC3_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC3_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC3_OUT_SEL: u32 = 511;
pub const GPIO_FUNC3_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC3_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC4_OUT_SEL_CFG_REG: u32 = 1072973120;
pub const GPIO_FUNC4_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC4_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC4_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC4_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC4_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC4_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC4_OUT_SEL: u32 = 511;
pub const GPIO_FUNC4_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC4_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC5_OUT_SEL_CFG_REG: u32 = 1072973124;
pub const GPIO_FUNC5_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC5_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC5_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC5_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC5_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC5_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC5_OUT_SEL: u32 = 511;
pub const GPIO_FUNC5_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC5_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC6_OUT_SEL_CFG_REG: u32 = 1072973128;
pub const GPIO_FUNC6_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC6_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC6_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC6_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC6_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC6_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC6_OUT_SEL: u32 = 511;
pub const GPIO_FUNC6_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC6_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC7_OUT_SEL_CFG_REG: u32 = 1072973132;
pub const GPIO_FUNC7_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC7_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC7_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC7_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC7_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC7_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC7_OUT_SEL: u32 = 511;
pub const GPIO_FUNC7_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC7_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC8_OUT_SEL_CFG_REG: u32 = 1072973136;
pub const GPIO_FUNC8_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC8_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC8_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC8_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC8_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC8_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC8_OUT_SEL: u32 = 511;
pub const GPIO_FUNC8_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC8_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC9_OUT_SEL_CFG_REG: u32 = 1072973140;
pub const GPIO_FUNC9_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC9_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC9_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC9_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC9_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC9_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC9_OUT_SEL: u32 = 511;
pub const GPIO_FUNC9_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC9_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC10_OUT_SEL_CFG_REG: u32 = 1072973144;
pub const GPIO_FUNC10_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC10_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC10_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC10_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC10_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC10_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC10_OUT_SEL: u32 = 511;
pub const GPIO_FUNC10_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC10_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC11_OUT_SEL_CFG_REG: u32 = 1072973148;
pub const GPIO_FUNC11_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC11_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC11_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC11_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC11_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC11_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC11_OUT_SEL: u32 = 511;
pub const GPIO_FUNC11_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC11_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC12_OUT_SEL_CFG_REG: u32 = 1072973152;
pub const GPIO_FUNC12_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC12_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC12_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC12_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC12_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC12_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC12_OUT_SEL: u32 = 511;
pub const GPIO_FUNC12_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC12_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC13_OUT_SEL_CFG_REG: u32 = 1072973156;
pub const GPIO_FUNC13_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC13_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC13_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC13_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC13_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC13_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC13_OUT_SEL: u32 = 511;
pub const GPIO_FUNC13_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC13_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC14_OUT_SEL_CFG_REG: u32 = 1072973160;
pub const GPIO_FUNC14_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC14_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC14_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC14_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC14_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC14_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC14_OUT_SEL: u32 = 511;
pub const GPIO_FUNC14_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC14_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC15_OUT_SEL_CFG_REG: u32 = 1072973164;
pub const GPIO_FUNC15_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC15_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC15_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC15_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC15_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC15_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC15_OUT_SEL: u32 = 511;
pub const GPIO_FUNC15_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC15_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC16_OUT_SEL_CFG_REG: u32 = 1072973168;
pub const GPIO_FUNC16_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC16_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC16_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC16_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC16_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC16_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC16_OUT_SEL: u32 = 511;
pub const GPIO_FUNC16_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC16_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC17_OUT_SEL_CFG_REG: u32 = 1072973172;
pub const GPIO_FUNC17_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC17_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC17_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC17_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC17_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC17_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC17_OUT_SEL: u32 = 511;
pub const GPIO_FUNC17_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC17_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC18_OUT_SEL_CFG_REG: u32 = 1072973176;
pub const GPIO_FUNC18_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC18_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC18_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC18_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC18_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC18_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC18_OUT_SEL: u32 = 511;
pub const GPIO_FUNC18_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC18_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC19_OUT_SEL_CFG_REG: u32 = 1072973180;
pub const GPIO_FUNC19_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC19_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC19_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC19_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC19_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC19_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC19_OUT_SEL: u32 = 511;
pub const GPIO_FUNC19_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC19_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC20_OUT_SEL_CFG_REG: u32 = 1072973184;
pub const GPIO_FUNC20_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC20_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC20_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC20_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC20_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC20_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC20_OUT_SEL: u32 = 511;
pub const GPIO_FUNC20_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC20_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC21_OUT_SEL_CFG_REG: u32 = 1072973188;
pub const GPIO_FUNC21_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC21_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC21_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC21_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC21_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC21_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC21_OUT_SEL: u32 = 511;
pub const GPIO_FUNC21_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC21_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC22_OUT_SEL_CFG_REG: u32 = 1072973192;
pub const GPIO_FUNC22_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC22_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC22_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC22_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC22_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC22_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC22_OUT_SEL: u32 = 511;
pub const GPIO_FUNC22_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC22_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC23_OUT_SEL_CFG_REG: u32 = 1072973196;
pub const GPIO_FUNC23_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC23_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC23_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC23_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC23_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC23_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC23_OUT_SEL: u32 = 511;
pub const GPIO_FUNC23_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC23_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC24_OUT_SEL_CFG_REG: u32 = 1072973200;
pub const GPIO_FUNC24_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC24_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC24_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC24_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC24_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC24_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC24_OUT_SEL: u32 = 511;
pub const GPIO_FUNC24_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC24_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC25_OUT_SEL_CFG_REG: u32 = 1072973204;
pub const GPIO_FUNC25_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC25_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC25_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC25_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC25_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC25_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC25_OUT_SEL: u32 = 511;
pub const GPIO_FUNC25_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC25_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC26_OUT_SEL_CFG_REG: u32 = 1072973208;
pub const GPIO_FUNC26_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC26_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC26_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC26_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC26_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC26_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC26_OUT_SEL: u32 = 511;
pub const GPIO_FUNC26_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC26_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC27_OUT_SEL_CFG_REG: u32 = 1072973212;
pub const GPIO_FUNC27_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC27_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC27_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC27_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC27_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC27_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC27_OUT_SEL: u32 = 511;
pub const GPIO_FUNC27_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC27_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC28_OUT_SEL_CFG_REG: u32 = 1072973216;
pub const GPIO_FUNC28_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC28_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC28_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC28_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC28_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC28_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC28_OUT_SEL: u32 = 511;
pub const GPIO_FUNC28_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC28_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC29_OUT_SEL_CFG_REG: u32 = 1072973220;
pub const GPIO_FUNC29_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC29_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC29_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC29_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC29_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC29_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC29_OUT_SEL: u32 = 511;
pub const GPIO_FUNC29_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC29_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC30_OUT_SEL_CFG_REG: u32 = 1072973224;
pub const GPIO_FUNC30_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC30_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC30_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC30_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC30_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC30_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC30_OUT_SEL: u32 = 511;
pub const GPIO_FUNC30_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC30_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC31_OUT_SEL_CFG_REG: u32 = 1072973228;
pub const GPIO_FUNC31_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC31_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC31_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC31_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC31_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC31_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC31_OUT_SEL: u32 = 511;
pub const GPIO_FUNC31_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC31_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC32_OUT_SEL_CFG_REG: u32 = 1072973232;
pub const GPIO_FUNC32_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC32_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC32_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC32_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC32_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC32_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC32_OUT_SEL: u32 = 511;
pub const GPIO_FUNC32_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC32_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC33_OUT_SEL_CFG_REG: u32 = 1072973236;
pub const GPIO_FUNC33_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC33_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC33_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC33_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC33_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC33_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC33_OUT_SEL: u32 = 511;
pub const GPIO_FUNC33_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC33_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC34_OUT_SEL_CFG_REG: u32 = 1072973240;
pub const GPIO_FUNC34_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC34_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC34_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC34_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC34_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC34_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC34_OUT_SEL: u32 = 511;
pub const GPIO_FUNC34_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC34_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC35_OUT_SEL_CFG_REG: u32 = 1072973244;
pub const GPIO_FUNC35_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC35_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC35_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC35_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC35_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC35_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC35_OUT_SEL: u32 = 511;
pub const GPIO_FUNC35_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC35_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC36_OUT_SEL_CFG_REG: u32 = 1072973248;
pub const GPIO_FUNC36_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC36_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC36_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC36_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC36_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC36_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC36_OUT_SEL: u32 = 511;
pub const GPIO_FUNC36_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC36_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC37_OUT_SEL_CFG_REG: u32 = 1072973252;
pub const GPIO_FUNC37_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC37_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC37_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC37_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC37_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC37_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC37_OUT_SEL: u32 = 511;
pub const GPIO_FUNC37_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC37_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC38_OUT_SEL_CFG_REG: u32 = 1072973256;
pub const GPIO_FUNC38_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC38_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC38_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC38_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC38_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC38_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC38_OUT_SEL: u32 = 511;
pub const GPIO_FUNC38_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC38_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC39_OUT_SEL_CFG_REG: u32 = 1072973260;
pub const GPIO_FUNC39_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC39_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC39_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC39_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC39_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC39_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC39_OUT_SEL: u32 = 511;
pub const GPIO_FUNC39_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC39_OUT_SEL_S: u32 = 0;
pub const SPICLK_IN_IDX: u32 = 0;
pub const SPICLK_OUT_IDX: u32 = 0;
pub const SPIQ_IN_IDX: u32 = 1;
pub const SPIQ_OUT_IDX: u32 = 1;
pub const SPID_IN_IDX: u32 = 2;
pub const SPID_OUT_IDX: u32 = 2;
pub const SPIHD_IN_IDX: u32 = 3;
pub const SPIHD_OUT_IDX: u32 = 3;
pub const SPIWP_IN_IDX: u32 = 4;
pub const SPIWP_OUT_IDX: u32 = 4;
pub const SPICS0_IN_IDX: u32 = 5;
pub const SPICS0_OUT_IDX: u32 = 5;
pub const SPICS1_IN_IDX: u32 = 6;
pub const SPICS1_OUT_IDX: u32 = 6;
pub const SPICS2_IN_IDX: u32 = 7;
pub const SPICS2_OUT_IDX: u32 = 7;
pub const HSPICLK_IN_IDX: u32 = 8;
pub const HSPICLK_OUT_IDX: u32 = 8;
pub const HSPIQ_IN_IDX: u32 = 9;
pub const HSPIQ_OUT_IDX: u32 = 9;
pub const HSPID_IN_IDX: u32 = 10;
pub const HSPID_OUT_IDX: u32 = 10;
pub const HSPICS0_IN_IDX: u32 = 11;
pub const HSPICS0_OUT_IDX: u32 = 11;
pub const HSPIHD_IN_IDX: u32 = 12;
pub const HSPIHD_OUT_IDX: u32 = 12;
pub const HSPIWP_IN_IDX: u32 = 13;
pub const HSPIWP_OUT_IDX: u32 = 13;
pub const U0RXD_IN_IDX: u32 = 14;
pub const U0TXD_OUT_IDX: u32 = 14;
pub const U0CTS_IN_IDX: u32 = 15;
pub const U0RTS_OUT_IDX: u32 = 15;
pub const U0DSR_IN_IDX: u32 = 16;
pub const U0DTR_OUT_IDX: u32 = 16;
pub const U1RXD_IN_IDX: u32 = 17;
pub const U1TXD_OUT_IDX: u32 = 17;
pub const U1CTS_IN_IDX: u32 = 18;
pub const U1RTS_OUT_IDX: u32 = 18;
pub const I2CM_SCL_O_IDX: u32 = 19;
pub const I2CM_SDA_I_IDX: u32 = 20;
pub const I2CM_SDA_O_IDX: u32 = 20;
pub const EXT_I2C_SCL_O_IDX: u32 = 21;
pub const EXT_I2C_SDA_O_IDX: u32 = 22;
pub const EXT_I2C_SDA_I_IDX: u32 = 22;
pub const I2S0O_BCK_IN_IDX: u32 = 23;
pub const I2S0O_BCK_OUT_IDX: u32 = 23;
pub const I2S1O_BCK_IN_IDX: u32 = 24;
pub const I2S1O_BCK_OUT_IDX: u32 = 24;
pub const I2S0O_WS_IN_IDX: u32 = 25;
pub const I2S0O_WS_OUT_IDX: u32 = 25;
pub const I2S1O_WS_IN_IDX: u32 = 26;
pub const I2S1O_WS_OUT_IDX: u32 = 26;
pub const I2S0I_BCK_IN_IDX: u32 = 27;
pub const I2S0I_BCK_OUT_IDX: u32 = 27;
pub const I2S0I_WS_IN_IDX: u32 = 28;
pub const I2S0I_WS_OUT_IDX: u32 = 28;
pub const I2CEXT0_SCL_IN_IDX: u32 = 29;
pub const I2CEXT0_SCL_OUT_IDX: u32 = 29;
pub const I2CEXT0_SDA_IN_IDX: u32 = 30;
pub const I2CEXT0_SDA_OUT_IDX: u32 = 30;
pub const PWM0_SYNC0_IN_IDX: u32 = 31;
pub const SDIO_TOHOST_INT_OUT_IDX: u32 = 31;
pub const PWM0_SYNC1_IN_IDX: u32 = 32;
pub const PWM0_OUT0A_IDX: u32 = 32;
pub const PWM0_SYNC2_IN_IDX: u32 = 33;
pub const PWM0_OUT0B_IDX: u32 = 33;
pub const PWM0_F0_IN_IDX: u32 = 34;
pub const PWM0_OUT1A_IDX: u32 = 34;
pub const PWM0_F1_IN_IDX: u32 = 35;
pub const PWM0_OUT1B_IDX: u32 = 35;
pub const PWM0_F2_IN_IDX: u32 = 36;
pub const PWM0_OUT2A_IDX: u32 = 36;
pub const GPIO_BT_ACTIVE_IDX: u32 = 37;
pub const PWM0_OUT2B_IDX: u32 = 37;
pub const GPIO_BT_PRIORITY_IDX: u32 = 38;
pub const PCNT_SIG_CH0_IN0_IDX: u32 = 39;
pub const PCNT_SIG_CH1_IN0_IDX: u32 = 40;
pub const GPIO_WLAN_ACTIVE_IDX: u32 = 40;
pub const PCNT_CTRL_CH0_IN0_IDX: u32 = 41;
pub const BB_DIAG0_IDX: u32 = 41;
pub const PCNT_CTRL_CH1_IN0_IDX: u32 = 42;
pub const BB_DIAG1_IDX: u32 = 42;
pub const PCNT_SIG_CH0_IN1_IDX: u32 = 43;
pub const BB_DIAG2_IDX: u32 = 43;
pub const PCNT_SIG_CH1_IN1_IDX: u32 = 44;
pub const BB_DIAG3_IDX: u32 = 44;
pub const PCNT_CTRL_CH0_IN1_IDX: u32 = 45;
pub const BB_DIAG4_IDX: u32 = 45;
pub const PCNT_CTRL_CH1_IN1_IDX: u32 = 46;
pub const BB_DIAG5_IDX: u32 = 46;
pub const PCNT_SIG_CH0_IN2_IDX: u32 = 47;
pub const BB_DIAG6_IDX: u32 = 47;
pub const PCNT_SIG_CH1_IN2_IDX: u32 = 48;
pub const BB_DIAG7_IDX: u32 = 48;
pub const PCNT_CTRL_CH0_IN2_IDX: u32 = 49;
pub const BB_DIAG8_IDX: u32 = 49;
pub const PCNT_CTRL_CH1_IN2_IDX: u32 = 50;
pub const BB_DIAG9_IDX: u32 = 50;
pub const PCNT_SIG_CH0_IN3_IDX: u32 = 51;
pub const BB_DIAG10_IDX: u32 = 51;
pub const PCNT_SIG_CH1_IN3_IDX: u32 = 52;
pub const BB_DIAG11_IDX: u32 = 52;
pub const PCNT_CTRL_CH0_IN3_IDX: u32 = 53;
pub const BB_DIAG12_IDX: u32 = 53;
pub const PCNT_CTRL_CH1_IN3_IDX: u32 = 54;
pub const BB_DIAG13_IDX: u32 = 54;
pub const PCNT_SIG_CH0_IN4_IDX: u32 = 55;
pub const BB_DIAG14_IDX: u32 = 55;
pub const PCNT_SIG_CH1_IN4_IDX: u32 = 56;
pub const BB_DIAG15_IDX: u32 = 56;
pub const PCNT_CTRL_CH0_IN4_IDX: u32 = 57;
pub const BB_DIAG16_IDX: u32 = 57;
pub const PCNT_CTRL_CH1_IN4_IDX: u32 = 58;
pub const BB_DIAG17_IDX: u32 = 58;
pub const BB_DIAG18_IDX: u32 = 59;
pub const BB_DIAG19_IDX: u32 = 60;
pub const HSPICS1_IN_IDX: u32 = 61;
pub const HSPICS1_OUT_IDX: u32 = 61;
pub const HSPICS2_IN_IDX: u32 = 62;
pub const HSPICS2_OUT_IDX: u32 = 62;
pub const VSPICLK_IN_IDX: u32 = 63;
pub const VSPICLK_OUT_IDX: u32 = 63;
pub const VSPIQ_IN_IDX: u32 = 64;
pub const VSPIQ_OUT_IDX: u32 = 64;
pub const VSPID_IN_IDX: u32 = 65;
pub const VSPID_OUT_IDX: u32 = 65;
pub const VSPIHD_IN_IDX: u32 = 66;
pub const VSPIHD_OUT_IDX: u32 = 66;
pub const VSPIWP_IN_IDX: u32 = 67;
pub const VSPIWP_OUT_IDX: u32 = 67;
pub const VSPICS0_IN_IDX: u32 = 68;
pub const VSPICS0_OUT_IDX: u32 = 68;
pub const VSPICS1_IN_IDX: u32 = 69;
pub const VSPICS1_OUT_IDX: u32 = 69;
pub const VSPICS2_IN_IDX: u32 = 70;
pub const VSPICS2_OUT_IDX: u32 = 70;
pub const PCNT_SIG_CH0_IN5_IDX: u32 = 71;
pub const LEDC_HS_SIG_OUT0_IDX: u32 = 71;
pub const PCNT_SIG_CH1_IN5_IDX: u32 = 72;
pub const LEDC_HS_SIG_OUT1_IDX: u32 = 72;
pub const PCNT_CTRL_CH0_IN5_IDX: u32 = 73;
pub const LEDC_HS_SIG_OUT2_IDX: u32 = 73;
pub const PCNT_CTRL_CH1_IN5_IDX: u32 = 74;
pub const LEDC_HS_SIG_OUT3_IDX: u32 = 74;
pub const PCNT_SIG_CH0_IN6_IDX: u32 = 75;
pub const LEDC_HS_SIG_OUT4_IDX: u32 = 75;
pub const PCNT_SIG_CH1_IN6_IDX: u32 = 76;
pub const LEDC_HS_SIG_OUT5_IDX: u32 = 76;
pub const PCNT_CTRL_CH0_IN6_IDX: u32 = 77;
pub const LEDC_HS_SIG_OUT6_IDX: u32 = 77;
pub const PCNT_CTRL_CH1_IN6_IDX: u32 = 78;
pub const LEDC_HS_SIG_OUT7_IDX: u32 = 78;
pub const PCNT_SIG_CH0_IN7_IDX: u32 = 79;
pub const LEDC_LS_SIG_OUT0_IDX: u32 = 79;
pub const PCNT_SIG_CH1_IN7_IDX: u32 = 80;
pub const LEDC_LS_SIG_OUT1_IDX: u32 = 80;
pub const PCNT_CTRL_CH0_IN7_IDX: u32 = 81;
pub const LEDC_LS_SIG_OUT2_IDX: u32 = 81;
pub const PCNT_CTRL_CH1_IN7_IDX: u32 = 82;
pub const LEDC_LS_SIG_OUT3_IDX: u32 = 82;
pub const RMT_SIG_IN0_IDX: u32 = 83;
pub const LEDC_LS_SIG_OUT4_IDX: u32 = 83;
pub const RMT_SIG_IN1_IDX: u32 = 84;
pub const LEDC_LS_SIG_OUT5_IDX: u32 = 84;
pub const RMT_SIG_IN2_IDX: u32 = 85;
pub const LEDC_LS_SIG_OUT6_IDX: u32 = 85;
pub const RMT_SIG_IN3_IDX: u32 = 86;
pub const LEDC_LS_SIG_OUT7_IDX: u32 = 86;
pub const RMT_SIG_IN4_IDX: u32 = 87;
pub const RMT_SIG_OUT0_IDX: u32 = 87;
pub const RMT_SIG_IN5_IDX: u32 = 88;
pub const RMT_SIG_OUT1_IDX: u32 = 88;
pub const RMT_SIG_IN6_IDX: u32 = 89;
pub const RMT_SIG_OUT2_IDX: u32 = 89;
pub const RMT_SIG_IN7_IDX: u32 = 90;
pub const RMT_SIG_OUT3_IDX: u32 = 90;
pub const RMT_SIG_OUT4_IDX: u32 = 91;
pub const RMT_SIG_OUT5_IDX: u32 = 92;
pub const EXT_ADC_START_IDX: u32 = 93;
pub const RMT_SIG_OUT6_IDX: u32 = 93;
pub const TWAI_RX_IDX: u32 = 94;
pub const CAN_RX_IDX: u32 = 94;
pub const RMT_SIG_OUT7_IDX: u32 = 94;
pub const I2CEXT1_SCL_IN_IDX: u32 = 95;
pub const I2CEXT1_SCL_OUT_IDX: u32 = 95;
pub const I2CEXT1_SDA_IN_IDX: u32 = 96;
pub const I2CEXT1_SDA_OUT_IDX: u32 = 96;
pub const HOST_CARD_DETECT_N_1_IDX: u32 = 97;
pub const HOST_CCMD_OD_PULLUP_EN_N_IDX: u32 = 97;
pub const HOST_CARD_DETECT_N_2_IDX: u32 = 98;
pub const HOST_RST_N_1_IDX: u32 = 98;
pub const HOST_CARD_WRITE_PRT_1_IDX: u32 = 99;
pub const HOST_RST_N_2_IDX: u32 = 99;
pub const HOST_CARD_WRITE_PRT_2_IDX: u32 = 100;
pub const GPIO_SD0_OUT_IDX: u32 = 100;
pub const HOST_CARD_INT_N_1_IDX: u32 = 101;
pub const GPIO_SD1_OUT_IDX: u32 = 101;
pub const HOST_CARD_INT_N_2_IDX: u32 = 102;
pub const GPIO_SD2_OUT_IDX: u32 = 102;
pub const PWM1_SYNC0_IN_IDX: u32 = 103;
pub const GPIO_SD3_OUT_IDX: u32 = 103;
pub const PWM1_SYNC1_IN_IDX: u32 = 104;
pub const GPIO_SD4_OUT_IDX: u32 = 104;
pub const PWM1_SYNC2_IN_IDX: u32 = 105;
pub const GPIO_SD5_OUT_IDX: u32 = 105;
pub const PWM1_F0_IN_IDX: u32 = 106;
pub const GPIO_SD6_OUT_IDX: u32 = 106;
pub const PWM1_F1_IN_IDX: u32 = 107;
pub const GPIO_SD7_OUT_IDX: u32 = 107;
pub const PWM1_F2_IN_IDX: u32 = 108;
pub const PWM1_OUT0A_IDX: u32 = 108;
pub const PWM0_CAP0_IN_IDX: u32 = 109;
pub const PWM1_OUT0B_IDX: u32 = 109;
pub const PWM0_CAP1_IN_IDX: u32 = 110;
pub const PWM1_OUT1A_IDX: u32 = 110;
pub const PWM0_CAP2_IN_IDX: u32 = 111;
pub const PWM1_OUT1B_IDX: u32 = 111;
pub const PWM1_CAP0_IN_IDX: u32 = 112;
pub const PWM1_OUT2A_IDX: u32 = 112;
pub const PWM1_CAP1_IN_IDX: u32 = 113;
pub const PWM1_OUT2B_IDX: u32 = 113;
pub const PWM1_CAP2_IN_IDX: u32 = 114;
pub const PWM2_OUT1H_IDX: u32 = 114;
pub const PWM2_FLTA_IDX: u32 = 115;
pub const PWM2_OUT1L_IDX: u32 = 115;
pub const PWM2_FLTB_IDX: u32 = 116;
pub const PWM2_OUT2H_IDX: u32 = 116;
pub const PWM2_CAP1_IN_IDX: u32 = 117;
pub const PWM2_OUT2L_IDX: u32 = 117;
pub const PWM2_CAP2_IN_IDX: u32 = 118;
pub const PWM2_OUT3H_IDX: u32 = 118;
pub const PWM2_CAP3_IN_IDX: u32 = 119;
pub const PWM2_OUT3L_IDX: u32 = 119;
pub const PWM3_FLTA_IDX: u32 = 120;
pub const PWM2_OUT4H_IDX: u32 = 120;
pub const PWM3_FLTB_IDX: u32 = 121;
pub const PWM2_OUT4L_IDX: u32 = 121;
pub const PWM3_CAP1_IN_IDX: u32 = 122;
pub const PWM3_CAP2_IN_IDX: u32 = 123;
pub const TWAI_TX_IDX: u32 = 123;
pub const CAN_TX_IDX: u32 = 123;
pub const PWM3_CAP3_IN_IDX: u32 = 124;
pub const TWAI_BUS_OFF_ON_IDX: u32 = 124;
pub const CAN_BUS_OFF_ON_IDX: u32 = 124;
pub const TWAI_CLKOUT_IDX: u32 = 125;
pub const CAN_CLKOUT_IDX: u32 = 125;
pub const SPID4_IN_IDX: u32 = 128;
pub const SPID4_OUT_IDX: u32 = 128;
pub const SPID5_IN_IDX: u32 = 129;
pub const SPID5_OUT_IDX: u32 = 129;
pub const SPID6_IN_IDX: u32 = 130;
pub const SPID6_OUT_IDX: u32 = 130;
pub const SPID7_IN_IDX: u32 = 131;
pub const SPID7_OUT_IDX: u32 = 131;
pub const HSPID4_IN_IDX: u32 = 132;
pub const HSPID4_OUT_IDX: u32 = 132;
pub const HSPID5_IN_IDX: u32 = 133;
pub const HSPID5_OUT_IDX: u32 = 133;
pub const HSPID6_IN_IDX: u32 = 134;
pub const HSPID6_OUT_IDX: u32 = 134;
pub const HSPID7_IN_IDX: u32 = 135;
pub const HSPID7_OUT_IDX: u32 = 135;
pub const VSPID4_IN_IDX: u32 = 136;
pub const VSPID4_OUT_IDX: u32 = 136;
pub const VSPID5_IN_IDX: u32 = 137;
pub const VSPID5_OUT_IDX: u32 = 137;
pub const VSPID6_IN_IDX: u32 = 138;
pub const VSPID6_OUT_IDX: u32 = 138;
pub const VSPID7_IN_IDX: u32 = 139;
pub const VSPID7_OUT_IDX: u32 = 139;
pub const I2S0I_DATA_IN0_IDX: u32 = 140;
pub const I2S0O_DATA_OUT0_IDX: u32 = 140;
pub const I2S0I_DATA_IN1_IDX: u32 = 141;
pub const I2S0O_DATA_OUT1_IDX: u32 = 141;
pub const I2S0I_DATA_IN2_IDX: u32 = 142;
pub const I2S0O_DATA_OUT2_IDX: u32 = 142;
pub const I2S0I_DATA_IN3_IDX: u32 = 143;
pub const I2S0O_DATA_OUT3_IDX: u32 = 143;
pub const I2S0I_DATA_IN4_IDX: u32 = 144;
pub const I2S0O_DATA_OUT4_IDX: u32 = 144;
pub const I2S0I_DATA_IN5_IDX: u32 = 145;
pub const I2S0O_DATA_OUT5_IDX: u32 = 145;
pub const I2S0I_DATA_IN6_IDX: u32 = 146;
pub const I2S0O_DATA_OUT6_IDX: u32 = 146;
pub const I2S0I_DATA_IN7_IDX: u32 = 147;
pub const I2S0O_DATA_OUT7_IDX: u32 = 147;
pub const I2S0I_DATA_IN8_IDX: u32 = 148;
pub const I2S0O_DATA_OUT8_IDX: u32 = 148;
pub const I2S0I_DATA_IN9_IDX: u32 = 149;
pub const I2S0O_DATA_OUT9_IDX: u32 = 149;
pub const I2S0I_DATA_IN10_IDX: u32 = 150;
pub const I2S0O_DATA_OUT10_IDX: u32 = 150;
pub const I2S0I_DATA_IN11_IDX: u32 = 151;
pub const I2S0O_DATA_OUT11_IDX: u32 = 151;
pub const I2S0I_DATA_IN12_IDX: u32 = 152;
pub const I2S0O_DATA_OUT12_IDX: u32 = 152;
pub const I2S0I_DATA_IN13_IDX: u32 = 153;
pub const I2S0O_DATA_OUT13_IDX: u32 = 153;
pub const I2S0I_DATA_IN14_IDX: u32 = 154;
pub const I2S0O_DATA_OUT14_IDX: u32 = 154;
pub const I2S0I_DATA_IN15_IDX: u32 = 155;
pub const I2S0O_DATA_OUT15_IDX: u32 = 155;
pub const I2S0O_DATA_OUT16_IDX: u32 = 156;
pub const I2S0O_DATA_OUT17_IDX: u32 = 157;
pub const I2S0O_DATA_OUT18_IDX: u32 = 158;
pub const I2S0O_DATA_OUT19_IDX: u32 = 159;
pub const I2S0O_DATA_OUT20_IDX: u32 = 160;
pub const I2S0O_DATA_OUT21_IDX: u32 = 161;
pub const I2S0O_DATA_OUT22_IDX: u32 = 162;
pub const I2S0O_DATA_OUT23_IDX: u32 = 163;
pub const I2S1I_BCK_IN_IDX: u32 = 164;
pub const I2S1I_BCK_OUT_IDX: u32 = 164;
pub const I2S1I_WS_IN_IDX: u32 = 165;
pub const I2S1I_WS_OUT_IDX: u32 = 165;
pub const I2S1I_DATA_IN0_IDX: u32 = 166;
pub const I2S1O_DATA_OUT0_IDX: u32 = 166;
pub const I2S1I_DATA_IN1_IDX: u32 = 167;
pub const I2S1O_DATA_OUT1_IDX: u32 = 167;
pub const I2S1I_DATA_IN2_IDX: u32 = 168;
pub const I2S1O_DATA_OUT2_IDX: u32 = 168;
pub const I2S1I_DATA_IN3_IDX: u32 = 169;
pub const I2S1O_DATA_OUT3_IDX: u32 = 169;
pub const I2S1I_DATA_IN4_IDX: u32 = 170;
pub const I2S1O_DATA_OUT4_IDX: u32 = 170;
pub const I2S1I_DATA_IN5_IDX: u32 = 171;
pub const I2S1O_DATA_OUT5_IDX: u32 = 171;
pub const I2S1I_DATA_IN6_IDX: u32 = 172;
pub const I2S1O_DATA_OUT6_IDX: u32 = 172;
pub const I2S1I_DATA_IN7_IDX: u32 = 173;
pub const I2S1O_DATA_OUT7_IDX: u32 = 173;
pub const I2S1I_DATA_IN8_IDX: u32 = 174;
pub const I2S1O_DATA_OUT8_IDX: u32 = 174;
pub const I2S1I_DATA_IN9_IDX: u32 = 175;
pub const I2S1O_DATA_OUT9_IDX: u32 = 175;
pub const I2S1I_DATA_IN10_IDX: u32 = 176;
pub const I2S1O_DATA_OUT10_IDX: u32 = 176;
pub const I2S1I_DATA_IN11_IDX: u32 = 177;
pub const I2S1O_DATA_OUT11_IDX: u32 = 177;
pub const I2S1I_DATA_IN12_IDX: u32 = 178;
pub const I2S1O_DATA_OUT12_IDX: u32 = 178;
pub const I2S1I_DATA_IN13_IDX: u32 = 179;
pub const I2S1O_DATA_OUT13_IDX: u32 = 179;
pub const I2S1I_DATA_IN14_IDX: u32 = 180;
pub const I2S1O_DATA_OUT14_IDX: u32 = 180;
pub const I2S1I_DATA_IN15_IDX: u32 = 181;
pub const I2S1O_DATA_OUT15_IDX: u32 = 181;
pub const I2S1O_DATA_OUT16_IDX: u32 = 182;
pub const I2S1O_DATA_OUT17_IDX: u32 = 183;
pub const I2S1O_DATA_OUT18_IDX: u32 = 184;
pub const I2S1O_DATA_OUT19_IDX: u32 = 185;
pub const I2S1O_DATA_OUT20_IDX: u32 = 186;
pub const I2S1O_DATA_OUT21_IDX: u32 = 187;
pub const I2S1O_DATA_OUT22_IDX: u32 = 188;
pub const I2S1O_DATA_OUT23_IDX: u32 = 189;
pub const I2S0I_H_SYNC_IDX: u32 = 190;
pub const PWM3_OUT1H_IDX: u32 = 190;
pub const I2S0I_V_SYNC_IDX: u32 = 191;
pub const PWM3_OUT1L_IDX: u32 = 191;
pub const I2S0I_H_ENABLE_IDX: u32 = 192;
pub const PWM3_OUT2H_IDX: u32 = 192;
pub const I2S1I_H_SYNC_IDX: u32 = 193;
pub const PWM3_OUT2L_IDX: u32 = 193;
pub const I2S1I_V_SYNC_IDX: u32 = 194;
pub const PWM3_OUT3H_IDX: u32 = 194;
pub const I2S1I_H_ENABLE_IDX: u32 = 195;
pub const PWM3_OUT3L_IDX: u32 = 195;
pub const PWM3_OUT4H_IDX: u32 = 196;
pub const PWM3_OUT4L_IDX: u32 = 197;
pub const U2RXD_IN_IDX: u32 = 198;
pub const U2TXD_OUT_IDX: u32 = 198;
pub const U2CTS_IN_IDX: u32 = 199;
pub const U2RTS_OUT_IDX: u32 = 199;
pub const EMAC_MDC_I_IDX: u32 = 200;
pub const EMAC_MDC_O_IDX: u32 = 200;
pub const EMAC_MDI_I_IDX: u32 = 201;
pub const EMAC_MDO_O_IDX: u32 = 201;
pub const EMAC_CRS_I_IDX: u32 = 202;
pub const EMAC_CRS_O_IDX: u32 = 202;
pub const EMAC_COL_I_IDX: u32 = 203;
pub const EMAC_COL_O_IDX: u32 = 203;
pub const PCMFSYNC_IN_IDX: u32 = 204;
pub const BT_AUDIO0_IRQ_IDX: u32 = 204;
pub const PCMCLK_IN_IDX: u32 = 205;
pub const BT_AUDIO1_IRQ_IDX: u32 = 205;
pub const PCMDIN_IDX: u32 = 206;
pub const BT_AUDIO2_IRQ_IDX: u32 = 206;
pub const BLE_AUDIO0_IRQ_IDX: u32 = 207;
pub const BLE_AUDIO1_IRQ_IDX: u32 = 208;
pub const BLE_AUDIO2_IRQ_IDX: u32 = 209;
pub const PCMFSYNC_OUT_IDX: u32 = 210;
pub const PCMCLK_OUT_IDX: u32 = 211;
pub const PCMDOUT_IDX: u32 = 212;
pub const BLE_AUDIO_SYNC0_P_IDX: u32 = 213;
pub const BLE_AUDIO_SYNC1_P_IDX: u32 = 214;
pub const BLE_AUDIO_SYNC2_P_IDX: u32 = 215;
pub const ANT_SEL0_IDX: u32 = 216;
pub const ANT_SEL1_IDX: u32 = 217;
pub const ANT_SEL2_IDX: u32 = 218;
pub const ANT_SEL3_IDX: u32 = 219;
pub const ANT_SEL4_IDX: u32 = 220;
pub const ANT_SEL5_IDX: u32 = 221;
pub const ANT_SEL6_IDX: u32 = 222;
pub const ANT_SEL7_IDX: u32 = 223;
pub const SIG_IN_FUNC224_IDX: u32 = 224;
pub const SIG_IN_FUNC225_IDX: u32 = 225;
pub const SIG_IN_FUNC226_IDX: u32 = 226;
pub const SIG_IN_FUNC227_IDX: u32 = 227;
pub const SIG_IN_FUNC228_IDX: u32 = 228;
pub const SIG_GPIO_OUT_IDX: u32 = 256;
pub const GPIO_PIN_REG_0: u32 = 1072992324;
pub const GPIO_PIN_REG_1: u32 = 1072992392;
pub const GPIO_PIN_REG_2: u32 = 1072992320;
pub const GPIO_PIN_REG_3: u32 = 1072992388;
pub const GPIO_PIN_REG_4: u32 = 1072992328;
pub const GPIO_PIN_REG_5: u32 = 1072992364;
pub const GPIO_PIN_REG_6: u32 = 1072992352;
pub const GPIO_PIN_REG_7: u32 = 1072992356;
pub const GPIO_PIN_REG_8: u32 = 1072992360;
pub const GPIO_PIN_REG_9: u32 = 1072992340;
pub const GPIO_PIN_REG_10: u32 = 1072992344;
pub const GPIO_PIN_REG_11: u32 = 1072992348;
pub const GPIO_PIN_REG_12: u32 = 1072992308;
pub const GPIO_PIN_REG_13: u32 = 1072992312;
pub const GPIO_PIN_REG_14: u32 = 1072992304;
pub const GPIO_PIN_REG_15: u32 = 1072992316;
pub const GPIO_PIN_REG_16: u32 = 1072992332;
pub const GPIO_PIN_REG_17: u32 = 1072992336;
pub const GPIO_PIN_REG_18: u32 = 1072992368;
pub const GPIO_PIN_REG_19: u32 = 1072992372;
pub const GPIO_PIN_REG_20: u32 = 1072992376;
pub const GPIO_PIN_REG_21: u32 = 1072992380;
pub const GPIO_PIN_REG_22: u32 = 1072992384;
pub const GPIO_PIN_REG_23: u32 = 1072992396;
pub const GPIO_PIN_REG_24: u32 = 1072992400;
pub const GPIO_PIN_REG_25: u32 = 1072992292;
pub const GPIO_PIN_REG_26: u32 = 1072992296;
pub const GPIO_PIN_REG_27: u32 = 1072992300;
pub const GPIO_PIN_REG_32: u32 = 1072992284;
pub const GPIO_PIN_REG_33: u32 = 1072992288;
pub const GPIO_PIN_REG_34: u32 = 1072992276;
pub const GPIO_PIN_REG_35: u32 = 1072992280;
pub const GPIO_PIN_REG_36: u32 = 1072992260;
pub const GPIO_PIN_REG_37: u32 = 1072992264;
pub const GPIO_PIN_REG_38: u32 = 1072992268;
pub const GPIO_PIN_REG_39: u32 = 1072992272;
pub const GPIO_MODE_DEF_DISABLE: u32 = 0;
pub const GPIO_MODE_DEF_INPUT: u32 = 1;
pub const GPIO_MODE_DEF_OUTPUT: u32 = 2;
pub const GPIO_MODE_DEF_OD: u32 = 4;
pub const GPIO_ID_PIN0: u32 = 0;
pub const GPIO_FUNC_IN_HIGH: u32 = 56;
pub const GPIO_FUNC_IN_LOW: u32 = 48;
pub const GPIO_PIN_COUNT: u32 = 40;
pub const LEDC_APB_CLK_HZ: u32 = 80000000;
pub const LEDC_REF_CLK_HZ: u32 = 1000000;
pub const LEDC_ERR_DUTY: u32 = 4294967295;
pub const LEDC_ERR_VAL: i32 = -1;
pub const DST_NONE: u32 = 0;
pub const DST_USA: u32 = 1;
pub const DST_AUST: u32 = 2;
pub const DST_WET: u32 = 3;
pub const DST_MET: u32 = 4;
pub const DST_EET: u32 = 5;
pub const DST_CAN: u32 = 6;
pub const SBT_MAX: u64 = 9223372036854775807;
pub const ITIMER_REAL: u32 = 0;
pub const ITIMER_VIRTUAL: u32 = 1;
pub const ITIMER_PROF: u32 = 2;
pub const _CLOCKS_PER_SEC_: u32 = 1000000;
pub const CLOCKS_PER_SEC: u32 = 1000000;
pub const CLK_TCK: u32 = 1000000;
pub const CLOCK_ENABLED: u32 = 1;
pub const CLOCK_DISABLED: u32 = 0;
pub const CLOCK_ALLOWED: u32 = 1;
pub const CLOCK_DISALLOWED: u32 = 0;
pub const TIMER_ABSTIME: u32 = 4;
pub const _POSIX_TIMERS: u32 = 1;
pub const ESP_ERR_CAMERA_BASE: u32 = 131072;
pub const ESP_ERR_CAMERA_NOT_DETECTED: u32 = 131073;
pub const ESP_ERR_CAMERA_FAILED_TO_SET_FRAME_SIZE: u32 = 131074;
pub const ESP_ERR_CAMERA_FAILED_TO_SET_OUT_FORMAT: u32 = 131075;
pub const ESP_ERR_CAMERA_NOT_SUPPORTED: u32 = 131076;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = ::std::os::raw::c_schar;
pub type __uint_least8_t = ::std::os::raw::c_uchar;
pub type __int_least16_t = ::std::os::raw::c_short;
pub type __uint_least16_t = ::std::os::raw::c_ushort;
pub type __int_least32_t = ::std::os::raw::c_int;
pub type __uint_least32_t = ::std::os::raw::c_uint;
pub type __int_least64_t = ::std::os::raw::c_long;
pub type __uint_least64_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __uintptr_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type int_fast16_t = ::std::os::raw::c_short;
pub type uint_fast16_t = ::std::os::raw::c_ushort;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type wint_t = ::std::os::raw::c_uint;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint32_t;
pub type _off_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
pub type __dev_t = ::std::os::raw::c_short;
pub type __uid_t = ::std::os::raw::c_ushort;
pub type __gid_t = ::std::os::raw::c_ushort;
pub type __id_t = __uint32_t;
pub type __ino_t = ::std::os::raw::c_ushort;
pub type __mode_t = __uint32_t;
pub type _off64_t = ::std::os::raw::c_longlong;
pub type __off_t = _off_t;
pub type __loff_t = _off64_t;
pub type __key_t = ::std::os::raw::c_long;
pub type _fpos_t = ::std::os::raw::c_long;
pub type __size_t = ::std::os::raw::c_ulong;
pub type _ssize_t = ::std::os::raw::c_long;
pub type __ssize_t = _ssize_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _mbstate_t__bindgen_ty_1 {
    pub __wch: wint_t,
    pub __wchb: [::std::os::raw::c_uchar; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout__mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout__mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<_mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(_mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
pub type _iconv_t = *mut ::std::os::raw::c_void;
pub type __clock_t = ::std::os::raw::c_ulong;
pub type __time_t = ::std::os::raw::c_long;
pub type __clockid_t = ::std::os::raw::c_ulong;
pub type __timer_t = ::std::os::raw::c_ulong;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __nl_item = ::std::os::raw::c_int;
pub type __nlink_t = ::std::os::raw::c_ushort;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_ulong;
pub type __va_list = __builtin_va_list;
pub type __ULong = ::std::os::raw::c_uint;
pub type _LOCK_T = *mut __lock;
extern "C" {
    pub fn __retarget_lock_init(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_init_recursive(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_close(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_close_recursive(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_acquire(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_acquire_recursive(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_try_acquire(lock: _LOCK_T) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __retarget_lock_try_acquire_recursive(lock: _LOCK_T) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __retarget_lock_release(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_release_recursive(lock: _LOCK_T);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __lock {
    pub reserved: [::std::os::raw::c_int; 23usize],
}
#[test]
fn bindgen_test_layout___lock() {
    assert_eq!(
        ::std::mem::size_of::<__lock>(),
        92usize,
        concat!("Size of: ", stringify!(__lock))
    );
    assert_eq!(
        ::std::mem::align_of::<__lock>(),
        4usize,
        concat!("Alignment of ", stringify!(__lock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__lock>())).reserved as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__lock),
            "::",
            stringify!(reserved)
        )
    );
}
pub type _lock_t = _LOCK_T;
extern "C" {
    pub fn _lock_init(plock: *mut _lock_t);
}
extern "C" {
    pub fn _lock_init_recursive(plock: *mut _lock_t);
}
extern "C" {
    pub fn _lock_close(plock: *mut _lock_t);
}
extern "C" {
    pub fn _lock_close_recursive(plock: *mut _lock_t);
}
extern "C" {
    pub fn _lock_acquire(plock: *mut _lock_t);
}
extern "C" {
    pub fn _lock_acquire_recursive(plock: *mut _lock_t);
}
extern "C" {
    pub fn _lock_try_acquire(plock: *mut _lock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _lock_try_acquire_recursive(plock: *mut _lock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _lock_release(plock: *mut _lock_t);
}
extern "C" {
    pub fn _lock_release_recursive(plock: *mut _lock_t);
}
pub type _flock_t = _LOCK_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Bigint {
    pub _next: *mut _Bigint,
    pub _k: ::std::os::raw::c_int,
    pub _maxwds: ::std::os::raw::c_int,
    pub _sign: ::std::os::raw::c_int,
    pub _wds: ::std::os::raw::c_int,
    pub _x: [__ULong; 1usize],
}
#[test]
fn bindgen_test_layout__Bigint() {
    assert_eq!(
        ::std::mem::size_of::<_Bigint>(),
        32usize,
        concat!("Size of: ", stringify!(_Bigint))
    );
    assert_eq!(
        ::std::mem::align_of::<_Bigint>(),
        8usize,
        concat!("Alignment of ", stringify!(_Bigint))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Bigint>()))._next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Bigint>()))._k as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_k)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Bigint>()))._maxwds as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_maxwds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Bigint>()))._sign as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_sign)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Bigint>()))._wds as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_wds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Bigint>()))._x as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __tm {
    pub __tm_sec: ::std::os::raw::c_int,
    pub __tm_min: ::std::os::raw::c_int,
    pub __tm_hour: ::std::os::raw::c_int,
    pub __tm_mday: ::std::os::raw::c_int,
    pub __tm_mon: ::std::os::raw::c_int,
    pub __tm_year: ::std::os::raw::c_int,
    pub __tm_wday: ::std::os::raw::c_int,
    pub __tm_yday: ::std::os::raw::c_int,
    pub __tm_isdst: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___tm() {
    assert_eq!(
        ::std::mem::size_of::<__tm>(),
        36usize,
        concat!("Size of: ", stringify!(__tm))
    );
    assert_eq!(
        ::std::mem::align_of::<__tm>(),
        4usize,
        concat!("Alignment of ", stringify!(__tm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__tm>())).__tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__tm>())).__tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__tm>())).__tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__tm>())).__tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__tm>())).__tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__tm>())).__tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__tm>())).__tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__tm>())).__tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__tm>())).__tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_isdst)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _on_exit_args {
    pub _fnargs: [*mut ::std::os::raw::c_void; 32usize],
    pub _dso_handle: [*mut ::std::os::raw::c_void; 32usize],
    pub _fntypes: __ULong,
    pub _is_cxa: __ULong,
}
#[test]
fn bindgen_test_layout__on_exit_args() {
    assert_eq!(
        ::std::mem::size_of::<_on_exit_args>(),
        520usize,
        concat!("Size of: ", stringify!(_on_exit_args))
    );
    assert_eq!(
        ::std::mem::align_of::<_on_exit_args>(),
        8usize,
        concat!("Alignment of ", stringify!(_on_exit_args))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_on_exit_args>()))._fnargs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_fnargs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_on_exit_args>()))._dso_handle as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_dso_handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_on_exit_args>()))._fntypes as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_fntypes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_on_exit_args>()))._is_cxa as *const _ as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_is_cxa)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _atexit {
    pub _next: *mut _atexit,
    pub _ind: ::std::os::raw::c_int,
    pub _fns: [::std::option::Option<unsafe extern "C" fn()>; 32usize],
    pub _on_exit_args_ptr: *mut _on_exit_args,
}
#[test]
fn bindgen_test_layout__atexit() {
    assert_eq!(
        ::std::mem::size_of::<_atexit>(),
        280usize,
        concat!("Size of: ", stringify!(_atexit))
    );
    assert_eq!(
        ::std::mem::align_of::<_atexit>(),
        8usize,
        concat!("Alignment of ", stringify!(_atexit))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_atexit>()))._next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_atexit>()))._ind as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_ind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_atexit>()))._fns as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_fns)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_atexit>()))._on_exit_args_ptr as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_on_exit_args_ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::std::os::raw::c_uchar,
    pub _size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    assert_eq!(
        ::std::mem::size_of::<__sbuf>(),
        16usize,
        concat!("Size of: ", stringify!(__sbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<__sbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(__sbuf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sbuf>()))._base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sbuf>()))._size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILE_fake {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _data: *mut _reent,
}
#[test]
fn bindgen_test_layout___sFILE_fake() {
    assert_eq!(
        ::std::mem::size_of::<__sFILE_fake>(),
        56usize,
        concat!("Size of: ", stringify!(__sFILE_fake))
    );
    assert_eq!(
        ::std::mem::align_of::<__sFILE_fake>(),
        8usize,
        concat!("Alignment of ", stringify!(__sFILE_fake))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE_fake>()))._p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE_fake),
            "::",
            stringify!(_p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE_fake>()))._r as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE_fake),
            "::",
            stringify!(_r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE_fake>()))._w as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE_fake),
            "::",
            stringify!(_w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE_fake>()))._flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE_fake),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE_fake>()))._file as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE_fake),
            "::",
            stringify!(_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE_fake>()))._bf as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE_fake),
            "::",
            stringify!(_bf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE_fake>()))._lbfsize as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE_fake),
            "::",
            stringify!(_lbfsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE_fake>()))._data as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE_fake),
            "::",
            stringify!(_data)
        )
    );
}
extern "C" {
    pub fn __sinit(arg1: *mut _reent);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _data: *mut _reent,
    pub _cookie: *mut ::std::os::raw::c_void,
    pub _read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::std::os::raw::c_void,
            arg3: *mut ::std::os::raw::c_char,
            arg4: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _write: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::std::os::raw::c_void,
            arg3: *const ::std::os::raw::c_char,
            arg4: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::std::os::raw::c_void,
            arg3: _fpos_t,
            arg4: ::std::os::raw::c_int,
        ) -> _fpos_t,
    >,
    pub _close: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub _ub: __sbuf,
    pub _up: *mut ::std::os::raw::c_uchar,
    pub _ur: ::std::os::raw::c_int,
    pub _ubuf: [::std::os::raw::c_uchar; 3usize],
    pub _nbuf: [::std::os::raw::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::std::os::raw::c_int,
    pub _offset: _off_t,
    pub _lock: _flock_t,
    pub _mbstate: _mbstate_t,
    pub _flags2: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sFILE() {
    assert_eq!(
        ::std::mem::size_of::<__sFILE>(),
        184usize,
        concat!("Size of: ", stringify!(__sFILE))
    );
    assert_eq!(
        ::std::mem::align_of::<__sFILE>(),
        8usize,
        concat!("Alignment of ", stringify!(__sFILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._r as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._w as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._file as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._bf as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_bf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._lbfsize as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lbfsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._data as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._cookie as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_cookie)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._read as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._write as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._seek as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_seek)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._close as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_close)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._ub as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ub)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._up as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_up)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._ur as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ur)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._ubuf as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ubuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._nbuf as *const _ as usize },
        127usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_nbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._lb as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._blksize as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_blksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._offset as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._lock as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._mbstate as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_mbstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._flags2 as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags2)
        )
    );
}
pub type __FILE = __sFILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _glue {
    pub _next: *mut _glue,
    pub _niobs: ::std::os::raw::c_int,
    pub _iobs: *mut __FILE,
}
#[test]
fn bindgen_test_layout__glue() {
    assert_eq!(
        ::std::mem::size_of::<_glue>(),
        24usize,
        concat!("Size of: ", stringify!(_glue))
    );
    assert_eq!(
        ::std::mem::align_of::<_glue>(),
        8usize,
        concat!("Alignment of ", stringify!(_glue))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glue>()))._next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_glue),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glue>()))._niobs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_glue),
            "::",
            stringify!(_niobs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_glue>()))._iobs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_glue),
            "::",
            stringify!(_iobs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _rand48 {
    pub _seed: [::std::os::raw::c_ushort; 3usize],
    pub _mult: [::std::os::raw::c_ushort; 3usize],
    pub _add: ::std::os::raw::c_ushort,
    pub _rand_next: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout__rand48() {
    assert_eq!(
        ::std::mem::size_of::<_rand48>(),
        24usize,
        concat!("Size of: ", stringify!(_rand48))
    );
    assert_eq!(
        ::std::mem::align_of::<_rand48>(),
        8usize,
        concat!("Alignment of ", stringify!(_rand48))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_rand48>()))._seed as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_rand48),
            "::",
            stringify!(_seed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_rand48>()))._mult as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_rand48),
            "::",
            stringify!(_mult)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_rand48>()))._add as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_rand48),
            "::",
            stringify!(_add)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_rand48>()))._rand_next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_rand48),
            "::",
            stringify!(_rand_next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _mprec {
    pub _result: *mut _Bigint,
    pub _result_k: ::std::os::raw::c_int,
    pub _p5s: *mut _Bigint,
    pub _freelist: *mut *mut _Bigint,
}
#[test]
fn bindgen_test_layout__mprec() {
    assert_eq!(
        ::std::mem::size_of::<_mprec>(),
        32usize,
        concat!("Size of: ", stringify!(_mprec))
    );
    assert_eq!(
        ::std::mem::align_of::<_mprec>(),
        8usize,
        concat!("Alignment of ", stringify!(_mprec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_mprec>()))._result as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mprec),
            "::",
            stringify!(_result)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_mprec>()))._result_k as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_mprec),
            "::",
            stringify!(_result_k)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_mprec>()))._p5s as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_mprec),
            "::",
            stringify!(_p5s)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_mprec>()))._freelist as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_mprec),
            "::",
            stringify!(_freelist)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _misc_reent {
    pub _strtok_last: *mut ::std::os::raw::c_char,
    pub _mblen_state: _mbstate_t,
    pub _wctomb_state: _mbstate_t,
    pub _mbtowc_state: _mbstate_t,
    pub _l64a_buf: [::std::os::raw::c_char; 8usize],
    pub _getdate_err: ::std::os::raw::c_int,
    pub _mbrlen_state: _mbstate_t,
    pub _mbrtowc_state: _mbstate_t,
    pub _mbsrtowcs_state: _mbstate_t,
    pub _wcrtomb_state: _mbstate_t,
    pub _wcsrtombs_state: _mbstate_t,
}
#[test]
fn bindgen_test_layout__misc_reent() {
    assert_eq!(
        ::std::mem::size_of::<_misc_reent>(),
        88usize,
        concat!("Size of: ", stringify!(_misc_reent))
    );
    assert_eq!(
        ::std::mem::align_of::<_misc_reent>(),
        8usize,
        concat!("Alignment of ", stringify!(_misc_reent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_misc_reent>()))._strtok_last as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_misc_reent),
            "::",
            stringify!(_strtok_last)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_misc_reent>()))._mblen_state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_misc_reent),
            "::",
            stringify!(_mblen_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_misc_reent>()))._wctomb_state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_misc_reent),
            "::",
            stringify!(_wctomb_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_misc_reent>()))._mbtowc_state as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_misc_reent),
            "::",
            stringify!(_mbtowc_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_misc_reent>()))._l64a_buf as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_misc_reent),
            "::",
            stringify!(_l64a_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_misc_reent>()))._getdate_err as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_misc_reent),
            "::",
            stringify!(_getdate_err)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_misc_reent>()))._mbrlen_state as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_misc_reent),
            "::",
            stringify!(_mbrlen_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_misc_reent>()))._mbrtowc_state as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_misc_reent),
            "::",
            stringify!(_mbrtowc_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_misc_reent>()))._mbsrtowcs_state as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_misc_reent),
            "::",
            stringify!(_mbsrtowcs_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_misc_reent>()))._wcrtomb_state as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_misc_reent),
            "::",
            stringify!(_wcrtomb_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_misc_reent>()))._wcsrtombs_state as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_misc_reent),
            "::",
            stringify!(_wcsrtombs_state)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _reent {
    pub _errno: ::std::os::raw::c_int,
    pub _stdin: *mut __FILE,
    pub _stdout: *mut __FILE,
    pub _stderr: *mut __FILE,
    pub _inc: ::std::os::raw::c_int,
    pub _emergency: *mut ::std::os::raw::c_char,
    pub __sdidinit: ::std::os::raw::c_int,
    pub _unspecified_locale_info: ::std::os::raw::c_int,
    pub _locale: *mut __locale_t,
    pub _mp: *mut _mprec,
    pub __cleanup: ::std::option::Option<unsafe extern "C" fn(arg1: *mut _reent)>,
    pub _gamma_signgam: ::std::os::raw::c_int,
    pub _cvtlen: ::std::os::raw::c_int,
    pub _cvtbuf: *mut ::std::os::raw::c_char,
    pub _r48: *mut _rand48,
    pub _localtime_buf: *mut __tm,
    pub _asctime_buf: *mut ::std::os::raw::c_char,
    pub _sig_func: *mut ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub _atexit: *mut _atexit,
    pub _atexit0: _atexit,
    pub __sglue: _glue,
    pub __sf: *mut __FILE,
    pub _misc: *mut _misc_reent,
    pub _signal_buf: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__reent() {
    assert_eq!(
        ::std::mem::size_of::<_reent>(),
        464usize,
        concat!("Size of: ", stringify!(_reent))
    );
    assert_eq!(
        ::std::mem::align_of::<_reent>(),
        8usize,
        concat!("Alignment of ", stringify!(_reent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_reent>()))._errno as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_errno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_reent>()))._stdin as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_stdin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_reent>()))._stdout as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_stdout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_reent>()))._stderr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_stderr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_reent>()))._inc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_inc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_reent>()))._emergency as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_emergency)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_reent>())).__sdidinit as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__sdidinit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_reent>()))._unspecified_locale_info as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_unspecified_locale_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_reent>()))._locale as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_locale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_reent>()))._mp as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_mp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_reent>())).__cleanup as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__cleanup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_reent>()))._gamma_signgam as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_gamma_signgam)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_reent>()))._cvtlen as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_cvtlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_reent>()))._cvtbuf as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_cvtbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_reent>()))._r48 as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_r48)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_reent>()))._localtime_buf as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_localtime_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_reent>()))._asctime_buf as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_asctime_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_reent>()))._sig_func as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_sig_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_reent>()))._atexit as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_atexit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_reent>()))._atexit0 as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_atexit0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_reent>())).__sglue as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__sglue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_reent>())).__sf as *const _ as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__sf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_reent>()))._misc as *const _ as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_misc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_reent>()))._signal_buf as *const _ as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_signal_buf)
        )
    );
}
extern "C" {
    pub static __sf_fake_stdin: __sFILE_fake;
}
extern "C" {
    pub static __sf_fake_stdout: __sFILE_fake;
}
extern "C" {
    pub static __sf_fake_stderr: __sFILE_fake;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn __locale_mb_cur_max() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn abs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arc4random() -> __uint32_t;
}
extern "C" {
    pub fn arc4random_uniform(arg1: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn arc4random_buf(arg1: *mut ::std::os::raw::c_void, arg2: usize);
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoff(__nptr: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoi_r(
        arg1: *mut _reent,
        __nptr: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _atol_r(
        arg1: *mut _reent,
        __nptr: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        _compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        arg1: ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn free(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn getenv(__string: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _getenv_r(
        arg1: *mut _reent,
        __string: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _findenv(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _findenv_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut suboptarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn malloc(arg1: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mblen(arg1: *const ::std::os::raw::c_char, arg2: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mblen_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
        arg4: *mut _mbstate_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        arg1: *mut wchar_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mbtowc_r(
        arg1: *mut _reent,
        arg2: *mut wchar_t,
        arg3: *const ::std::os::raw::c_char,
        arg4: usize,
        arg5: *mut _mbstate_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(arg1: *mut ::std::os::raw::c_char, arg2: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wctomb_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: wchar_t,
        arg4: *mut _mbstate_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const ::std::os::raw::c_char, arg3: usize) -> usize;
}
extern "C" {
    pub fn _mbstowcs_r(
        arg1: *mut _reent,
        arg2: *mut wchar_t,
        arg3: *const ::std::os::raw::c_char,
        arg4: usize,
        arg5: *mut _mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn wcstombs(arg1: *mut ::std::os::raw::c_char, arg2: *const wchar_t, arg3: usize) -> usize;
}
extern "C" {
    pub fn _wcstombs_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *const wchar_t,
        arg4: usize,
        arg5: *mut _mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn mkdtemp(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _mkdtemp_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _mkostemp_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mkostemps_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mkstemp_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mkstemps_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mktemp_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        _compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realloc(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn reallocarray(
        arg1: *mut ::std::os::raw::c_void,
        arg2: usize,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn reallocf(arg1: *mut ::std::os::raw::c_void, arg2: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realpath(
        path: *const ::std::os::raw::c_char,
        resolved_path: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmatch(response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn strtod(
        __n: *const ::std::os::raw::c_char,
        __end_PTR: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn _strtod_r(
        arg1: *mut _reent,
        __n: *const ::std::os::raw::c_char,
        __end_PTR: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __n: *const ::std::os::raw::c_char,
        __end_PTR: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtol(
        __n: *const ::std::os::raw::c_char,
        __end_PTR: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _strtol_r(
        arg1: *mut _reent,
        __n: *const ::std::os::raw::c_char,
        __end_PTR: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __n: *const ::std::os::raw::c_char,
        __end_PTR: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _strtoul_r(
        arg1: *mut _reent,
        __n: *const ::std::os::raw::c_char,
        __end_PTR: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn system(__string: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn a64l(__input: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn l64a(__input: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _l64a_r(
        arg1: *mut _reent,
        __input: ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(arg1: ::std::os::raw::c_int, arg2: *mut ::std::os::raw::c_void),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putenv_r(
        arg1: *mut _reent,
        __string: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _reallocf_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn setenv(
        __string: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __overwrite: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _setenv_r(
        arg1: *mut _reent,
        __string: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __overwrite: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __itoa(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __utoa(
        arg1: ::std::os::raw::c_uint,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn itoa(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn utoa(
        arg1: ::std::os::raw::c_uint,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn _drand48_r(arg1: *mut _reent) -> f64;
}
extern "C" {
    pub fn erand48(arg1: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn _erand48_r(arg1: *mut _reent, arg2: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn jrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _jrand48_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lcong48(arg1: *mut ::std::os::raw::c_ushort);
}
extern "C" {
    pub fn _lcong48_r(arg1: *mut _reent, arg2: *mut ::std::os::raw::c_ushort);
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _lrand48_r(arg1: *mut _reent) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _mrand48_r(arg1: *mut _reent) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _nrand48_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn seed48(arg1: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn _seed48_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_ushort,
    ) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn srand48(arg1: ::std::os::raw::c_long);
}
extern "C" {
    pub fn _srand48_r(arg1: *mut _reent, arg2: ::std::os::raw::c_long);
}
extern "C" {
    pub fn initstate(
        arg1: ::std::os::raw::c_uint,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn setstate(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn srandom(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoll_r(
        arg1: *mut _reent,
        __nptr: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llabs(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn strtoll(
        __n: *const ::std::os::raw::c_char,
        __end_PTR: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoll_r(
        arg1: *mut _reent,
        __n: *const ::std::os::raw::c_char,
        __end_PTR: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __n: *const ::std::os::raw::c_char,
        __end_PTR: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoull_r(
        arg1: *mut _reent,
        __n: *const ::std::os::raw::c_char,
        __end_PTR: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn cfree(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn unsetenv(__string: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _unsetenv_r(
        arg1: *mut _reent,
        __string: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_memalign(
        arg1: *mut *mut ::std::os::raw::c_void,
        arg2: usize,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _dtoa_r(
        arg1: *mut _reent,
        arg2: f64,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: *mut ::std::os::raw::c_int,
        arg6: *mut ::std::os::raw::c_int,
        arg7: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _malloc_r(arg1: *mut _reent, arg2: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _calloc_r(arg1: *mut _reent, arg2: usize, arg3: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _free_r(arg1: *mut _reent, arg2: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _realloc_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _mstats_r(arg1: *mut _reent, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn _system_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __eprintf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
        arg4: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}__bsd_qsort_r"]
    pub fn qsort_r(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __thunk: *mut ::std::os::raw::c_void,
        _compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn _strtold_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtold(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn aligned_alloc(
        arg1: ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn at_quick_exit(
        arg1: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn quick_exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn __assert(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn __assert_func(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub static mut _impure_ptr: *mut _reent;
}
extern "C" {
    pub static mut _global_impure_ptr: *mut _reent;
}
extern "C" {
    pub fn _reclaim_reent(arg1: *mut _reent);
}
extern "C" {
    pub fn _cleanup_r(r: *mut _reent);
}
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = __intptr_t;
pub type __sigset_t = ::std::os::raw::c_ulong;
pub type suseconds_t = __suseconds_t;
pub type time_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
pub type sigset_t = __sigset_t;
pub type fd_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _types_fd_set {
    pub fds_bits: [fd_mask; 1usize],
}
#[test]
fn bindgen_test_layout__types_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<_types_fd_set>(),
        8usize,
        concat!("Size of: ", stringify!(_types_fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<_types_fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(_types_fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_types_fd_set>())).fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_types_fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
extern "C" {
    pub fn select(
        __n: ::std::os::raw::c_int,
        __readfds: *mut _types_fd_set,
        __writefds: *mut _types_fd_set,
        __exceptfds: *mut _types_fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __n: ::std::os::raw::c_int,
        __readfds: *mut _types_fd_set,
        __writefds: *mut _types_fd_set,
        __exceptfds: *mut _types_fd_set,
        __timeout: *const timespec,
        __set: *const sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type u_register_t = __uintptr_t;
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type ulong = ::std::os::raw::c_ulong;
pub type blkcnt_t = __blkcnt_t;
pub type blksize_t = __blksize_t;
pub type clock_t = ::std::os::raw::c_ulong;
pub type daddr_t = ::std::os::raw::c_long;
pub type caddr_t = *mut ::std::os::raw::c_char;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type id_t = __id_t;
pub type ino_t = __ino_t;
pub type off_t = __off_t;
pub type dev_t = __dev_t;
pub type uid_t = __uid_t;
pub type gid_t = __gid_t;
pub type pid_t = __pid_t;
pub type key_t = __key_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type useconds_t = __useconds_t;
pub type sbintime_t = __int64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    assert_eq!(
        ::std::mem::size_of::<sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_param>())).sched_priority as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(sched_priority)
        )
    );
}
extern "C" {
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
pub type pthread_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_attr_t {
    pub is_initialized: ::std::os::raw::c_int,
    pub stackaddr: *mut ::std::os::raw::c_void,
    pub stacksize: ::std::os::raw::c_int,
    pub contentionscope: ::std::os::raw::c_int,
    pub inheritsched: ::std::os::raw::c_int,
    pub schedpolicy: ::std::os::raw::c_int,
    pub schedparam: sched_param,
    pub detachstate: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).is_initialized as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(is_initialized)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).stackaddr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(stackaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).stacksize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(stacksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).contentionscope as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(contentionscope)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).inheritsched as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(inheritsched)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).schedpolicy as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(schedpolicy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).schedparam as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(schedparam)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).detachstate as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(detachstate)
        )
    );
}
pub type pthread_mutex_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutexattr_t {
    pub is_initialized: ::std::os::raw::c_int,
    pub recursive: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_mutexattr_t>())).is_initialized as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(is_initialized)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).recursive as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(recursive)
        )
    );
}
pub type pthread_cond_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_condattr_t {
    pub is_initialized: ::std::os::raw::c_int,
    pub clock: clock_t,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_condattr_t>())).is_initialized as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(is_initialized)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).clock as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(clock)
        )
    );
}
pub type pthread_key_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_once_t {
    pub is_initialized: ::std::os::raw::c_int,
    pub init_executed: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_once_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_once_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_once_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_once_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_once_t>())).is_initialized as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_once_t),
            "::",
            stringify!(is_initialized)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_once_t>())).init_executed as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_once_t),
            "::",
            stringify!(init_executed)
        )
    );
}
pub type FILE = __FILE;
pub type fpos_t = _fpos_t;
extern "C" {
    pub fn ctermid(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn freopen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fputc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const ::std::os::raw::c_char, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        arg1: *mut ::std::os::raw::c_void,
        _size: ::std::os::raw::c_ulong,
        _n: ::std::os::raw::c_ulong,
        arg2: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        arg1: *const ::std::os::raw::c_void,
        _size: ::std::os::raw::c_ulong,
        _n: ::std::os::raw::c_ulong,
        arg2: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(
        arg1: *mut FILE,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn fopen(
        _name: *const ::std::os::raw::c_char,
        _type: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn sprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseeko(
        arg1: *mut FILE,
        arg2: off_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(arg1: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_ulong,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_ulong,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn asiprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn asniprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut usize,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asnprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut usize,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn diprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fiprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fiscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iprintf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iscanf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn siprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn siscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sniprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasiprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasniprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut usize,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn vasnprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut usize,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn vdiprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfiprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfiscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn viprintf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn viscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsiprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsiscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsniprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fdopen(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuffer(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn putc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fmemopen(
        arg1: *mut ::std::os::raw::c_void,
        arg2: usize,
        arg3: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(arg1: *mut *mut ::std::os::raw::c_char, arg2: *mut usize) -> *mut FILE;
}
extern "C" {
    pub fn vdprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _asiprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _asniprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut usize,
        arg4: *const ::std::os::raw::c_char,
        ...
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _asnprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut usize,
        arg4: *const ::std::os::raw::c_char,
        ...
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _asprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _diprintf_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _dprintf_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fclose_r(arg1: *mut _reent, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fcloseall_r(arg1: *mut _reent) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fdopen_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fflush_r(arg1: *mut _reent, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fgetc_r(arg1: *mut _reent, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fgetc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fgets_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _fgets_unlocked_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _fgetpos_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *mut fpos_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fsetpos_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const fpos_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fiprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fiscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fmemopen_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fopen_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _freopen_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fpurge_r(arg1: *mut _reent, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fputc_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fputc_unlocked_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fputs_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fputs_unlocked_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fread_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fread_unlocked_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fseek_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: ::std::os::raw::c_long,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fseeko_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: _off_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _ftell_r(arg1: *mut _reent, arg2: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _ftello_r(arg1: *mut _reent, arg2: *mut FILE) -> _off_t;
}
extern "C" {
    pub fn _rewind_r(arg1: *mut _reent, arg2: *mut FILE);
}
extern "C" {
    pub fn _fwrite_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fwrite_unlocked_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _getc_r(arg1: *mut _reent, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _getc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _getchar_r(arg1: *mut _reent) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _getchar_unlocked_r(arg1: *mut _reent) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _gets_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _iprintf_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iscanf_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _open_memstream_r(
        arg1: *mut _reent,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _perror_r(arg1: *mut _reent, arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn _printf_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putc_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putc_unlocked_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putchar_unlocked_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putchar_r(arg1: *mut _reent, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _puts_r(arg1: *mut _reent, arg2: *const ::std::os::raw::c_char)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _remove_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _rename_r(
        arg1: *mut _reent,
        _old: *const ::std::os::raw::c_char,
        _new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _scanf_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _siprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _siscanf_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _sniprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _snprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _sprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _sscanf_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _tempnam_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _tmpfile_r(arg1: *mut _reent) -> *mut FILE;
}
extern "C" {
    pub fn _tmpnam_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ungetc_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vasiprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vasniprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut usize,
        arg4: *const ::std::os::raw::c_char,
        arg5: *mut __va_list_tag,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _vasnprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut usize,
        arg4: *const ::std::os::raw::c_char,
        arg5: *mut __va_list_tag,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _vasprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vdiprintf_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vdprintf_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vfiprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vfiscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vfprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vfscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _viprintf_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _viscanf_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vprintf_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vscanf_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsiprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsiscanf_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsniprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
        arg5: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsnprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
        arg5: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsscanf_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __getdelim(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut usize,
        arg3: ::std::os::raw::c_int,
        arg4: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn __getline(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut usize,
        arg3: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn clearerr_unlocked(arg1: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread_unlocked(
        arg1: *mut ::std::os::raw::c_void,
        _size: usize,
        _n: usize,
        arg2: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        arg1: *const ::std::os::raw::c_void,
        _size: usize,
        _n: usize,
        arg2: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn __srget_r(arg1: *mut _reent, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __swbuf_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funopen(
        __cookie: *const ::std::os::raw::c_void,
        __readfn: ::std::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::std::os::raw::c_void,
                __buf: *mut ::std::os::raw::c_char,
                __n: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        __writefn: ::std::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::std::os::raw::c_void,
                __buf: *const ::std::os::raw::c_char,
                __n: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        __seekfn: ::std::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::std::os::raw::c_void,
                __off: fpos_t,
                __whence: ::std::os::raw::c_int,
            ) -> fpos_t,
        >,
        __closefn: ::std::option::Option<
            unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _funopen_r(
        arg1: *mut _reent,
        __cookie: *const ::std::os::raw::c_void,
        __readfn: ::std::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::std::os::raw::c_void,
                __buf: *mut ::std::os::raw::c_char,
                __n: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        __writefn: ::std::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::std::os::raw::c_void,
                __buf: *const ::std::os::raw::c_char,
                __n: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        __seekfn: ::std::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::std::os::raw::c_void,
                __off: fpos_t,
                __whence: ::std::os::raw::c_int,
            ) -> fpos_t,
        >,
        __closefn: ::std::option::Option<
            unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
    ) -> *mut FILE;
}
pub type esp_err_t = ::std::os::raw::c_int;
extern "C" {
    #[doc = " @brief Returns string for esp_err_t error codes"]
    #[doc = ""]
    #[doc = " This function finds the error code in a pre-generated lookup-table and"]
    #[doc = " returns its string representation."]
    #[doc = ""]
    #[doc = " The function is generated by the Python script"]
    #[doc = " tools/gen_esp_err_to_name.py which should be run each time an esp_err_t"]
    #[doc = " error is modified, created or removed from the IDF project."]
    #[doc = ""]
    #[doc = " @param code esp_err_t error code"]
    #[doc = " @return string error message"]
    pub fn esp_err_to_name(code: esp_err_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Returns string for esp_err_t and system error codes"]
    #[doc = ""]
    #[doc = " This function finds the error code in a pre-generated lookup-table of"]
    #[doc = " esp_err_t errors and returns its string representation. If the error code"]
    #[doc = " is not found then it is attempted to be found among system errors."]
    #[doc = ""]
    #[doc = " The function is generated by the Python script"]
    #[doc = " tools/gen_esp_err_to_name.py which should be run each time an esp_err_t"]
    #[doc = " error is modified, created or removed from the IDF project."]
    #[doc = ""]
    #[doc = " @param code esp_err_t error code"]
    #[doc = " @param[out] buf buffer where the error message should be written"]
    #[doc = " @param buflen Size of buffer buf. At most buflen bytes are written into the buf buffer (including the terminating null byte)."]
    #[doc = " @return buf containing the string error message"]
    pub fn esp_err_to_name_r(
        code: esp_err_t,
        buf: *mut ::std::os::raw::c_char,
        buflen: usize,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @cond"]
    pub fn _esp_error_check_failed(
        rc: esp_err_t,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        function: *const ::std::os::raw::c_char,
        expression: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @cond"]
    pub fn _esp_error_check_failed_without_abort(
        rc: esp_err_t,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        function: *const ::std::os::raw::c_char,
        expression: *const ::std::os::raw::c_char,
    );
}
#[doc = " Function prototype for interrupt handler function"]
pub type intr_handler_t =
    ::std::option::Option<unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct intr_handle_data_t {
    _unused: [u8; 0],
}
#[doc = " Handle to an interrupt handler"]
pub type intr_handle_t = *mut intr_handle_data_t;
extern "C" {
    #[doc = " @brief Mark an interrupt as a shared interrupt"]
    #[doc = ""]
    #[doc = " This will mark a certain interrupt on the specified CPU as"]
    #[doc = " an interrupt that can be used to hook shared interrupt handlers"]
    #[doc = " to."]
    #[doc = ""]
    #[doc = " @param intno The number of the interrupt (0-31)"]
    #[doc = " @param cpu CPU on which the interrupt should be marked as shared (0 or 1)"]
    #[doc = " @param is_in_iram Shared interrupt is for handlers that reside in IRAM and"]
    #[doc = "                   the int can be left enabled while the flash cache is disabled."]
    #[doc = ""]
    #[doc = " @return ESP_ERR_INVALID_ARG if cpu or intno is invalid"]
    #[doc = "         ESP_OK otherwise"]
    pub fn esp_intr_mark_shared(
        intno: ::std::os::raw::c_int,
        cpu: ::std::os::raw::c_int,
        is_in_iram: bool,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Reserve an interrupt to be used outside of this framework"]
    #[doc = ""]
    #[doc = " This will mark a certain interrupt on the specified CPU as"]
    #[doc = " reserved, not to be allocated for any reason."]
    #[doc = ""]
    #[doc = " @param intno The number of the interrupt (0-31)"]
    #[doc = " @param cpu CPU on which the interrupt should be marked as shared (0 or 1)"]
    #[doc = ""]
    #[doc = " @return ESP_ERR_INVALID_ARG if cpu or intno is invalid"]
    #[doc = "         ESP_OK otherwise"]
    pub fn esp_intr_reserve(intno: ::std::os::raw::c_int, cpu: ::std::os::raw::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Allocate an interrupt with the given parameters."]
    #[doc = ""]
    #[doc = " This finds an interrupt that matches the restrictions as given in the flags"]
    #[doc = " parameter, maps the given interrupt source to it and hooks up the given"]
    #[doc = " interrupt handler (with optional argument) as well. If needed, it can return"]
    #[doc = " a handle for the interrupt as well."]
    #[doc = ""]
    #[doc = " The interrupt will always be allocated on the core that runs this function."]
    #[doc = ""]
    #[doc = " If ESP_INTR_FLAG_IRAM flag is used, and handler address is not in IRAM or"]
    #[doc = " RTC_FAST_MEM, then ESP_ERR_INVALID_ARG is returned."]
    #[doc = ""]
    #[doc = " @param source The interrupt source. One of the ETS_*_INTR_SOURCE interrupt mux"]
    #[doc = "               sources, as defined in soc/soc.h, or one of the internal"]
    #[doc = "               ETS_INTERNAL_*_INTR_SOURCE sources as defined in this header."]
    #[doc = " @param flags An ORred mask of the ESP_INTR_FLAG_* defines. These restrict the"]
    #[doc = "               choice of interrupts that this routine can choose from. If this value"]
    #[doc = "               is 0, it will default to allocating a non-shared interrupt of level"]
    #[doc = "               1, 2 or 3. If this is ESP_INTR_FLAG_SHARED, it will allocate a shared"]
    #[doc = "               interrupt of level 1. Setting ESP_INTR_FLAG_INTRDISABLED will return"]
    #[doc = "               from this function with the interrupt disabled."]
    #[doc = " @param handler The interrupt handler. Must be NULL when an interrupt of level >3"]
    #[doc = "               is requested, because these types of interrupts aren't C-callable."]
    #[doc = " @param arg    Optional argument for passed to the interrupt handler"]
    #[doc = " @param ret_handle Pointer to an intr_handle_t to store a handle that can later be"]
    #[doc = "               used to request details or free the interrupt. Can be NULL if no handle"]
    #[doc = "               is required."]
    #[doc = ""]
    #[doc = " @return ESP_ERR_INVALID_ARG if the combination of arguments is invalid."]
    #[doc = "         ESP_ERR_NOT_FOUND No free interrupt found with the specified flags"]
    #[doc = "         ESP_OK otherwise"]
    pub fn esp_intr_alloc(
        source: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
        handler: intr_handler_t,
        arg: *mut ::std::os::raw::c_void,
        ret_handle: *mut intr_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Allocate an interrupt with the given parameters."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " This essentially does the same as esp_intr_alloc, but allows specifying a register and mask"]
    #[doc = " combo. For shared interrupts, the handler is only called if a read from the specified"]
    #[doc = " register, ANDed with the mask, returns non-zero. By passing an interrupt status register"]
    #[doc = " address and a fitting mask, this can be used to accelerate interrupt handling in the case"]
    #[doc = " a shared interrupt is triggered; by checking the interrupt statuses first, the code can"]
    #[doc = " decide which ISRs can be skipped"]
    #[doc = ""]
    #[doc = " @param source The interrupt source. One of the ETS_*_INTR_SOURCE interrupt mux"]
    #[doc = "               sources, as defined in soc/soc.h, or one of the internal"]
    #[doc = "               ETS_INTERNAL_*_INTR_SOURCE sources as defined in this header."]
    #[doc = " @param flags An ORred mask of the ESP_INTR_FLAG_* defines. These restrict the"]
    #[doc = "               choice of interrupts that this routine can choose from. If this value"]
    #[doc = "               is 0, it will default to allocating a non-shared interrupt of level"]
    #[doc = "               1, 2 or 3. If this is ESP_INTR_FLAG_SHARED, it will allocate a shared"]
    #[doc = "               interrupt of level 1. Setting ESP_INTR_FLAG_INTRDISABLED will return"]
    #[doc = "               from this function with the interrupt disabled."]
    #[doc = " @param intrstatusreg The address of an interrupt status register"]
    #[doc = " @param intrstatusmask A mask. If a read of address intrstatusreg has any of the bits"]
    #[doc = "               that are 1 in the mask set, the ISR will be called. If not, it will be"]
    #[doc = "               skipped."]
    #[doc = " @param handler The interrupt handler. Must be NULL when an interrupt of level >3"]
    #[doc = "               is requested, because these types of interrupts aren't C-callable."]
    #[doc = " @param arg    Optional argument for passed to the interrupt handler"]
    #[doc = " @param ret_handle Pointer to an intr_handle_t to store a handle that can later be"]
    #[doc = "               used to request details or free the interrupt. Can be NULL if no handle"]
    #[doc = "               is required."]
    #[doc = ""]
    #[doc = " @return ESP_ERR_INVALID_ARG if the combination of arguments is invalid."]
    #[doc = "         ESP_ERR_NOT_FOUND No free interrupt found with the specified flags"]
    #[doc = "         ESP_OK otherwise"]
    pub fn esp_intr_alloc_intrstatus(
        source: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
        intrstatusreg: u32,
        intrstatusmask: u32,
        handler: intr_handler_t,
        arg: *mut ::std::os::raw::c_void,
        ret_handle: *mut intr_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable and free an interrupt."]
    #[doc = ""]
    #[doc = " Use an interrupt handle to disable the interrupt and release the resources associated with it."]
    #[doc = " If the current core is not the core that registered this interrupt, this routine will be assigned to"]
    #[doc = " the core that allocated this interrupt, blocking and waiting until the resource is successfully released."]
    #[doc = ""]
    #[doc = " @note"]
    #[doc = " When the handler shares its source with other handlers, the interrupt status"]
    #[doc = " bits it's responsible for should be managed properly before freeing it. see"]
    #[doc = " ``esp_intr_disable`` for more details. Please do not call this function in ``esp_ipc_call_blocking``."]
    #[doc = ""]
    #[doc = " @param handle The handle, as obtained by esp_intr_alloc or esp_intr_alloc_intrstatus"]
    #[doc = ""]
    #[doc = " @return ESP_ERR_INVALID_ARG the handle is NULL"]
    #[doc = "         ESP_FAIL failed to release this handle"]
    #[doc = "         ESP_OK otherwise"]
    pub fn esp_intr_free(handle: intr_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get CPU number an interrupt is tied to"]
    #[doc = ""]
    #[doc = " @param handle The handle, as obtained by esp_intr_alloc or esp_intr_alloc_intrstatus"]
    #[doc = ""]
    #[doc = " @return The core number where the interrupt is allocated"]
    pub fn esp_intr_get_cpu(handle: intr_handle_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the allocated interrupt for a certain handle"]
    #[doc = ""]
    #[doc = " @param handle The handle, as obtained by esp_intr_alloc or esp_intr_alloc_intrstatus"]
    #[doc = ""]
    #[doc = " @return The interrupt number"]
    pub fn esp_intr_get_intno(handle: intr_handle_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Disable the interrupt associated with the handle"]
    #[doc = ""]
    #[doc = " @note"]
    #[doc = " 1. For local interrupts (ESP_INTERNAL_* sources), this function has to be called on the"]
    #[doc = " CPU the interrupt is allocated on. Other interrupts have no such restriction."]
    #[doc = " 2. When several handlers sharing a same interrupt source, interrupt status bits, which are"]
    #[doc = " handled in the handler to be disabled, should be masked before the disabling, or handled"]
    #[doc = " in other enabled interrupts properly. Miss of interrupt status handling will cause infinite"]
    #[doc = " interrupt calls and finally system crash."]
    #[doc = ""]
    #[doc = " @param handle The handle, as obtained by esp_intr_alloc or esp_intr_alloc_intrstatus"]
    #[doc = ""]
    #[doc = " @return ESP_ERR_INVALID_ARG if the combination of arguments is invalid."]
    #[doc = "         ESP_OK otherwise"]
    pub fn esp_intr_disable(handle: intr_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable the interrupt associated with the handle"]
    #[doc = ""]
    #[doc = " @note For local interrupts (ESP_INTERNAL_* sources), this function has to be called on the"]
    #[doc = "       CPU the interrupt is allocated on. Other interrupts have no such restriction."]
    #[doc = ""]
    #[doc = " @param handle The handle, as obtained by esp_intr_alloc or esp_intr_alloc_intrstatus"]
    #[doc = ""]
    #[doc = " @return ESP_ERR_INVALID_ARG if the combination of arguments is invalid."]
    #[doc = "         ESP_OK otherwise"]
    pub fn esp_intr_enable(handle: intr_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set the \"in IRAM\" status of the handler."]
    #[doc = ""]
    #[doc = " @note Does not work on shared interrupts."]
    #[doc = ""]
    #[doc = " @param handle The handle, as obtained by esp_intr_alloc or esp_intr_alloc_intrstatus"]
    #[doc = " @param is_in_iram Whether the handler associated with this handle resides in IRAM."]
    #[doc = "                   Handlers residing in IRAM can be called when cache is disabled."]
    #[doc = ""]
    #[doc = " @return ESP_ERR_INVALID_ARG if the combination of arguments is invalid."]
    #[doc = "         ESP_OK otherwise"]
    pub fn esp_intr_set_in_iram(handle: intr_handle_t, is_in_iram: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable interrupts that aren't specifically marked as running from IRAM"]
    pub fn esp_intr_noniram_disable();
}
extern "C" {
    #[doc = " @brief Re-enable interrupts disabled by esp_intr_noniram_disable"]
    pub fn esp_intr_noniram_enable();
}
extern "C" {
    #[doc = " @brief enable the interrupt source based on its number"]
    #[doc = " @param inum interrupt number from 0 to 31"]
    pub fn esp_intr_enable_source(inum: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " @brief disable the interrupt source based on its number"]
    #[doc = " @param inum interrupt number from 0 to 31"]
    pub fn esp_intr_disable_source(inum: ::std::os::raw::c_int);
}
#[doc = "< LEDC high speed speed_mode"]
pub const ledc_mode_t_LEDC_HIGH_SPEED_MODE: ledc_mode_t = 0;
#[doc = "< LEDC low speed speed_mode"]
pub const ledc_mode_t_LEDC_LOW_SPEED_MODE: ledc_mode_t = 1;
#[doc = "< LEDC speed limit"]
pub const ledc_mode_t_LEDC_SPEED_MODE_MAX: ledc_mode_t = 2;
pub type ledc_mode_t = u32;
#[doc = "< Disable LEDC interrupt"]
pub const ledc_intr_type_t_LEDC_INTR_DISABLE: ledc_intr_type_t = 0;
#[doc = "< Enable LEDC interrupt"]
pub const ledc_intr_type_t_LEDC_INTR_FADE_END: ledc_intr_type_t = 1;
pub const ledc_intr_type_t_LEDC_INTR_MAX: ledc_intr_type_t = 2;
pub type ledc_intr_type_t = u32;
#[doc = "< LEDC duty decrease direction"]
pub const ledc_duty_direction_t_LEDC_DUTY_DIR_DECREASE: ledc_duty_direction_t = 0;
#[doc = "< LEDC duty increase direction"]
pub const ledc_duty_direction_t_LEDC_DUTY_DIR_INCREASE: ledc_duty_direction_t = 1;
pub const ledc_duty_direction_t_LEDC_DUTY_DIR_MAX: ledc_duty_direction_t = 2;
pub type ledc_duty_direction_t = u32;
#[doc = "< LEDC low speed timer clock source is 8MHz RTC clock"]
pub const ledc_slow_clk_sel_t_LEDC_SLOW_CLK_RTC8M: ledc_slow_clk_sel_t = 0;
#[doc = "< LEDC low speed timer clock source is 80MHz APB clock"]
pub const ledc_slow_clk_sel_t_LEDC_SLOW_CLK_APB: ledc_slow_clk_sel_t = 1;
pub type ledc_slow_clk_sel_t = u32;
#[doc = "< The driver will automatically select the source clock(REF_TICK or APB) based on the giving resolution and duty parameter when init the timer"]
pub const ledc_clk_cfg_t_LEDC_AUTO_CLK: ledc_clk_cfg_t = 0;
#[doc = "< LEDC timer select REF_TICK clock as source clock"]
pub const ledc_clk_cfg_t_LEDC_USE_REF_TICK: ledc_clk_cfg_t = 1;
#[doc = "< LEDC timer select APB clock as source clock"]
pub const ledc_clk_cfg_t_LEDC_USE_APB_CLK: ledc_clk_cfg_t = 2;
#[doc = "< LEDC timer select RTC8M_CLK as source clock. Only for low speed channels and this parameter must be the same for all low speed channels"]
pub const ledc_clk_cfg_t_LEDC_USE_RTC8M_CLK: ledc_clk_cfg_t = 3;
pub type ledc_clk_cfg_t = u32;
#[doc = "< LEDC timer clock divided from reference tick (1Mhz)"]
pub const ledc_clk_src_t_LEDC_REF_TICK: ledc_clk_src_t = 1;
#[doc = "< LEDC timer clock divided from APB clock (80Mhz)"]
pub const ledc_clk_src_t_LEDC_APB_CLK: ledc_clk_src_t = 2;
pub type ledc_clk_src_t = u32;
#[doc = "< LEDC timer 0"]
pub const ledc_timer_t_LEDC_TIMER_0: ledc_timer_t = 0;
#[doc = "< LEDC timer 1"]
pub const ledc_timer_t_LEDC_TIMER_1: ledc_timer_t = 1;
#[doc = "< LEDC timer 2"]
pub const ledc_timer_t_LEDC_TIMER_2: ledc_timer_t = 2;
#[doc = "< LEDC timer 3"]
pub const ledc_timer_t_LEDC_TIMER_3: ledc_timer_t = 3;
pub const ledc_timer_t_LEDC_TIMER_MAX: ledc_timer_t = 4;
pub type ledc_timer_t = u32;
#[doc = "< LEDC channel 0"]
pub const ledc_channel_t_LEDC_CHANNEL_0: ledc_channel_t = 0;
#[doc = "< LEDC channel 1"]
pub const ledc_channel_t_LEDC_CHANNEL_1: ledc_channel_t = 1;
#[doc = "< LEDC channel 2"]
pub const ledc_channel_t_LEDC_CHANNEL_2: ledc_channel_t = 2;
#[doc = "< LEDC channel 3"]
pub const ledc_channel_t_LEDC_CHANNEL_3: ledc_channel_t = 3;
#[doc = "< LEDC channel 4"]
pub const ledc_channel_t_LEDC_CHANNEL_4: ledc_channel_t = 4;
#[doc = "< LEDC channel 5"]
pub const ledc_channel_t_LEDC_CHANNEL_5: ledc_channel_t = 5;
#[doc = "< LEDC channel 6"]
pub const ledc_channel_t_LEDC_CHANNEL_6: ledc_channel_t = 6;
#[doc = "< LEDC channel 7"]
pub const ledc_channel_t_LEDC_CHANNEL_7: ledc_channel_t = 7;
pub const ledc_channel_t_LEDC_CHANNEL_MAX: ledc_channel_t = 8;
pub type ledc_channel_t = u32;
#[doc = "< LEDC PWM duty resolution of  1 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_1_BIT: ledc_timer_bit_t = 1;
#[doc = "< LEDC PWM duty resolution of  2 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_2_BIT: ledc_timer_bit_t = 2;
#[doc = "< LEDC PWM duty resolution of  3 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_3_BIT: ledc_timer_bit_t = 3;
#[doc = "< LEDC PWM duty resolution of  4 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_4_BIT: ledc_timer_bit_t = 4;
#[doc = "< LEDC PWM duty resolution of  5 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_5_BIT: ledc_timer_bit_t = 5;
#[doc = "< LEDC PWM duty resolution of  6 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_6_BIT: ledc_timer_bit_t = 6;
#[doc = "< LEDC PWM duty resolution of  7 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_7_BIT: ledc_timer_bit_t = 7;
#[doc = "< LEDC PWM duty resolution of  8 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_8_BIT: ledc_timer_bit_t = 8;
#[doc = "< LEDC PWM duty resolution of  9 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_9_BIT: ledc_timer_bit_t = 9;
#[doc = "< LEDC PWM duty resolution of 10 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_10_BIT: ledc_timer_bit_t = 10;
#[doc = "< LEDC PWM duty resolution of 11 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_11_BIT: ledc_timer_bit_t = 11;
#[doc = "< LEDC PWM duty resolution of 12 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_12_BIT: ledc_timer_bit_t = 12;
#[doc = "< LEDC PWM duty resolution of 13 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_13_BIT: ledc_timer_bit_t = 13;
#[doc = "< LEDC PWM duty resolution of 14 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_14_BIT: ledc_timer_bit_t = 14;
#[doc = "< LEDC PWM duty resolution of 15 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_15_BIT: ledc_timer_bit_t = 15;
#[doc = "< LEDC PWM duty resolution of 16 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_16_BIT: ledc_timer_bit_t = 16;
#[doc = "< LEDC PWM duty resolution of 17 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_17_BIT: ledc_timer_bit_t = 17;
#[doc = "< LEDC PWM duty resolution of 18 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_18_BIT: ledc_timer_bit_t = 18;
#[doc = "< LEDC PWM duty resolution of 19 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_19_BIT: ledc_timer_bit_t = 19;
#[doc = "< LEDC PWM duty resolution of 20 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_20_BIT: ledc_timer_bit_t = 20;
pub const ledc_timer_bit_t_LEDC_TIMER_BIT_MAX: ledc_timer_bit_t = 21;
pub type ledc_timer_bit_t = u32;
#[doc = "< LEDC fade function will return immediately"]
pub const ledc_fade_mode_t_LEDC_FADE_NO_WAIT: ledc_fade_mode_t = 0;
#[doc = "< LEDC fade function will block until fading to the target duty"]
pub const ledc_fade_mode_t_LEDC_FADE_WAIT_DONE: ledc_fade_mode_t = 1;
pub const ledc_fade_mode_t_LEDC_FADE_MAX: ledc_fade_mode_t = 2;
pub type ledc_fade_mode_t = u32;
#[doc = " @brief Configuration parameters of LEDC channel for ledc_channel_config function"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ledc_channel_config_t {
    #[doc = "< the LEDC output gpio_num, if you want to use gpio16, gpio_num = 16"]
    pub gpio_num: ::std::os::raw::c_int,
    #[doc = "< LEDC speed speed_mode, high-speed mode or low-speed mode"]
    pub speed_mode: ledc_mode_t,
    #[doc = "< LEDC channel (0 - 7)"]
    pub channel: ledc_channel_t,
    #[doc = "< configure interrupt, Fade interrupt enable  or Fade interrupt disable"]
    pub intr_type: ledc_intr_type_t,
    #[doc = "< Select the timer source of channel (0 - 3)"]
    pub timer_sel: ledc_timer_t,
    #[doc = "< LEDC channel duty, the range of duty setting is [0, (2**duty_resolution)]"]
    pub duty: u32,
    #[doc = "< LEDC channel hpoint value, the max value is 0xfffff"]
    pub hpoint: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ledc_channel_config_t() {
    assert_eq!(
        ::std::mem::size_of::<ledc_channel_config_t>(),
        28usize,
        concat!("Size of: ", stringify!(ledc_channel_config_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ledc_channel_config_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ledc_channel_config_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ledc_channel_config_t>())).gpio_num as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ledc_channel_config_t),
            "::",
            stringify!(gpio_num)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ledc_channel_config_t>())).speed_mode as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ledc_channel_config_t),
            "::",
            stringify!(speed_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ledc_channel_config_t>())).channel as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ledc_channel_config_t),
            "::",
            stringify!(channel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ledc_channel_config_t>())).intr_type as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ledc_channel_config_t),
            "::",
            stringify!(intr_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ledc_channel_config_t>())).timer_sel as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ledc_channel_config_t),
            "::",
            stringify!(timer_sel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ledc_channel_config_t>())).duty as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ledc_channel_config_t),
            "::",
            stringify!(duty)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ledc_channel_config_t>())).hpoint as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ledc_channel_config_t),
            "::",
            stringify!(hpoint)
        )
    );
}
#[doc = " @brief Configuration parameters of LEDC Timer timer for ledc_timer_config function"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ledc_timer_config_t {
    #[doc = "< LEDC speed speed_mode, high-speed mode or low-speed mode"]
    pub speed_mode: ledc_mode_t,
    pub __bindgen_anon_1: ledc_timer_config_t__bindgen_ty_1,
    #[doc = "< The timer source of channel (0 - 3)"]
    pub timer_num: ledc_timer_t,
    #[doc = "< LEDC timer frequency (Hz)"]
    pub freq_hz: u32,
    #[doc = "< Configure LEDC source clock."]
    #[doc = "For low speed channels and high speed channels, you can specify the source clock using LEDC_USE_REF_TICK, LEDC_USE_APB_CLK or LEDC_AUTO_CLK."]
    #[doc = "For low speed channels, you can also specify the source clock using LEDC_USE_RTC8M_CLK, in this case, all low speed channel's source clock must be RTC8M_CLK"]
    pub clk_cfg: ledc_clk_cfg_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ledc_timer_config_t__bindgen_ty_1 {
    #[doc = "< LEDC channel duty resolution"]
    pub duty_resolution: ledc_timer_bit_t,
    #[doc = "< Deprecated in ESP-IDF 3.0. This is an alias to 'duty_resolution' for backward compatibility with ESP-IDF 2.1"]
    pub bit_num: ledc_timer_bit_t,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_ledc_timer_config_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ledc_timer_config_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(ledc_timer_config_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ledc_timer_config_t__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ledc_timer_config_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ledc_timer_config_t__bindgen_ty_1>())).duty_resolution
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ledc_timer_config_t__bindgen_ty_1),
            "::",
            stringify!(duty_resolution)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ledc_timer_config_t__bindgen_ty_1>())).bit_num as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ledc_timer_config_t__bindgen_ty_1),
            "::",
            stringify!(bit_num)
        )
    );
}
#[test]
fn bindgen_test_layout_ledc_timer_config_t() {
    assert_eq!(
        ::std::mem::size_of::<ledc_timer_config_t>(),
        20usize,
        concat!("Size of: ", stringify!(ledc_timer_config_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ledc_timer_config_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ledc_timer_config_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ledc_timer_config_t>())).speed_mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ledc_timer_config_t),
            "::",
            stringify!(speed_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ledc_timer_config_t>())).timer_num as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ledc_timer_config_t),
            "::",
            stringify!(timer_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ledc_timer_config_t>())).freq_hz as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ledc_timer_config_t),
            "::",
            stringify!(freq_hz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ledc_timer_config_t>())).clk_cfg as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ledc_timer_config_t),
            "::",
            stringify!(clk_cfg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gpio_dev_s {
    pub bt_select: u32,
    pub out: u32,
    pub out_w1ts: u32,
    pub out_w1tc: u32,
    pub out1: gpio_dev_s__bindgen_ty_1,
    pub out1_w1ts: gpio_dev_s__bindgen_ty_2,
    pub out1_w1tc: gpio_dev_s__bindgen_ty_3,
    pub sdio_select: gpio_dev_s__bindgen_ty_4,
    pub enable: u32,
    pub enable_w1ts: u32,
    pub enable_w1tc: u32,
    pub enable1: gpio_dev_s__bindgen_ty_5,
    pub enable1_w1ts: gpio_dev_s__bindgen_ty_6,
    pub enable1_w1tc: gpio_dev_s__bindgen_ty_7,
    pub strap: gpio_dev_s__bindgen_ty_8,
    pub in_: u32,
    pub in1: gpio_dev_s__bindgen_ty_9,
    pub status: u32,
    pub status_w1ts: u32,
    pub status_w1tc: u32,
    pub status1: gpio_dev_s__bindgen_ty_10,
    pub status1_w1ts: gpio_dev_s__bindgen_ty_11,
    pub status1_w1tc: gpio_dev_s__bindgen_ty_12,
    pub reserved_5c: u32,
    pub acpu_int: u32,
    pub acpu_nmi_int: u32,
    pub pcpu_int: u32,
    pub pcpu_nmi_int: u32,
    pub cpusdio_int: u32,
    pub acpu_int1: gpio_dev_s__bindgen_ty_13,
    pub acpu_nmi_int1: gpio_dev_s__bindgen_ty_14,
    pub pcpu_int1: gpio_dev_s__bindgen_ty_15,
    pub pcpu_nmi_int1: gpio_dev_s__bindgen_ty_16,
    pub cpusdio_int1: gpio_dev_s__bindgen_ty_17,
    pub pin: [gpio_dev_s__bindgen_ty_18; 40usize],
    pub cali_conf: gpio_dev_s__bindgen_ty_19,
    pub cali_data: gpio_dev_s__bindgen_ty_20,
    pub func_in_sel_cfg: [gpio_dev_s__bindgen_ty_21; 256usize],
    pub func_out_sel_cfg: [gpio_dev_s__bindgen_ty_22; 40usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_1 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_1__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_gpio_dev_s__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<gpio_dev_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(gpio_dev_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<gpio_dev_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(gpio_dev_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl gpio_dev_s__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn data(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(data: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let data: u32 = unsafe { ::std::mem::transmute(data) };
            data as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::std::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_gpio_dev_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<gpio_dev_s__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(gpio_dev_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<gpio_dev_s__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(gpio_dev_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s__bindgen_ty_1>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s__bindgen_ty_1),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_2 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_2__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_gpio_dev_s__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<gpio_dev_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(gpio_dev_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<gpio_dev_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(gpio_dev_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
}
impl gpio_dev_s__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn data(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(data: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let data: u32 = unsafe { ::std::mem::transmute(data) };
            data as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::std::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_gpio_dev_s__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<gpio_dev_s__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(gpio_dev_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<gpio_dev_s__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(gpio_dev_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s__bindgen_ty_2>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s__bindgen_ty_2),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_3 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_3__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_gpio_dev_s__bindgen_ty_3__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<gpio_dev_s__bindgen_ty_3__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(gpio_dev_s__bindgen_ty_3__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<gpio_dev_s__bindgen_ty_3__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(gpio_dev_s__bindgen_ty_3__bindgen_ty_1)
        )
    );
}
impl gpio_dev_s__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn data(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(data: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let data: u32 = unsafe { ::std::mem::transmute(data) };
            data as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::std::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_gpio_dev_s__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<gpio_dev_s__bindgen_ty_3>(),
        4usize,
        concat!("Size of: ", stringify!(gpio_dev_s__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<gpio_dev_s__bindgen_ty_3>(),
        4usize,
        concat!("Alignment of ", stringify!(gpio_dev_s__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s__bindgen_ty_3>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s__bindgen_ty_3),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_4 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_4__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_4__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_gpio_dev_s__bindgen_ty_4__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<gpio_dev_s__bindgen_ty_4__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(gpio_dev_s__bindgen_ty_4__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<gpio_dev_s__bindgen_ty_4__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(gpio_dev_s__bindgen_ty_4__bindgen_ty_1)
        )
    );
}
impl gpio_dev_s__bindgen_ty_4__bindgen_ty_1 {
    #[inline]
    pub fn sel(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(sel: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let sel: u32 = unsafe { ::std::mem::transmute(sel) };
            sel as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::std::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_gpio_dev_s__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<gpio_dev_s__bindgen_ty_4>(),
        4usize,
        concat!("Size of: ", stringify!(gpio_dev_s__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<gpio_dev_s__bindgen_ty_4>(),
        4usize,
        concat!("Alignment of ", stringify!(gpio_dev_s__bindgen_ty_4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s__bindgen_ty_4>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s__bindgen_ty_4),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_5 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_5__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_5__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_gpio_dev_s__bindgen_ty_5__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<gpio_dev_s__bindgen_ty_5__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(gpio_dev_s__bindgen_ty_5__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<gpio_dev_s__bindgen_ty_5__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(gpio_dev_s__bindgen_ty_5__bindgen_ty_1)
        )
    );
}
impl gpio_dev_s__bindgen_ty_5__bindgen_ty_1 {
    #[inline]
    pub fn data(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(data: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let data: u32 = unsafe { ::std::mem::transmute(data) };
            data as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::std::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_gpio_dev_s__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<gpio_dev_s__bindgen_ty_5>(),
        4usize,
        concat!("Size of: ", stringify!(gpio_dev_s__bindgen_ty_5))
    );
    assert_eq!(
        ::std::mem::align_of::<gpio_dev_s__bindgen_ty_5>(),
        4usize,
        concat!("Alignment of ", stringify!(gpio_dev_s__bindgen_ty_5))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s__bindgen_ty_5>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s__bindgen_ty_5),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_6 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_6__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_6__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_gpio_dev_s__bindgen_ty_6__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<gpio_dev_s__bindgen_ty_6__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(gpio_dev_s__bindgen_ty_6__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<gpio_dev_s__bindgen_ty_6__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(gpio_dev_s__bindgen_ty_6__bindgen_ty_1)
        )
    );
}
impl gpio_dev_s__bindgen_ty_6__bindgen_ty_1 {
    #[inline]
    pub fn data(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(data: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let data: u32 = unsafe { ::std::mem::transmute(data) };
            data as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::std::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_gpio_dev_s__bindgen_ty_6() {
    assert_eq!(
        ::std::mem::size_of::<gpio_dev_s__bindgen_ty_6>(),
        4usize,
        concat!("Size of: ", stringify!(gpio_dev_s__bindgen_ty_6))
    );
    assert_eq!(
        ::std::mem::align_of::<gpio_dev_s__bindgen_ty_6>(),
        4usize,
        concat!("Alignment of ", stringify!(gpio_dev_s__bindgen_ty_6))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s__bindgen_ty_6>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s__bindgen_ty_6),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_7 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_7__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_7__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_gpio_dev_s__bindgen_ty_7__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<gpio_dev_s__bindgen_ty_7__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(gpio_dev_s__bindgen_ty_7__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<gpio_dev_s__bindgen_ty_7__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(gpio_dev_s__bindgen_ty_7__bindgen_ty_1)
        )
    );
}
impl gpio_dev_s__bindgen_ty_7__bindgen_ty_1 {
    #[inline]
    pub fn data(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(data: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let data: u32 = unsafe { ::std::mem::transmute(data) };
            data as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::std::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_gpio_dev_s__bindgen_ty_7() {
    assert_eq!(
        ::std::mem::size_of::<gpio_dev_s__bindgen_ty_7>(),
        4usize,
        concat!("Size of: ", stringify!(gpio_dev_s__bindgen_ty_7))
    );
    assert_eq!(
        ::std::mem::align_of::<gpio_dev_s__bindgen_ty_7>(),
        4usize,
        concat!("Alignment of ", stringify!(gpio_dev_s__bindgen_ty_7))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s__bindgen_ty_7>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s__bindgen_ty_7),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_8 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_8__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_8__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[test]
fn bindgen_test_layout_gpio_dev_s__bindgen_ty_8__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<gpio_dev_s__bindgen_ty_8__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(gpio_dev_s__bindgen_ty_8__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<gpio_dev_s__bindgen_ty_8__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(gpio_dev_s__bindgen_ty_8__bindgen_ty_1)
        )
    );
}
impl gpio_dev_s__bindgen_ty_8__bindgen_ty_1 {
    #[inline]
    pub fn strapping(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_strapping(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved16(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        strapping: u32,
        reserved16: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let strapping: u32 = unsafe { ::std::mem::transmute(strapping) };
            strapping as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let reserved16: u32 = unsafe { ::std::mem::transmute(reserved16) };
            reserved16 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_gpio_dev_s__bindgen_ty_8() {
    assert_eq!(
        ::std::mem::size_of::<gpio_dev_s__bindgen_ty_8>(),
        4usize,
        concat!("Size of: ", stringify!(gpio_dev_s__bindgen_ty_8))
    );
    assert_eq!(
        ::std::mem::align_of::<gpio_dev_s__bindgen_ty_8>(),
        4usize,
        concat!("Alignment of ", stringify!(gpio_dev_s__bindgen_ty_8))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s__bindgen_ty_8>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s__bindgen_ty_8),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_9 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_9__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_9__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_gpio_dev_s__bindgen_ty_9__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<gpio_dev_s__bindgen_ty_9__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(gpio_dev_s__bindgen_ty_9__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<gpio_dev_s__bindgen_ty_9__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(gpio_dev_s__bindgen_ty_9__bindgen_ty_1)
        )
    );
}
impl gpio_dev_s__bindgen_ty_9__bindgen_ty_1 {
    #[inline]
    pub fn data(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(data: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let data: u32 = unsafe { ::std::mem::transmute(data) };
            data as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::std::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_gpio_dev_s__bindgen_ty_9() {
    assert_eq!(
        ::std::mem::size_of::<gpio_dev_s__bindgen_ty_9>(),
        4usize,
        concat!("Size of: ", stringify!(gpio_dev_s__bindgen_ty_9))
    );
    assert_eq!(
        ::std::mem::align_of::<gpio_dev_s__bindgen_ty_9>(),
        4usize,
        concat!("Alignment of ", stringify!(gpio_dev_s__bindgen_ty_9))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s__bindgen_ty_9>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s__bindgen_ty_9),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_10 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_10__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_10__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_gpio_dev_s__bindgen_ty_10__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<gpio_dev_s__bindgen_ty_10__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(gpio_dev_s__bindgen_ty_10__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<gpio_dev_s__bindgen_ty_10__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(gpio_dev_s__bindgen_ty_10__bindgen_ty_1)
        )
    );
}
impl gpio_dev_s__bindgen_ty_10__bindgen_ty_1 {
    #[inline]
    pub fn intr_st(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_intr_st(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        intr_st: u32,
        reserved8: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let intr_st: u32 = unsafe { ::std::mem::transmute(intr_st) };
            intr_st as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::std::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_gpio_dev_s__bindgen_ty_10() {
    assert_eq!(
        ::std::mem::size_of::<gpio_dev_s__bindgen_ty_10>(),
        4usize,
        concat!("Size of: ", stringify!(gpio_dev_s__bindgen_ty_10))
    );
    assert_eq!(
        ::std::mem::align_of::<gpio_dev_s__bindgen_ty_10>(),
        4usize,
        concat!("Alignment of ", stringify!(gpio_dev_s__bindgen_ty_10))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s__bindgen_ty_10>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s__bindgen_ty_10),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_11 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_11__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_11__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_gpio_dev_s__bindgen_ty_11__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<gpio_dev_s__bindgen_ty_11__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(gpio_dev_s__bindgen_ty_11__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<gpio_dev_s__bindgen_ty_11__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(gpio_dev_s__bindgen_ty_11__bindgen_ty_1)
        )
    );
}
impl gpio_dev_s__bindgen_ty_11__bindgen_ty_1 {
    #[inline]
    pub fn intr_st(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_intr_st(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        intr_st: u32,
        reserved8: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let intr_st: u32 = unsafe { ::std::mem::transmute(intr_st) };
            intr_st as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::std::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_gpio_dev_s__bindgen_ty_11() {
    assert_eq!(
        ::std::mem::size_of::<gpio_dev_s__bindgen_ty_11>(),
        4usize,
        concat!("Size of: ", stringify!(gpio_dev_s__bindgen_ty_11))
    );
    assert_eq!(
        ::std::mem::align_of::<gpio_dev_s__bindgen_ty_11>(),
        4usize,
        concat!("Alignment of ", stringify!(gpio_dev_s__bindgen_ty_11))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s__bindgen_ty_11>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s__bindgen_ty_11),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_12 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_12__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_12__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_gpio_dev_s__bindgen_ty_12__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<gpio_dev_s__bindgen_ty_12__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(gpio_dev_s__bindgen_ty_12__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<gpio_dev_s__bindgen_ty_12__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(gpio_dev_s__bindgen_ty_12__bindgen_ty_1)
        )
    );
}
impl gpio_dev_s__bindgen_ty_12__bindgen_ty_1 {
    #[inline]
    pub fn intr_st(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_intr_st(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        intr_st: u32,
        reserved8: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let intr_st: u32 = unsafe { ::std::mem::transmute(intr_st) };
            intr_st as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::std::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_gpio_dev_s__bindgen_ty_12() {
    assert_eq!(
        ::std::mem::size_of::<gpio_dev_s__bindgen_ty_12>(),
        4usize,
        concat!("Size of: ", stringify!(gpio_dev_s__bindgen_ty_12))
    );
    assert_eq!(
        ::std::mem::align_of::<gpio_dev_s__bindgen_ty_12>(),
        4usize,
        concat!("Alignment of ", stringify!(gpio_dev_s__bindgen_ty_12))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s__bindgen_ty_12>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s__bindgen_ty_12),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_13 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_13__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_13__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_gpio_dev_s__bindgen_ty_13__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<gpio_dev_s__bindgen_ty_13__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(gpio_dev_s__bindgen_ty_13__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<gpio_dev_s__bindgen_ty_13__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(gpio_dev_s__bindgen_ty_13__bindgen_ty_1)
        )
    );
}
impl gpio_dev_s__bindgen_ty_13__bindgen_ty_1 {
    #[inline]
    pub fn intr(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_intr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(intr: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let intr: u32 = unsafe { ::std::mem::transmute(intr) };
            intr as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::std::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_gpio_dev_s__bindgen_ty_13() {
    assert_eq!(
        ::std::mem::size_of::<gpio_dev_s__bindgen_ty_13>(),
        4usize,
        concat!("Size of: ", stringify!(gpio_dev_s__bindgen_ty_13))
    );
    assert_eq!(
        ::std::mem::align_of::<gpio_dev_s__bindgen_ty_13>(),
        4usize,
        concat!("Alignment of ", stringify!(gpio_dev_s__bindgen_ty_13))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s__bindgen_ty_13>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s__bindgen_ty_13),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_14 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_14__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_14__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_gpio_dev_s__bindgen_ty_14__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<gpio_dev_s__bindgen_ty_14__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(gpio_dev_s__bindgen_ty_14__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<gpio_dev_s__bindgen_ty_14__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(gpio_dev_s__bindgen_ty_14__bindgen_ty_1)
        )
    );
}
impl gpio_dev_s__bindgen_ty_14__bindgen_ty_1 {
    #[inline]
    pub fn intr(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_intr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(intr: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let intr: u32 = unsafe { ::std::mem::transmute(intr) };
            intr as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::std::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_gpio_dev_s__bindgen_ty_14() {
    assert_eq!(
        ::std::mem::size_of::<gpio_dev_s__bindgen_ty_14>(),
        4usize,
        concat!("Size of: ", stringify!(gpio_dev_s__bindgen_ty_14))
    );
    assert_eq!(
        ::std::mem::align_of::<gpio_dev_s__bindgen_ty_14>(),
        4usize,
        concat!("Alignment of ", stringify!(gpio_dev_s__bindgen_ty_14))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s__bindgen_ty_14>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s__bindgen_ty_14),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_15 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_15__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_15__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_gpio_dev_s__bindgen_ty_15__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<gpio_dev_s__bindgen_ty_15__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(gpio_dev_s__bindgen_ty_15__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<gpio_dev_s__bindgen_ty_15__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(gpio_dev_s__bindgen_ty_15__bindgen_ty_1)
        )
    );
}
impl gpio_dev_s__bindgen_ty_15__bindgen_ty_1 {
    #[inline]
    pub fn intr(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_intr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(intr: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let intr: u32 = unsafe { ::std::mem::transmute(intr) };
            intr as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::std::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_gpio_dev_s__bindgen_ty_15() {
    assert_eq!(
        ::std::mem::size_of::<gpio_dev_s__bindgen_ty_15>(),
        4usize,
        concat!("Size of: ", stringify!(gpio_dev_s__bindgen_ty_15))
    );
    assert_eq!(
        ::std::mem::align_of::<gpio_dev_s__bindgen_ty_15>(),
        4usize,
        concat!("Alignment of ", stringify!(gpio_dev_s__bindgen_ty_15))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s__bindgen_ty_15>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s__bindgen_ty_15),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_16 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_16__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_16__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_gpio_dev_s__bindgen_ty_16__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<gpio_dev_s__bindgen_ty_16__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(gpio_dev_s__bindgen_ty_16__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<gpio_dev_s__bindgen_ty_16__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(gpio_dev_s__bindgen_ty_16__bindgen_ty_1)
        )
    );
}
impl gpio_dev_s__bindgen_ty_16__bindgen_ty_1 {
    #[inline]
    pub fn intr(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_intr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(intr: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let intr: u32 = unsafe { ::std::mem::transmute(intr) };
            intr as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::std::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_gpio_dev_s__bindgen_ty_16() {
    assert_eq!(
        ::std::mem::size_of::<gpio_dev_s__bindgen_ty_16>(),
        4usize,
        concat!("Size of: ", stringify!(gpio_dev_s__bindgen_ty_16))
    );
    assert_eq!(
        ::std::mem::align_of::<gpio_dev_s__bindgen_ty_16>(),
        4usize,
        concat!("Alignment of ", stringify!(gpio_dev_s__bindgen_ty_16))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s__bindgen_ty_16>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s__bindgen_ty_16),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_17 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_17__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_17__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_gpio_dev_s__bindgen_ty_17__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<gpio_dev_s__bindgen_ty_17__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(gpio_dev_s__bindgen_ty_17__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<gpio_dev_s__bindgen_ty_17__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(gpio_dev_s__bindgen_ty_17__bindgen_ty_1)
        )
    );
}
impl gpio_dev_s__bindgen_ty_17__bindgen_ty_1 {
    #[inline]
    pub fn intr(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_intr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(intr: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let intr: u32 = unsafe { ::std::mem::transmute(intr) };
            intr as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::std::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_gpio_dev_s__bindgen_ty_17() {
    assert_eq!(
        ::std::mem::size_of::<gpio_dev_s__bindgen_ty_17>(),
        4usize,
        concat!("Size of: ", stringify!(gpio_dev_s__bindgen_ty_17))
    );
    assert_eq!(
        ::std::mem::align_of::<gpio_dev_s__bindgen_ty_17>(),
        4usize,
        concat!("Alignment of ", stringify!(gpio_dev_s__bindgen_ty_17))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s__bindgen_ty_17>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s__bindgen_ty_17),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_18 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_18__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_18__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[test]
fn bindgen_test_layout_gpio_dev_s__bindgen_ty_18__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<gpio_dev_s__bindgen_ty_18__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(gpio_dev_s__bindgen_ty_18__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<gpio_dev_s__bindgen_ty_18__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(gpio_dev_s__bindgen_ty_18__bindgen_ty_1)
        )
    );
}
impl gpio_dev_s__bindgen_ty_18__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn pad_driver(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pad_driver(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved3(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn int_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_int_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn wakeup_enable(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wakeup_enable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn config(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_config(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn int_ena(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_int_ena(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved18(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved18(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        pad_driver: u32,
        reserved3: u32,
        int_type: u32,
        wakeup_enable: u32,
        config: u32,
        int_ena: u32,
        reserved18: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let reserved0: u32 = unsafe { ::std::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let pad_driver: u32 = unsafe { ::std::mem::transmute(pad_driver) };
            pad_driver as u64
        });
        __bindgen_bitfield_unit.set(3usize, 4u8, {
            let reserved3: u32 = unsafe { ::std::mem::transmute(reserved3) };
            reserved3 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 3u8, {
            let int_type: u32 = unsafe { ::std::mem::transmute(int_type) };
            int_type as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let wakeup_enable: u32 = unsafe { ::std::mem::transmute(wakeup_enable) };
            wakeup_enable as u64
        });
        __bindgen_bitfield_unit.set(11usize, 2u8, {
            let config: u32 = unsafe { ::std::mem::transmute(config) };
            config as u64
        });
        __bindgen_bitfield_unit.set(13usize, 5u8, {
            let int_ena: u32 = unsafe { ::std::mem::transmute(int_ena) };
            int_ena as u64
        });
        __bindgen_bitfield_unit.set(18usize, 14u8, {
            let reserved18: u32 = unsafe { ::std::mem::transmute(reserved18) };
            reserved18 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_gpio_dev_s__bindgen_ty_18() {
    assert_eq!(
        ::std::mem::size_of::<gpio_dev_s__bindgen_ty_18>(),
        4usize,
        concat!("Size of: ", stringify!(gpio_dev_s__bindgen_ty_18))
    );
    assert_eq!(
        ::std::mem::align_of::<gpio_dev_s__bindgen_ty_18>(),
        4usize,
        concat!("Alignment of ", stringify!(gpio_dev_s__bindgen_ty_18))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s__bindgen_ty_18>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s__bindgen_ty_18),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_19 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_19__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_19__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_gpio_dev_s__bindgen_ty_19__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<gpio_dev_s__bindgen_ty_19__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(gpio_dev_s__bindgen_ty_19__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<gpio_dev_s__bindgen_ty_19__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(gpio_dev_s__bindgen_ty_19__bindgen_ty_1)
        )
    );
}
impl gpio_dev_s__bindgen_ty_19__bindgen_ty_1 {
    #[inline]
    pub fn rtc_max(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_max(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved10(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 21u8) as u32) }
    }
    #[inline]
    pub fn set_reserved10(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 21u8, val as u64)
        }
    }
    #[inline]
    pub fn start(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rtc_max: u32,
        reserved10: u32,
        start: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let rtc_max: u32 = unsafe { ::std::mem::transmute(rtc_max) };
            rtc_max as u64
        });
        __bindgen_bitfield_unit.set(10usize, 21u8, {
            let reserved10: u32 = unsafe { ::std::mem::transmute(reserved10) };
            reserved10 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let start: u32 = unsafe { ::std::mem::transmute(start) };
            start as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_gpio_dev_s__bindgen_ty_19() {
    assert_eq!(
        ::std::mem::size_of::<gpio_dev_s__bindgen_ty_19>(),
        4usize,
        concat!("Size of: ", stringify!(gpio_dev_s__bindgen_ty_19))
    );
    assert_eq!(
        ::std::mem::align_of::<gpio_dev_s__bindgen_ty_19>(),
        4usize,
        concat!("Alignment of ", stringify!(gpio_dev_s__bindgen_ty_19))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s__bindgen_ty_19>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s__bindgen_ty_19),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_20 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_20__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_20__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_gpio_dev_s__bindgen_ty_20__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<gpio_dev_s__bindgen_ty_20__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(gpio_dev_s__bindgen_ty_20__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<gpio_dev_s__bindgen_ty_20__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(gpio_dev_s__bindgen_ty_20__bindgen_ty_1)
        )
    );
}
impl gpio_dev_s__bindgen_ty_20__bindgen_ty_1 {
    #[inline]
    pub fn value_sync2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_value_sync2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved20(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_reserved20(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn rdy_real(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rdy_real(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rdy_sync2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rdy_sync2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        value_sync2: u32,
        reserved20: u32,
        rdy_real: u32,
        rdy_sync2: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let value_sync2: u32 = unsafe { ::std::mem::transmute(value_sync2) };
            value_sync2 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 10u8, {
            let reserved20: u32 = unsafe { ::std::mem::transmute(reserved20) };
            reserved20 as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let rdy_real: u32 = unsafe { ::std::mem::transmute(rdy_real) };
            rdy_real as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let rdy_sync2: u32 = unsafe { ::std::mem::transmute(rdy_sync2) };
            rdy_sync2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_gpio_dev_s__bindgen_ty_20() {
    assert_eq!(
        ::std::mem::size_of::<gpio_dev_s__bindgen_ty_20>(),
        4usize,
        concat!("Size of: ", stringify!(gpio_dev_s__bindgen_ty_20))
    );
    assert_eq!(
        ::std::mem::align_of::<gpio_dev_s__bindgen_ty_20>(),
        4usize,
        concat!("Alignment of ", stringify!(gpio_dev_s__bindgen_ty_20))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s__bindgen_ty_20>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s__bindgen_ty_20),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_21 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_21__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_21__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_gpio_dev_s__bindgen_ty_21__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<gpio_dev_s__bindgen_ty_21__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(gpio_dev_s__bindgen_ty_21__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<gpio_dev_s__bindgen_ty_21__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(gpio_dev_s__bindgen_ty_21__bindgen_ty_1)
        )
    );
}
impl gpio_dev_s__bindgen_ty_21__bindgen_ty_1 {
    #[inline]
    pub fn func_sel(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_func_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn sig_in_inv(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sig_in_inv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sig_in_sel(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sig_in_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        func_sel: u32,
        sig_in_inv: u32,
        sig_in_sel: u32,
        reserved8: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let func_sel: u32 = unsafe { ::std::mem::transmute(func_sel) };
            func_sel as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let sig_in_inv: u32 = unsafe { ::std::mem::transmute(sig_in_inv) };
            sig_in_inv as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let sig_in_sel: u32 = unsafe { ::std::mem::transmute(sig_in_sel) };
            sig_in_sel as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::std::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_gpio_dev_s__bindgen_ty_21() {
    assert_eq!(
        ::std::mem::size_of::<gpio_dev_s__bindgen_ty_21>(),
        4usize,
        concat!("Size of: ", stringify!(gpio_dev_s__bindgen_ty_21))
    );
    assert_eq!(
        ::std::mem::align_of::<gpio_dev_s__bindgen_ty_21>(),
        4usize,
        concat!("Alignment of ", stringify!(gpio_dev_s__bindgen_ty_21))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s__bindgen_ty_21>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s__bindgen_ty_21),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_22 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_22__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_22__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_gpio_dev_s__bindgen_ty_22__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<gpio_dev_s__bindgen_ty_22__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(gpio_dev_s__bindgen_ty_22__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<gpio_dev_s__bindgen_ty_22__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(gpio_dev_s__bindgen_ty_22__bindgen_ty_1)
        )
    );
}
impl gpio_dev_s__bindgen_ty_22__bindgen_ty_1 {
    #[inline]
    pub fn func_sel(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_func_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn inv_sel(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inv_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn oen_sel(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_oen_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn oen_inv_sel(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_oen_inv_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved12(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_reserved12(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        func_sel: u32,
        inv_sel: u32,
        oen_sel: u32,
        oen_inv_sel: u32,
        reserved12: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 9u8, {
            let func_sel: u32 = unsafe { ::std::mem::transmute(func_sel) };
            func_sel as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let inv_sel: u32 = unsafe { ::std::mem::transmute(inv_sel) };
            inv_sel as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let oen_sel: u32 = unsafe { ::std::mem::transmute(oen_sel) };
            oen_sel as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let oen_inv_sel: u32 = unsafe { ::std::mem::transmute(oen_inv_sel) };
            oen_inv_sel as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let reserved12: u32 = unsafe { ::std::mem::transmute(reserved12) };
            reserved12 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_gpio_dev_s__bindgen_ty_22() {
    assert_eq!(
        ::std::mem::size_of::<gpio_dev_s__bindgen_ty_22>(),
        4usize,
        concat!("Size of: ", stringify!(gpio_dev_s__bindgen_ty_22))
    );
    assert_eq!(
        ::std::mem::align_of::<gpio_dev_s__bindgen_ty_22>(),
        4usize,
        concat!("Alignment of ", stringify!(gpio_dev_s__bindgen_ty_22))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s__bindgen_ty_22>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s__bindgen_ty_22),
            "::",
            stringify!(val)
        )
    );
}
#[test]
fn bindgen_test_layout_gpio_dev_s() {
    assert_eq!(
        ::std::mem::size_of::<gpio_dev_s>(),
        1488usize,
        concat!("Size of: ", stringify!(gpio_dev_s))
    );
    assert_eq!(
        ::std::mem::align_of::<gpio_dev_s>(),
        4usize,
        concat!("Alignment of ", stringify!(gpio_dev_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s>())).bt_select as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s),
            "::",
            stringify!(bt_select)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s>())).out as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s),
            "::",
            stringify!(out)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s>())).out_w1ts as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s),
            "::",
            stringify!(out_w1ts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s>())).out_w1tc as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s),
            "::",
            stringify!(out_w1tc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s>())).out1 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s),
            "::",
            stringify!(out1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s>())).out1_w1ts as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s),
            "::",
            stringify!(out1_w1ts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s>())).out1_w1tc as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s),
            "::",
            stringify!(out1_w1tc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s>())).sdio_select as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s),
            "::",
            stringify!(sdio_select)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s>())).enable as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s>())).enable_w1ts as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s),
            "::",
            stringify!(enable_w1ts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s>())).enable_w1tc as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s),
            "::",
            stringify!(enable_w1tc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s>())).enable1 as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s),
            "::",
            stringify!(enable1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s>())).enable1_w1ts as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s),
            "::",
            stringify!(enable1_w1ts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s>())).enable1_w1tc as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s),
            "::",
            stringify!(enable1_w1tc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s>())).strap as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s),
            "::",
            stringify!(strap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s>())).in_ as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s),
            "::",
            stringify!(in_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s>())).in1 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s),
            "::",
            stringify!(in1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s>())).status as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s>())).status_w1ts as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s),
            "::",
            stringify!(status_w1ts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s>())).status_w1tc as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s),
            "::",
            stringify!(status_w1tc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s>())).status1 as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s),
            "::",
            stringify!(status1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s>())).status1_w1ts as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s),
            "::",
            stringify!(status1_w1ts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s>())).status1_w1tc as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s),
            "::",
            stringify!(status1_w1tc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s>())).reserved_5c as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s),
            "::",
            stringify!(reserved_5c)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s>())).acpu_int as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s),
            "::",
            stringify!(acpu_int)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s>())).acpu_nmi_int as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s),
            "::",
            stringify!(acpu_nmi_int)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s>())).pcpu_int as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s),
            "::",
            stringify!(pcpu_int)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s>())).pcpu_nmi_int as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s),
            "::",
            stringify!(pcpu_nmi_int)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s>())).cpusdio_int as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s),
            "::",
            stringify!(cpusdio_int)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s>())).acpu_int1 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s),
            "::",
            stringify!(acpu_int1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s>())).acpu_nmi_int1 as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s),
            "::",
            stringify!(acpu_nmi_int1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s>())).pcpu_int1 as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s),
            "::",
            stringify!(pcpu_int1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s>())).pcpu_nmi_int1 as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s),
            "::",
            stringify!(pcpu_nmi_int1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s>())).cpusdio_int1 as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s),
            "::",
            stringify!(cpusdio_int1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s>())).pin as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s),
            "::",
            stringify!(pin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s>())).cali_conf as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s),
            "::",
            stringify!(cali_conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s>())).cali_data as *const _ as usize },
        300usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s),
            "::",
            stringify!(cali_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s>())).func_in_sel_cfg as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s),
            "::",
            stringify!(func_in_sel_cfg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_dev_s>())).func_out_sel_cfg as *const _ as usize },
        1328usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev_s),
            "::",
            stringify!(func_out_sel_cfg)
        )
    );
}
pub type gpio_dev_t = gpio_dev_s;
extern "C" {
    pub static mut GPIO: gpio_dev_t;
}
extern "C" {
    pub static mut GPIO_PIN_MUX_REG: [u32; 40usize];
}
extern "C" {
    pub static mut GPIO_HOLD_MASK: [u32; 40usize];
}
pub const gpio_port_t_GPIO_PORT_0: gpio_port_t = 0;
pub const gpio_port_t_GPIO_PORT_MAX: gpio_port_t = 1;
pub type gpio_port_t = u32;
#[doc = "< Use to signal not connected to S/W"]
pub const gpio_num_t_GPIO_NUM_NC: gpio_num_t = -1;
#[doc = "< GPIO0, input and output"]
pub const gpio_num_t_GPIO_NUM_0: gpio_num_t = 0;
#[doc = "< GPIO1, input and output"]
pub const gpio_num_t_GPIO_NUM_1: gpio_num_t = 1;
#[doc = "< GPIO2, input and output"]
pub const gpio_num_t_GPIO_NUM_2: gpio_num_t = 2;
#[doc = "< GPIO3, input and output"]
pub const gpio_num_t_GPIO_NUM_3: gpio_num_t = 3;
#[doc = "< GPIO4, input and output"]
pub const gpio_num_t_GPIO_NUM_4: gpio_num_t = 4;
#[doc = "< GPIO5, input and output"]
pub const gpio_num_t_GPIO_NUM_5: gpio_num_t = 5;
#[doc = "< GPIO6, input and output"]
pub const gpio_num_t_GPIO_NUM_6: gpio_num_t = 6;
#[doc = "< GPIO7, input and output"]
pub const gpio_num_t_GPIO_NUM_7: gpio_num_t = 7;
#[doc = "< GPIO8, input and output"]
pub const gpio_num_t_GPIO_NUM_8: gpio_num_t = 8;
#[doc = "< GPIO9, input and output"]
pub const gpio_num_t_GPIO_NUM_9: gpio_num_t = 9;
#[doc = "< GPIO10, input and output"]
pub const gpio_num_t_GPIO_NUM_10: gpio_num_t = 10;
#[doc = "< GPIO11, input and output"]
pub const gpio_num_t_GPIO_NUM_11: gpio_num_t = 11;
#[doc = "< GPIO12, input and output"]
pub const gpio_num_t_GPIO_NUM_12: gpio_num_t = 12;
#[doc = "< GPIO13, input and output"]
pub const gpio_num_t_GPIO_NUM_13: gpio_num_t = 13;
#[doc = "< GPIO14, input and output"]
pub const gpio_num_t_GPIO_NUM_14: gpio_num_t = 14;
#[doc = "< GPIO15, input and output"]
pub const gpio_num_t_GPIO_NUM_15: gpio_num_t = 15;
#[doc = "< GPIO16, input and output"]
pub const gpio_num_t_GPIO_NUM_16: gpio_num_t = 16;
#[doc = "< GPIO17, input and output"]
pub const gpio_num_t_GPIO_NUM_17: gpio_num_t = 17;
#[doc = "< GPIO18, input and output"]
pub const gpio_num_t_GPIO_NUM_18: gpio_num_t = 18;
#[doc = "< GPIO19, input and output"]
pub const gpio_num_t_GPIO_NUM_19: gpio_num_t = 19;
#[doc = "< GPIO20, input and output"]
pub const gpio_num_t_GPIO_NUM_20: gpio_num_t = 20;
#[doc = "< GPIO21, input and output"]
pub const gpio_num_t_GPIO_NUM_21: gpio_num_t = 21;
#[doc = "< GPIO22, input and output"]
pub const gpio_num_t_GPIO_NUM_22: gpio_num_t = 22;
#[doc = "< GPIO23, input and output"]
pub const gpio_num_t_GPIO_NUM_23: gpio_num_t = 23;
#[doc = "< GPIO25, input and output"]
pub const gpio_num_t_GPIO_NUM_25: gpio_num_t = 25;
#[doc = "< GPIO26, input and output"]
pub const gpio_num_t_GPIO_NUM_26: gpio_num_t = 26;
#[doc = "< GPIO27, input and output"]
pub const gpio_num_t_GPIO_NUM_27: gpio_num_t = 27;
#[doc = "< GPIO28, input and output"]
pub const gpio_num_t_GPIO_NUM_28: gpio_num_t = 28;
#[doc = "< GPIO29, input and output"]
pub const gpio_num_t_GPIO_NUM_29: gpio_num_t = 29;
#[doc = "< GPIO30, input and output"]
pub const gpio_num_t_GPIO_NUM_30: gpio_num_t = 30;
#[doc = "< GPIO31, input and output"]
pub const gpio_num_t_GPIO_NUM_31: gpio_num_t = 31;
#[doc = "< GPIO32, input and output"]
pub const gpio_num_t_GPIO_NUM_32: gpio_num_t = 32;
#[doc = "< GPIO33, input and output"]
pub const gpio_num_t_GPIO_NUM_33: gpio_num_t = 33;
#[doc = "< GPIO34, input mode only"]
pub const gpio_num_t_GPIO_NUM_34: gpio_num_t = 34;
#[doc = "< GPIO35, input mode only"]
pub const gpio_num_t_GPIO_NUM_35: gpio_num_t = 35;
#[doc = "< GPIO36, input mode only"]
pub const gpio_num_t_GPIO_NUM_36: gpio_num_t = 36;
#[doc = "< GPIO37, input mode only"]
pub const gpio_num_t_GPIO_NUM_37: gpio_num_t = 37;
#[doc = "< GPIO38, input mode only"]
pub const gpio_num_t_GPIO_NUM_38: gpio_num_t = 38;
#[doc = "< GPIO39, input mode only"]
pub const gpio_num_t_GPIO_NUM_39: gpio_num_t = 39;
pub const gpio_num_t_GPIO_NUM_MAX: gpio_num_t = 40;
pub type gpio_num_t = i32;
#[doc = "< Disable GPIO interrupt"]
pub const gpio_int_type_t_GPIO_INTR_DISABLE: gpio_int_type_t = 0;
#[doc = "< GPIO interrupt type : rising edge"]
pub const gpio_int_type_t_GPIO_INTR_POSEDGE: gpio_int_type_t = 1;
#[doc = "< GPIO interrupt type : falling edge"]
pub const gpio_int_type_t_GPIO_INTR_NEGEDGE: gpio_int_type_t = 2;
#[doc = "< GPIO interrupt type : both rising and falling edge"]
pub const gpio_int_type_t_GPIO_INTR_ANYEDGE: gpio_int_type_t = 3;
#[doc = "< GPIO interrupt type : input low level trigger"]
pub const gpio_int_type_t_GPIO_INTR_LOW_LEVEL: gpio_int_type_t = 4;
#[doc = "< GPIO interrupt type : input high level trigger"]
pub const gpio_int_type_t_GPIO_INTR_HIGH_LEVEL: gpio_int_type_t = 5;
pub const gpio_int_type_t_GPIO_INTR_MAX: gpio_int_type_t = 6;
pub type gpio_int_type_t = u32;
#[doc = "< GPIO mode : disable input and output"]
pub const gpio_mode_t_GPIO_MODE_DISABLE: gpio_mode_t = 0;
#[doc = "< GPIO mode : input only"]
pub const gpio_mode_t_GPIO_MODE_INPUT: gpio_mode_t = 1;
#[doc = "< GPIO mode : output only mode"]
pub const gpio_mode_t_GPIO_MODE_OUTPUT: gpio_mode_t = 2;
#[doc = "< GPIO mode : output only with open-drain mode"]
pub const gpio_mode_t_GPIO_MODE_OUTPUT_OD: gpio_mode_t = 6;
#[doc = "< GPIO mode : output and input with open-drain mode"]
pub const gpio_mode_t_GPIO_MODE_INPUT_OUTPUT_OD: gpio_mode_t = 7;
#[doc = "< GPIO mode : output and input mode"]
pub const gpio_mode_t_GPIO_MODE_INPUT_OUTPUT: gpio_mode_t = 3;
#[doc = " @endcond"]
pub type gpio_mode_t = u32;
#[doc = "< Disable GPIO pull-up resistor"]
pub const gpio_pullup_t_GPIO_PULLUP_DISABLE: gpio_pullup_t = 0;
#[doc = "< Enable GPIO pull-up resistor"]
pub const gpio_pullup_t_GPIO_PULLUP_ENABLE: gpio_pullup_t = 1;
pub type gpio_pullup_t = u32;
#[doc = "< Disable GPIO pull-down resistor"]
pub const gpio_pulldown_t_GPIO_PULLDOWN_DISABLE: gpio_pulldown_t = 0;
#[doc = "< Enable GPIO pull-down resistor"]
pub const gpio_pulldown_t_GPIO_PULLDOWN_ENABLE: gpio_pulldown_t = 1;
pub type gpio_pulldown_t = u32;
#[doc = " @brief Configuration parameters of GPIO pad for gpio_config function"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gpio_config_t {
    #[doc = "< GPIO pin: set with bit mask, each bit maps to a GPIO"]
    pub pin_bit_mask: u64,
    #[doc = "< GPIO mode: set input/output mode"]
    pub mode: gpio_mode_t,
    #[doc = "< GPIO pull-up"]
    pub pull_up_en: gpio_pullup_t,
    #[doc = "< GPIO pull-down"]
    pub pull_down_en: gpio_pulldown_t,
    #[doc = "< GPIO interrupt type"]
    pub intr_type: gpio_int_type_t,
}
#[test]
fn bindgen_test_layout_gpio_config_t() {
    assert_eq!(
        ::std::mem::size_of::<gpio_config_t>(),
        24usize,
        concat!("Size of: ", stringify!(gpio_config_t))
    );
    assert_eq!(
        ::std::mem::align_of::<gpio_config_t>(),
        8usize,
        concat!("Alignment of ", stringify!(gpio_config_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_config_t>())).pin_bit_mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_config_t),
            "::",
            stringify!(pin_bit_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_config_t>())).mode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_config_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_config_t>())).pull_up_en as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_config_t),
            "::",
            stringify!(pull_up_en)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_config_t>())).pull_down_en as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_config_t),
            "::",
            stringify!(pull_down_en)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpio_config_t>())).intr_type as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_config_t),
            "::",
            stringify!(intr_type)
        )
    );
}
#[doc = "< Pad pull up"]
pub const gpio_pull_mode_t_GPIO_PULLUP_ONLY: gpio_pull_mode_t = 0;
#[doc = "< Pad pull down"]
pub const gpio_pull_mode_t_GPIO_PULLDOWN_ONLY: gpio_pull_mode_t = 1;
#[doc = "< Pad pull up + pull down"]
pub const gpio_pull_mode_t_GPIO_PULLUP_PULLDOWN: gpio_pull_mode_t = 2;
#[doc = "< Pad floating"]
pub const gpio_pull_mode_t_GPIO_FLOATING: gpio_pull_mode_t = 3;
pub type gpio_pull_mode_t = u32;
#[doc = "< Pad drive capability: weak"]
pub const gpio_drive_cap_t_GPIO_DRIVE_CAP_0: gpio_drive_cap_t = 0;
#[doc = "< Pad drive capability: stronger"]
pub const gpio_drive_cap_t_GPIO_DRIVE_CAP_1: gpio_drive_cap_t = 1;
#[doc = "< Pad drive capability: medium"]
pub const gpio_drive_cap_t_GPIO_DRIVE_CAP_2: gpio_drive_cap_t = 2;
#[doc = "< Pad drive capability: medium"]
pub const gpio_drive_cap_t_GPIO_DRIVE_CAP_DEFAULT: gpio_drive_cap_t = 2;
#[doc = "< Pad drive capability: strongest"]
pub const gpio_drive_cap_t_GPIO_DRIVE_CAP_3: gpio_drive_cap_t = 3;
pub const gpio_drive_cap_t_GPIO_DRIVE_CAP_MAX: gpio_drive_cap_t = 4;
pub type gpio_drive_cap_t = u32;
pub type gpio_isr_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
pub const GPIO_INT_TYPE_GPIO_PIN_INTR_DISABLE: GPIO_INT_TYPE = 0;
pub const GPIO_INT_TYPE_GPIO_PIN_INTR_POSEDGE: GPIO_INT_TYPE = 1;
pub const GPIO_INT_TYPE_GPIO_PIN_INTR_NEGEDGE: GPIO_INT_TYPE = 2;
pub const GPIO_INT_TYPE_GPIO_PIN_INTR_ANYEDGE: GPIO_INT_TYPE = 3;
pub const GPIO_INT_TYPE_GPIO_PIN_INTR_LOLEVEL: GPIO_INT_TYPE = 4;
pub const GPIO_INT_TYPE_GPIO_PIN_INTR_HILEVEL: GPIO_INT_TYPE = 5;
pub type GPIO_INT_TYPE = u32;
pub type gpio_intr_handler_fn_t = ::std::option::Option<
    unsafe extern "C" fn(intr_mask: u32, high: bool, arg: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " @brief Initialize GPIO. This includes reading the GPIO Configuration DataSet"]
    #[doc = "        to initialize \"output enables\" and pin configurations for each gpio pin."]
    #[doc = "        Please do not call this function in SDK."]
    #[doc = ""]
    #[doc = " @param  None"]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn gpio_init();
}
extern "C" {
    #[doc = " @brief Change GPIO(0-31) pin output by setting, clearing, or disabling pins, GPIO0<->BIT(0)."]
    #[doc = "         There is no particular ordering guaranteed; so if the order of writes is significant,"]
    #[doc = "         calling code should divide a single call into multiple calls."]
    #[doc = ""]
    #[doc = " @param  uint32_t set_mask : the gpios that need high level."]
    #[doc = ""]
    #[doc = " @param  uint32_t clear_mask : the gpios that need low level."]
    #[doc = ""]
    #[doc = " @param  uint32_t enable_mask : the gpios that need be changed."]
    #[doc = ""]
    #[doc = " @param  uint32_t disable_mask : the gpios that need diable output."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn gpio_output_set(set_mask: u32, clear_mask: u32, enable_mask: u32, disable_mask: u32);
}
extern "C" {
    #[doc = " @brief Change GPIO(32-39) pin output by setting, clearing, or disabling pins, GPIO32<->BIT(0)."]
    #[doc = "         There is no particular ordering guaranteed; so if the order of writes is significant,"]
    #[doc = "         calling code should divide a single call into multiple calls."]
    #[doc = ""]
    #[doc = " @param  uint32_t set_mask : the gpios that need high level."]
    #[doc = ""]
    #[doc = " @param  uint32_t clear_mask : the gpios that need low level."]
    #[doc = ""]
    #[doc = " @param  uint32_t enable_mask : the gpios that need be changed."]
    #[doc = ""]
    #[doc = " @param  uint32_t disable_mask : the gpios that need diable output."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn gpio_output_set_high(
        set_mask: u32,
        clear_mask: u32,
        enable_mask: u32,
        disable_mask: u32,
    );
}
extern "C" {
    #[doc = " @brief Sample the value of GPIO input pins(0-31) and returns a bitmask."]
    #[doc = ""]
    #[doc = " @param None"]
    #[doc = ""]
    #[doc = " @return uint32_t : bitmask for GPIO input pins, BIT(0) for GPIO0."]
    pub fn gpio_input_get() -> u32;
}
extern "C" {
    #[doc = " @brief Sample the value of GPIO input pins(32-39) and returns a bitmask."]
    #[doc = ""]
    #[doc = " @param None"]
    #[doc = ""]
    #[doc = " @return uint32_t : bitmask for GPIO input pins, BIT(0) for GPIO32."]
    pub fn gpio_input_get_high() -> u32;
}
extern "C" {
    #[doc = " @brief Register an application-specific interrupt handler for GPIO pin interrupts."]
    #[doc = "        Once the interrupt handler is called, it will not be called again until after a call to gpio_intr_ack."]
    #[doc = "        Please do not call this function in SDK."]
    #[doc = ""]
    #[doc = " @param gpio_intr_handler_fn_t fn : gpio application-specific interrupt handler"]
    #[doc = ""]
    #[doc = " @param void *arg : gpio application-specific interrupt handler argument."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn gpio_intr_handler_register(
        fn_: gpio_intr_handler_fn_t,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " @brief Get gpio interrupts which happens but not processed."]
    #[doc = "        Please do not call this function in SDK."]
    #[doc = ""]
    #[doc = " @param None"]
    #[doc = ""]
    #[doc = " @return uint32_t : bitmask for GPIO pending interrupts, BIT(0) for GPIO0."]
    pub fn gpio_intr_pending() -> u32;
}
extern "C" {
    #[doc = " @brief Get gpio interrupts which happens but not processed."]
    #[doc = "        Please do not call this function in SDK."]
    #[doc = ""]
    #[doc = " @param None"]
    #[doc = ""]
    #[doc = " @return uint32_t : bitmask for GPIO pending interrupts, BIT(0) for GPIO32."]
    pub fn gpio_intr_pending_high() -> u32;
}
extern "C" {
    #[doc = " @brief Ack gpio interrupts to process pending interrupts."]
    #[doc = "        Please do not call this function in SDK."]
    #[doc = ""]
    #[doc = " @param uint32_t ack_mask: bitmask for GPIO ack interrupts, BIT(0) for GPIO0."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn gpio_intr_ack(ack_mask: u32);
}
extern "C" {
    #[doc = " @brief Ack gpio interrupts to process pending interrupts."]
    #[doc = "        Please do not call this function in SDK."]
    #[doc = ""]
    #[doc = " @param uint32_t ack_mask: bitmask for GPIO ack interrupts, BIT(0) for GPIO32."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn gpio_intr_ack_high(ack_mask: u32);
}
extern "C" {
    #[doc = " @brief Set GPIO to wakeup the ESP32."]
    #[doc = "        Please do not call this function in SDK."]
    #[doc = ""]
    #[doc = " @param uint32_t i: gpio number."]
    #[doc = ""]
    #[doc = " @param GPIO_INT_TYPE intr_state : only GPIO_PIN_INTR_LOLEVEL\\GPIO_PIN_INTR_HILEVEL can be used"]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn gpio_pin_wakeup_enable(i: u32, intr_state: GPIO_INT_TYPE);
}
extern "C" {
    #[doc = " @brief disable GPIOs to wakeup the ESP32."]
    #[doc = "        Please do not call this function in SDK."]
    #[doc = ""]
    #[doc = " @param None"]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn gpio_pin_wakeup_disable();
}
extern "C" {
    #[doc = " @brief set gpio input to a signal, one gpio can input to several signals."]
    #[doc = ""]
    #[doc = " @param uint32_t gpio : gpio number, 0~0x27"]
    #[doc = "                        gpio == 0x30, input 0 to signal"]
    #[doc = "                        gpio == 0x34, ???"]
    #[doc = "                        gpio == 0x38, input 1 to signal"]
    #[doc = ""]
    #[doc = " @param uint32_t signal_idx : signal index."]
    #[doc = ""]
    #[doc = " @param bool inv : the signal is inv or not"]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn gpio_matrix_in(gpio: u32, signal_idx: u32, inv: bool);
}
extern "C" {
    #[doc = " @brief set signal output to gpio, one signal can output to several gpios."]
    #[doc = ""]
    #[doc = " @param uint32_t gpio : gpio number, 0~0x27"]
    #[doc = ""]
    #[doc = " @param uint32_t signal_idx : signal index."]
    #[doc = "                        signal_idx == 0x100, cancel output put to the gpio"]
    #[doc = ""]
    #[doc = " @param bool out_inv : the signal output is inv or not"]
    #[doc = ""]
    #[doc = " @param bool oen_inv : the signal output enable is inv or not"]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn gpio_matrix_out(gpio: u32, signal_idx: u32, out_inv: bool, oen_inv: bool);
}
extern "C" {
    #[doc = " @brief Select pad as a gpio function from IOMUX."]
    #[doc = ""]
    #[doc = " @param uint32_t gpio_num : gpio number, 0~0x27"]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn gpio_pad_select_gpio(gpio_num: u8);
}
extern "C" {
    #[doc = " @brief Set pad driver capability."]
    #[doc = ""]
    #[doc = " @param uint32_t gpio_num : gpio number, 0~0x27"]
    #[doc = ""]
    #[doc = " @param uint8_t drv : 0-3"]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn gpio_pad_set_drv(gpio_num: u8, drv: u8);
}
extern "C" {
    #[doc = " @brief Pull up the pad from gpio number."]
    #[doc = ""]
    #[doc = " @param uint32_t gpio_num : gpio number, 0~0x27"]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn gpio_pad_pullup(gpio_num: u8);
}
extern "C" {
    #[doc = " @brief Pull down the pad from gpio number."]
    #[doc = ""]
    #[doc = " @param uint32_t gpio_num : gpio number, 0~0x27"]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn gpio_pad_pulldown(gpio_num: u8);
}
extern "C" {
    #[doc = " @brief Unhold the pad from gpio number."]
    #[doc = ""]
    #[doc = " @param uint32_t gpio_num : gpio number, 0~0x27"]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn gpio_pad_unhold(gpio_num: u8);
}
extern "C" {
    #[doc = " @brief Hold the pad from gpio number."]
    #[doc = ""]
    #[doc = " @param uint32_t gpio_num : gpio number, 0~0x27"]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn gpio_pad_hold(gpio_num: u8);
}
pub type gpio_isr_handle_t = intr_handle_t;
extern "C" {
    #[doc = " @brief GPIO common configuration"]
    #[doc = ""]
    #[doc = "        Configure GPIO's Mode,pull-up,PullDown,IntrType"]
    #[doc = ""]
    #[doc = " @param  pGPIOConfig Pointer to GPIO configure struct"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = ""]
    pub fn gpio_config(pGPIOConfig: *const gpio_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Reset an gpio to default state (select gpio function, enable pullup and disable input and output)."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number."]
    #[doc = ""]
    #[doc = " @note This function also configures the IOMUX for this pin to the GPIO"]
    #[doc = "       function, and disconnects any other peripheral output configured via GPIO"]
    #[doc = "       Matrix."]
    #[doc = ""]
    #[doc = " @return Always return ESP_OK."]
    pub fn gpio_reset_pin(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  GPIO set interrupt trigger type"]
    #[doc = ""]
    #[doc = " @param  gpio_num GPIO number. If you want to set the trigger type of e.g. of GPIO16, gpio_num should be GPIO_NUM_16 (16);"]
    #[doc = " @param  intr_type Interrupt type, select from gpio_int_type_t"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK  Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = ""]
    pub fn gpio_set_intr_type(gpio_num: gpio_num_t, intr_type: gpio_int_type_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Enable GPIO module interrupt signal"]
    #[doc = ""]
    #[doc = " @note Please do not use the interrupt of GPIO36 and GPIO39 when using ADC or Wi-Fi with sleep mode enabled."]
    #[doc = "       Please refer to the comments of `adc1_get_raw`."]
    #[doc = "       Please refer to section 3.11 of 'ECO_and_Workarounds_for_Bugs_in_ESP32' for the description of this issue."]
    #[doc = "       As a workaround, call adc_power_acquire() in the app. This will result in higher power consumption (by ~1mA),"]
    #[doc = "       but will remove the glitches on GPIO36 and GPIO39."]
    #[doc = ""]
    #[doc = " @param  gpio_num GPIO number. If you want to enable an interrupt on e.g. GPIO16, gpio_num should be GPIO_NUM_16 (16);"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = ""]
    pub fn gpio_intr_enable(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Disable GPIO module interrupt signal"]
    #[doc = ""]
    #[doc = " @param  gpio_num GPIO number. If you want to disable the interrupt of e.g. GPIO16, gpio_num should be GPIO_NUM_16 (16);"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = ""]
    pub fn gpio_intr_disable(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  GPIO set output level"]
    #[doc = ""]
    #[doc = " @param  gpio_num GPIO number. If you want to set the output level of e.g. GPIO16, gpio_num should be GPIO_NUM_16 (16);"]
    #[doc = " @param  level Output level. 0: low ; 1: high"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG GPIO number error"]
    #[doc = ""]
    pub fn gpio_set_level(gpio_num: gpio_num_t, level: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  GPIO get input level"]
    #[doc = ""]
    #[doc = " @warning If the pad is not configured for input (or input and output) the returned value is always 0."]
    #[doc = ""]
    #[doc = " @param  gpio_num GPIO number. If you want to get the logic level of e.g. pin GPIO16, gpio_num should be GPIO_NUM_16 (16);"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - 0 the GPIO input level is 0"]
    #[doc = "     - 1 the GPIO input level is 1"]
    #[doc = ""]
    pub fn gpio_get_level(gpio_num: gpio_num_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief\t GPIO set direction"]
    #[doc = ""]
    #[doc = " Configure GPIO direction,such as output_only,input_only,output_and_input"]
    #[doc = ""]
    #[doc = " @param  gpio_num  Configure GPIO pins number, it should be GPIO number. If you want to set direction of e.g. GPIO16, gpio_num should be GPIO_NUM_16 (16);"]
    #[doc = " @param  mode GPIO direction"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG GPIO error"]
    #[doc = ""]
    pub fn gpio_set_direction(gpio_num: gpio_num_t, mode: gpio_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Configure GPIO pull-up/pull-down resistors"]
    #[doc = ""]
    #[doc = " Only pins that support both input & output have integrated pull-up and pull-down resistors. Input-only GPIOs 34-39 do not."]
    #[doc = ""]
    #[doc = " @param  gpio_num GPIO number. If you want to set pull up or down mode for e.g. GPIO16, gpio_num should be GPIO_NUM_16 (16);"]
    #[doc = " @param  pull GPIO pull up/down mode."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG : Parameter error"]
    #[doc = ""]
    pub fn gpio_set_pull_mode(gpio_num: gpio_num_t, pull: gpio_pull_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable GPIO wake-up function."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number."]
    #[doc = ""]
    #[doc = " @param intr_type GPIO wake-up type. Only GPIO_INTR_LOW_LEVEL or GPIO_INTR_HIGH_LEVEL can be used."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_wakeup_enable(gpio_num: gpio_num_t, intr_type: gpio_int_type_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable GPIO wake-up function."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_wakeup_disable(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Register GPIO interrupt handler, the handler is an ISR."]
    #[doc = "          The handler will be attached to the same CPU core that this function is running on."]
    #[doc = ""]
    #[doc = " This ISR function is called whenever any GPIO interrupt occurs. See"]
    #[doc = " the alternative gpio_install_isr_service() and"]
    #[doc = " gpio_isr_handler_add() API in order to have the driver support"]
    #[doc = " per-GPIO ISRs."]
    #[doc = ""]
    #[doc = " @param  fn  Interrupt handler function."]
    #[doc = " @param  intr_alloc_flags Flags used to allocate the interrupt. One or multiple (ORred)"]
    #[doc = "            ESP_INTR_FLAG_* values. See esp_intr_alloc.h for more info."]
    #[doc = " @param  arg  Parameter for handler function"]
    #[doc = " @param  handle Pointer to return handle. If non-NULL, a handle for the interrupt will be returned here."]
    #[doc = ""]
    #[doc = " \\verbatim embed:rst:leading-asterisk"]
    #[doc = " To disable or remove the ISR, pass the returned handle to the :doc:`interrupt allocation functions </api-reference/system/intr_alloc>`."]
    #[doc = " \\endverbatim"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success ;"]
    #[doc = "     - ESP_ERR_INVALID_ARG GPIO error"]
    #[doc = "     - ESP_ERR_NOT_FOUND No free interrupt found with the specified flags"]
    pub fn gpio_isr_register(
        fn_: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        arg: *mut ::std::os::raw::c_void,
        intr_alloc_flags: ::std::os::raw::c_int,
        handle: *mut gpio_isr_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable pull-up on GPIO."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_pullup_en(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable pull-up on GPIO."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_pullup_dis(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable pull-down on GPIO."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_pulldown_en(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable pull-down on GPIO."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_pulldown_dis(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Install the driver's GPIO ISR handler service, which allows per-pin GPIO interrupt handlers."]
    #[doc = ""]
    #[doc = " This function is incompatible with gpio_isr_register() - if that function is used, a single global ISR is registered for all GPIO interrupts. If this function is used, the ISR service provides a global GPIO ISR and individual pin handlers are registered via the gpio_isr_handler_add() function."]
    #[doc = ""]
    #[doc = " @param intr_alloc_flags Flags used to allocate the interrupt. One or multiple (ORred)"]
    #[doc = "            ESP_INTR_FLAG_* values. See esp_intr_alloc.h for more info."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_NO_MEM No memory to install this service"]
    #[doc = "     - ESP_ERR_INVALID_STATE ISR service already installed."]
    #[doc = "     - ESP_ERR_NOT_FOUND No free interrupt found with the specified flags"]
    #[doc = "     - ESP_ERR_INVALID_ARG GPIO error"]
    pub fn gpio_install_isr_service(intr_alloc_flags: ::std::os::raw::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Uninstall the driver's GPIO ISR service, freeing related resources."]
    pub fn gpio_uninstall_isr_service();
}
extern "C" {
    #[doc = " @brief Add ISR handler for the corresponding GPIO pin."]
    #[doc = ""]
    #[doc = " Call this function after using gpio_install_isr_service() to"]
    #[doc = " install the driver's GPIO ISR handler service."]
    #[doc = ""]
    #[doc = " The pin ISR handlers no longer need to be declared with IRAM_ATTR,"]
    #[doc = " unless you pass the ESP_INTR_FLAG_IRAM flag when allocating the"]
    #[doc = " ISR in gpio_install_isr_service()."]
    #[doc = ""]
    #[doc = " This ISR handler will be called from an ISR. So there is a stack"]
    #[doc = " size limit (configurable as \"ISR stack size\" in menuconfig). This"]
    #[doc = " limit is smaller compared to a global GPIO interrupt handler due"]
    #[doc = " to the additional level of indirection."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number"]
    #[doc = " @param isr_handler ISR handler function for the corresponding GPIO number."]
    #[doc = " @param args parameter for ISR handler."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_STATE Wrong state, the ISR service has not been initialized."]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_isr_handler_add(
        gpio_num: gpio_num_t,
        isr_handler: gpio_isr_t,
        args: *mut ::std::os::raw::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Remove ISR handler for the corresponding GPIO pin."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_STATE Wrong state, the ISR service has not been initialized."]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_isr_handler_remove(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set GPIO pad drive capability"]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number, only support output GPIOs"]
    #[doc = " @param strength Drive capability of the pad"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_set_drive_capability(gpio_num: gpio_num_t, strength: gpio_drive_cap_t)
        -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get GPIO pad drive capability"]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number, only support output GPIOs"]
    #[doc = " @param strength Pointer to accept drive capability of the pad"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_get_drive_capability(
        gpio_num: gpio_num_t,
        strength: *mut gpio_drive_cap_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable gpio pad hold function."]
    #[doc = ""]
    #[doc = " The gpio pad hold function works in both input and output modes, but must be output-capable gpios."]
    #[doc = " If pad hold enabled:"]
    #[doc = "   in output mode: the output level of the pad will be force locked and can not be changed."]
    #[doc = "   in input mode: the input value read will not change, regardless the changes of input signal."]
    #[doc = ""]
    #[doc = " The state of digital gpio cannot be held during Deep-sleep, and it will resume the hold function"]
    #[doc = " when the chip wakes up from Deep-sleep. If the digital gpio also needs to be held during Deep-sleep,"]
    #[doc = " `gpio_deep_sleep_hold_en` should also be called."]
    #[doc = ""]
    #[doc = " Power down or call gpio_hold_dis will disable this function."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number, only support output-capable GPIOs"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_NOT_SUPPORTED Not support pad hold function"]
    pub fn gpio_hold_en(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable gpio pad hold function."]
    #[doc = ""]
    #[doc = " When the chip is woken up from Deep-sleep, the gpio will be set to the default mode, so, the gpio will output"]
    #[doc = " the default level if this function is called. If you don't want the level changes, the gpio should be configured to"]
    #[doc = " a known state before this function is called."]
    #[doc = "  e.g."]
    #[doc = "     If you hold gpio18 high during Deep-sleep, after the chip is woken up and `gpio_hold_dis` is called,"]
    #[doc = "     gpio18 will output low level(because gpio18 is input mode by default). If you don't want this behavior,"]
    #[doc = "     you should configure gpio18 as output mode and set it to hight level before calling `gpio_hold_dis`."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number, only support output-capable GPIOs"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_NOT_SUPPORTED Not support pad hold function"]
    pub fn gpio_hold_dis(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable all digital gpio pad hold function during Deep-sleep."]
    #[doc = ""]
    #[doc = " When the chip is in Deep-sleep mode, all digital gpio will hold the state before sleep, and when the chip is woken up,"]
    #[doc = " the status of digital gpio will not be held. Note that the pad hold feature only works when the chip is in Deep-sleep mode,"]
    #[doc = " when not in sleep mode, the digital gpio state can be changed even you have called this function."]
    #[doc = ""]
    #[doc = " Power down or call gpio_hold_dis will disable this function, otherwise, the digital gpio hold feature works as long as the chip enter Deep-sleep."]
    pub fn gpio_deep_sleep_hold_en();
}
extern "C" {
    #[doc = " @brief Disable all digital gpio pad hold function during Deep-sleep."]
    #[doc = ""]
    pub fn gpio_deep_sleep_hold_dis();
}
extern "C" {
    #[doc = " @brief Set pad input to a peripheral signal through the IOMUX."]
    #[doc = " @param gpio_num GPIO number of the pad."]
    #[doc = " @param signal_idx Peripheral signal id to input. One of the ``*_IN_IDX`` signals in ``soc/gpio_sig_map.h``."]
    pub fn gpio_iomux_in(gpio_num: u32, signal_idx: u32);
}
extern "C" {
    #[doc = " @brief Set peripheral output to an GPIO pad through the IOMUX."]
    #[doc = " @param gpio_num gpio_num GPIO number of the pad."]
    #[doc = " @param func The function number of the peripheral pin to output pin."]
    #[doc = "        One of the ``FUNC_X_*`` of specified pin (X) in ``soc/io_mux_reg.h``."]
    #[doc = " @param oen_inv True if the output enable needs to be inverted, otherwise False."]
    pub fn gpio_iomux_out(gpio_num: u8, func: ::std::os::raw::c_int, oen_inv: bool);
}
extern "C" {
    #[doc = " @brief Enable SLP_SEL to change GPIO status automantically in lightsleep."]
    #[doc = " @param gpio_num GPIO number of the pad."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = ""]
    pub fn gpio_sleep_sel_en(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable SLP_SEL to change GPIO status automantically in lightsleep."]
    #[doc = " @param gpio_num GPIO number of the pad."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    pub fn gpio_sleep_sel_dis(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief\t GPIO set direction at sleep"]
    #[doc = ""]
    #[doc = " Configure GPIO direction,such as output_only,input_only,output_and_input"]
    #[doc = ""]
    #[doc = " @param  gpio_num  Configure GPIO pins number, it should be GPIO number. If you want to set direction of e.g. GPIO16, gpio_num should be GPIO_NUM_16 (16);"]
    #[doc = " @param  mode GPIO direction"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG GPIO error"]
    pub fn gpio_sleep_set_direction(gpio_num: gpio_num_t, mode: gpio_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Configure GPIO pull-up/pull-down resistors at sleep"]
    #[doc = ""]
    #[doc = " Only pins that support both input & output have integrated pull-up and pull-down resistors. Input-only GPIOs 34-39 do not."]
    #[doc = ""]
    #[doc = " @param  gpio_num GPIO number. If you want to set pull up or down mode for e.g. GPIO16, gpio_num should be GPIO_NUM_16 (16);"]
    #[doc = " @param  pull GPIO pull up/down mode."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG : Parameter error"]
    pub fn gpio_sleep_set_pull_mode(gpio_num: gpio_num_t, pull: gpio_pull_mode_t) -> esp_err_t;
}
pub const periph_module_t_PERIPH_LEDC_MODULE: periph_module_t = 0;
pub const periph_module_t_PERIPH_UART0_MODULE: periph_module_t = 1;
pub const periph_module_t_PERIPH_UART1_MODULE: periph_module_t = 2;
pub const periph_module_t_PERIPH_UART2_MODULE: periph_module_t = 3;
pub const periph_module_t_PERIPH_I2C0_MODULE: periph_module_t = 4;
pub const periph_module_t_PERIPH_I2C1_MODULE: periph_module_t = 5;
pub const periph_module_t_PERIPH_I2S0_MODULE: periph_module_t = 6;
pub const periph_module_t_PERIPH_I2S1_MODULE: periph_module_t = 7;
pub const periph_module_t_PERIPH_TIMG0_MODULE: periph_module_t = 8;
pub const periph_module_t_PERIPH_TIMG1_MODULE: periph_module_t = 9;
pub const periph_module_t_PERIPH_PWM0_MODULE: periph_module_t = 10;
pub const periph_module_t_PERIPH_PWM1_MODULE: periph_module_t = 11;
pub const periph_module_t_PERIPH_PWM2_MODULE: periph_module_t = 12;
pub const periph_module_t_PERIPH_PWM3_MODULE: periph_module_t = 13;
pub const periph_module_t_PERIPH_UHCI0_MODULE: periph_module_t = 14;
pub const periph_module_t_PERIPH_UHCI1_MODULE: periph_module_t = 15;
pub const periph_module_t_PERIPH_RMT_MODULE: periph_module_t = 16;
pub const periph_module_t_PERIPH_PCNT_MODULE: periph_module_t = 17;
pub const periph_module_t_PERIPH_SPI_MODULE: periph_module_t = 18;
pub const periph_module_t_PERIPH_HSPI_MODULE: periph_module_t = 19;
pub const periph_module_t_PERIPH_VSPI_MODULE: periph_module_t = 20;
pub const periph_module_t_PERIPH_SPI_DMA_MODULE: periph_module_t = 21;
pub const periph_module_t_PERIPH_SDMMC_MODULE: periph_module_t = 22;
pub const periph_module_t_PERIPH_SDIO_SLAVE_MODULE: periph_module_t = 23;
pub const periph_module_t_PERIPH_TWAI_MODULE: periph_module_t = 24;
pub const periph_module_t_PERIPH_CAN_MODULE: periph_module_t = 24;
pub const periph_module_t_PERIPH_EMAC_MODULE: periph_module_t = 25;
pub const periph_module_t_PERIPH_RNG_MODULE: periph_module_t = 26;
pub const periph_module_t_PERIPH_WIFI_MODULE: periph_module_t = 27;
pub const periph_module_t_PERIPH_BT_MODULE: periph_module_t = 28;
pub const periph_module_t_PERIPH_WIFI_BT_COMMON_MODULE: periph_module_t = 29;
pub const periph_module_t_PERIPH_BT_BASEBAND_MODULE: periph_module_t = 30;
pub const periph_module_t_PERIPH_BT_LC_MODULE: periph_module_t = 31;
pub const periph_module_t_PERIPH_AES_MODULE: periph_module_t = 32;
pub const periph_module_t_PERIPH_SHA_MODULE: periph_module_t = 33;
pub const periph_module_t_PERIPH_RSA_MODULE: periph_module_t = 34;
pub const periph_module_t_PERIPH_MODULE_MAX: periph_module_t = 35;
pub type periph_module_t = u32;
extern "C" {
    #[doc = " @brief      enable peripheral module"]
    #[doc = ""]
    #[doc = " @param[in]  periph    :  Peripheral module name"]
    #[doc = ""]
    #[doc = " Clock for the module will be ungated, and reset de-asserted."]
    #[doc = ""]
    #[doc = " @note If periph_module_enable is called a number of times,"]
    #[doc = "       periph_module_disable has to be called the same number of times"]
    #[doc = "       in order to put the peripheral into disabled state."]
    #[doc = ""]
    #[doc = " @return     NULL"]
    #[doc = ""]
    pub fn periph_module_enable(periph: periph_module_t);
}
extern "C" {
    #[doc = " @brief      disable peripheral module"]
    #[doc = ""]
    #[doc = " @param[in]  periph    :  Peripheral module name"]
    #[doc = ""]
    #[doc = " Clock for the module will be gated, reset asserted."]
    #[doc = ""]
    #[doc = " @note If periph_module_enable is called a number of times,"]
    #[doc = "       periph_module_disable has to be called the same number of times"]
    #[doc = "       in order to put the peripheral into disabled state."]
    #[doc = ""]
    #[doc = " @return     NULL"]
    #[doc = ""]
    pub fn periph_module_disable(periph: periph_module_t);
}
extern "C" {
    #[doc = " @brief      reset peripheral module"]
    #[doc = ""]
    #[doc = " @param[in]  periph    :  Peripheral module name"]
    #[doc = ""]
    #[doc = " Reset will asserted then de-assrted for the peripheral."]
    #[doc = ""]
    #[doc = " Calling this function does not enable or disable the clock for the module."]
    #[doc = ""]
    #[doc = " @return     NULL"]
    #[doc = ""]
    pub fn periph_module_reset(periph: periph_module_t);
}
extern "C" {
    #[doc = " @brief      enable wifi bt common module"]
    #[doc = ""]
    #[doc = " @note If wifi_bt_common_module_enable is called a number of times,"]
    #[doc = "       wifi_bt_common_module_disable has to be called the same number of times"]
    #[doc = "       in order to put the peripheral into disabled state."]
    #[doc = ""]
    #[doc = " @return     NULL"]
    #[doc = ""]
    pub fn wifi_bt_common_module_enable();
}
extern "C" {
    #[doc = " @brief      disable wifi bt common module"]
    #[doc = ""]
    #[doc = " @note If wifi_bt_common_module_enable is called a number of times,"]
    #[doc = "       wifi_bt_common_module_disable has to be called the same number of times"]
    #[doc = "       in order to put the peripheral into disabled state."]
    #[doc = ""]
    #[doc = " @return     NULL"]
    #[doc = ""]
    pub fn wifi_bt_common_module_disable();
}
extern "C" {
    #[doc = " @brief      enable wifi module"]
    #[doc = ""]
    #[doc = " @note Enable wifi module only."]
    #[doc = ""]
    #[doc = " @return     NULL"]
    #[doc = ""]
    pub fn wifi_module_enable();
}
extern "C" {
    #[doc = " @brief      disable wifi module"]
    #[doc = ""]
    #[doc = " @note Disable wifi module only."]
    #[doc = ""]
    #[doc = " @return     NULL"]
    #[doc = ""]
    pub fn wifi_module_disable();
}
pub type ledc_isr_handle_t = intr_handle_t;
extern "C" {
    #[doc = " @brief LEDC channel configuration"]
    #[doc = "        Configure LEDC channel with the given channel/output gpio_num/interrupt/source timer/frequency(Hz)/LEDC duty resolution"]
    #[doc = ""]
    #[doc = " @param ledc_conf Pointer of LEDC channel configure struct"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn ledc_channel_config(ledc_conf: *const ledc_channel_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief LEDC timer configuration"]
    #[doc = "        Configure LEDC timer with the given source timer/frequency(Hz)/duty_resolution"]
    #[doc = ""]
    #[doc = " @param  timer_conf Pointer of LEDC timer configure struct"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_FAIL Can not find a proper pre-divider number base on the given frequency and the current duty_resolution."]
    pub fn ledc_timer_config(timer_conf: *const ledc_timer_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief LEDC update channel parameters"]
    #[doc = " @note  Call this function to activate the LEDC updated parameters."]
    #[doc = "        After ledc_set_duty, we need to call this function to update the settings."]
    #[doc = " @note  ledc_set_duty, ledc_set_duty_with_hpoint and ledc_update_duty are not thread-safe, do not call these functions to"]
    #[doc = "        control one LEDC channel in different tasks at the same time."]
    #[doc = "        A thread-safe version of API is ledc_set_duty_and_update"]
    #[doc = " @param speed_mode Select the LEDC channel group with specified speed mode. Note that not all targets support high speed mode."]
    #[doc = " @param channel LEDC channel (0-7), select from ledc_channel_t"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = ""]
    pub fn ledc_update_duty(speed_mode: ledc_mode_t, channel: ledc_channel_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set LEDC output gpio."]
    #[doc = ""]
    #[doc = " @param  gpio_num The LEDC output gpio"]
    #[doc = " @param  speed_mode Select the LEDC channel group with specified speed mode. Note that not all targets support high speed mode."]
    #[doc = " @param  ledc_channel LEDC channel (0-7), select from ledc_channel_t"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn ledc_set_pin(
        gpio_num: ::std::os::raw::c_int,
        speed_mode: ledc_mode_t,
        ledc_channel: ledc_channel_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief LEDC stop."]
    #[doc = "        Disable LEDC output, and set idle level"]
    #[doc = ""]
    #[doc = " @param  speed_mode Select the LEDC channel group with specified speed mode. Note that not all targets support high speed mode."]
    #[doc = " @param  channel LEDC channel (0-7), select from ledc_channel_t"]
    #[doc = " @param  idle_level Set output idle level after LEDC stops."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn ledc_stop(
        speed_mode: ledc_mode_t,
        channel: ledc_channel_t,
        idle_level: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief LEDC set channel frequency (Hz)"]
    #[doc = ""]
    #[doc = " @param speed_mode Select the LEDC channel group with specified speed mode. Note that not all targets support high speed mode."]
    #[doc = " @param  timer_num LEDC timer index (0-3), select from ledc_timer_t"]
    #[doc = " @param  freq_hz Set the LEDC frequency"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_FAIL Can not find a proper pre-divider number base on the given frequency and the current duty_resolution."]
    pub fn ledc_set_freq(
        speed_mode: ledc_mode_t,
        timer_num: ledc_timer_t,
        freq_hz: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      LEDC get channel frequency (Hz)"]
    #[doc = ""]
    #[doc = " @param speed_mode Select the LEDC channel group with specified speed mode. Note that not all targets support high speed mode."]
    #[doc = " @param timer_num LEDC timer index (0-3), select from ledc_timer_t"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - 0  error"]
    #[doc = "     - Others Current LEDC frequency"]
    pub fn ledc_get_freq(speed_mode: ledc_mode_t, timer_num: ledc_timer_t) -> u32;
}
extern "C" {
    #[doc = " @brief LEDC set duty and hpoint value"]
    #[doc = "        Only after calling ledc_update_duty will the duty update."]
    #[doc = " @note  ledc_set_duty, ledc_set_duty_with_hpoint and ledc_update_duty are not thread-safe, do not call these functions to"]
    #[doc = "        control one LEDC channel in different tasks at the same time."]
    #[doc = "        A thread-safe version of API is ledc_set_duty_and_update"]
    #[doc = " @note  If a fade operation is running in progress on that channel, the driver would not allow it to be stopped."]
    #[doc = "        Other duty operations will have to wait until the fade operation has finished."]
    #[doc = " @param speed_mode Select the LEDC channel group with specified speed mode. Note that not all targets support high speed mode."]
    #[doc = " @param channel LEDC channel (0-7), select from ledc_channel_t"]
    #[doc = " @param duty Set the LEDC duty, the range of duty setting is [0, (2**duty_resolution)]"]
    #[doc = " @param hpoint Set the LEDC hpoint value(max: 0xfffff)"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn ledc_set_duty_with_hpoint(
        speed_mode: ledc_mode_t,
        channel: ledc_channel_t,
        duty: u32,
        hpoint: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief LEDC get hpoint value, the counter value when the output is set high level."]
    #[doc = ""]
    #[doc = " @param speed_mode Select the LEDC channel group with specified speed mode. Note that not all targets support high speed mode."]
    #[doc = " @param channel LEDC channel (0-7), select from ledc_channel_t"]
    #[doc = " @return"]
    #[doc = "     - LEDC_ERR_VAL if parameter error"]
    #[doc = "     - Others Current hpoint value of LEDC channel"]
    pub fn ledc_get_hpoint(
        speed_mode: ledc_mode_t,
        channel: ledc_channel_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief LEDC set duty"]
    #[doc = "        This function do not change the hpoint value of this channel. if needed, please call ledc_set_duty_with_hpoint."]
    #[doc = "        only after calling ledc_update_duty will the duty update."]
    #[doc = " @note  ledc_set_duty, ledc_set_duty_with_hpoint and ledc_update_duty are not thread-safe, do not call these functions to"]
    #[doc = "        control one LEDC channel in different tasks at the same time."]
    #[doc = "        A thread-safe version of API is ledc_set_duty_and_update."]
    #[doc = " @note  If a fade operation is running in progress on that channel, the driver would not allow it to be stopped."]
    #[doc = "        Other duty operations will have to wait until the fade operation has finished."]
    #[doc = " @param speed_mode Select the LEDC channel group with specified speed mode. Note that not all targets support high speed mode."]
    #[doc = " @param channel LEDC channel (0-7), select from ledc_channel_t"]
    #[doc = " @param duty Set the LEDC duty, the range of duty setting is [0, (2**duty_resolution)]"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn ledc_set_duty(speed_mode: ledc_mode_t, channel: ledc_channel_t, duty: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief LEDC get duty"]
    #[doc = ""]
    #[doc = " @param speed_mode Select the LEDC channel group with specified speed mode. Note that not all targets support high speed mode."]
    #[doc = " @param channel LEDC channel (0-7), select from ledc_channel_t"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - LEDC_ERR_DUTY if parameter error"]
    #[doc = "     - Others Current LEDC duty"]
    pub fn ledc_get_duty(speed_mode: ledc_mode_t, channel: ledc_channel_t) -> u32;
}
extern "C" {
    #[doc = " @brief LEDC set gradient"]
    #[doc = "        Set LEDC gradient, After the function calls the ledc_update_duty function, the function can take effect."]
    #[doc = " @note  If a fade operation is running in progress on that channel, the driver would not allow it to be stopped."]
    #[doc = "        Other duty operations will have to wait until the fade operation has finished."]
    #[doc = " @param speed_mode Select the LEDC channel group with specified speed mode. Note that not all targets support high speed mode."]
    #[doc = " @param channel LEDC channel (0-7), select from ledc_channel_t"]
    #[doc = " @param duty Set the start of the gradient duty, the range of duty setting is [0, (2**duty_resolution)]"]
    #[doc = " @param fade_direction Set the direction of the gradient"]
    #[doc = " @param step_num Set the number of the gradient"]
    #[doc = " @param duty_cycle_num Set how many LEDC tick each time the gradient lasts"]
    #[doc = " @param duty_scale Set gradient change amplitude"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn ledc_set_fade(
        speed_mode: ledc_mode_t,
        channel: ledc_channel_t,
        duty: u32,
        fade_direction: ledc_duty_direction_t,
        step_num: u32,
        duty_cycle_num: u32,
        duty_scale: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Register LEDC interrupt handler, the handler is an ISR."]
    #[doc = "        The handler will be attached to the same CPU core that this function is running on."]
    #[doc = ""]
    #[doc = " @param fn Interrupt handler function."]
    #[doc = " @param arg User-supplied argument passed to the handler function."]
    #[doc = " @param intr_alloc_flags Flags used to allocate the interrupt. One or multiple (ORred)"]
    #[doc = "        ESP_INTR_FLAG_* values. See esp_intr_alloc.h for more info."]
    #[doc = " @param handle Pointer to return handle. If non-NULL, a handle for the interrupt will"]
    #[doc = "        be returned here."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Function pointer error."]
    pub fn ledc_isr_register(
        fn_: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        arg: *mut ::std::os::raw::c_void,
        intr_alloc_flags: ::std::os::raw::c_int,
        handle: *mut ledc_isr_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Configure LEDC settings"]
    #[doc = ""]
    #[doc = " @param speed_mode Select the LEDC channel group with specified speed mode. Note that not all targets support high speed mode."]
    #[doc = " @param timer_sel  Timer index (0-3), there are 4 timers in LEDC module"]
    #[doc = " @param clock_divider Timer clock divide value, the timer clock is divided from the selected clock source"]
    #[doc = " @param duty_resolution Resolution of duty setting in number of bits. The range of duty values is [0, (2**duty_resolution)]"]
    #[doc = " @param clk_src Select LEDC source clock."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - (-1) Parameter error"]
    #[doc = "     - Other Current LEDC duty"]
    pub fn ledc_timer_set(
        speed_mode: ledc_mode_t,
        timer_sel: ledc_timer_t,
        clock_divider: u32,
        duty_resolution: u32,
        clk_src: ledc_clk_src_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Reset LEDC timer"]
    #[doc = ""]
    #[doc = " @param  speed_mode Select the LEDC channel group with specified speed mode. Note that not all targets support high speed mode."]
    #[doc = " @param  timer_sel LEDC timer index (0-3), select from ledc_timer_t"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_OK Success"]
    pub fn ledc_timer_rst(speed_mode: ledc_mode_t, timer_sel: ledc_timer_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Pause LEDC timer counter"]
    #[doc = ""]
    #[doc = " @param  speed_mode  Select the LEDC channel group with specified speed mode. Note that not all targets support high speed mode."]
    #[doc = " @param  timer_sel LEDC timer index (0-3), select from ledc_timer_t"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_OK Success"]
    #[doc = ""]
    pub fn ledc_timer_pause(speed_mode: ledc_mode_t, timer_sel: ledc_timer_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Resume LEDC timer"]
    #[doc = ""]
    #[doc = " @param speed_mode Select the LEDC channel group with specified speed mode. Note that not all targets support high speed mode."]
    #[doc = " @param timer_sel LEDC timer index (0-3), select from ledc_timer_t"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_OK Success"]
    pub fn ledc_timer_resume(speed_mode: ledc_mode_t, timer_sel: ledc_timer_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Bind LEDC channel with the selected timer"]
    #[doc = ""]
    #[doc = " @param speed_mode Select the LEDC channel group with specified speed mode. Note that not all targets support high speed mode."]
    #[doc = " @param channel LEDC channel index (0-7), select from ledc_channel_t"]
    #[doc = " @param timer_sel LEDC timer index (0-3), select from ledc_timer_t"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_OK Success"]
    pub fn ledc_bind_channel_timer(
        speed_mode: ledc_mode_t,
        channel: ledc_channel_t,
        timer_sel: ledc_timer_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set LEDC fade function."]
    #[doc = " @note  Call ledc_fade_func_install() once before calling this function."]
    #[doc = "        Call ledc_fade_start() after this to start fading."]
    #[doc = " @note  ledc_set_fade_with_step, ledc_set_fade_with_time and ledc_fade_start are not thread-safe, do not call these functions to"]
    #[doc = "        control one LEDC channel in different tasks at the same time."]
    #[doc = "        A thread-safe version of API is ledc_set_fade_step_and_start"]
    #[doc = " @note  If a fade operation is running in progress on that channel, the driver would not allow it to be stopped."]
    #[doc = "        Other duty operations will have to wait until the fade operation has finished."]
    #[doc = " @param speed_mode Select the LEDC channel group with specified speed mode. Note that not all targets support high speed mode. ,"]
    #[doc = " @param channel LEDC channel index (0-7), select from ledc_channel_t"]
    #[doc = " @param target_duty Target duty of fading [0, (2**duty_resolution) - 1]"]
    #[doc = " @param scale Controls the increase or decrease step scale."]
    #[doc = " @param cycle_num increase or decrease the duty every cycle_num cycles"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_STATE Fade function not installed."]
    #[doc = "     - ESP_FAIL Fade function init error"]
    pub fn ledc_set_fade_with_step(
        speed_mode: ledc_mode_t,
        channel: ledc_channel_t,
        target_duty: u32,
        scale: u32,
        cycle_num: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set LEDC fade function, with a limited time."]
    #[doc = " @note  Call ledc_fade_func_install() once before calling this function."]
    #[doc = "        Call ledc_fade_start() after this to start fading."]
    #[doc = " @note  ledc_set_fade_with_step, ledc_set_fade_with_time and ledc_fade_start are not thread-safe, do not call these functions to"]
    #[doc = "        control one LEDC channel in different tasks at the same time."]
    #[doc = "        A thread-safe version of API is ledc_set_fade_step_and_start"]
    #[doc = " @note  If a fade operation is running in progress on that channel, the driver would not allow it to be stopped."]
    #[doc = "        Other duty operations will have to wait until the fade operation has finished."]
    #[doc = " @param speed_mode Select the LEDC channel group with specified speed mode. Note that not all targets support high speed mode. ,"]
    #[doc = " @param channel LEDC channel index (0-7), select from ledc_channel_t"]
    #[doc = " @param target_duty Target duty of fading.( 0 - (2 ** duty_resolution - 1)))"]
    #[doc = " @param max_fade_time_ms The maximum time of the fading ( ms )."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_STATE Fade function not installed."]
    #[doc = "     - ESP_FAIL Fade function init error"]
    pub fn ledc_set_fade_with_time(
        speed_mode: ledc_mode_t,
        channel: ledc_channel_t,
        target_duty: u32,
        max_fade_time_ms: ::std::os::raw::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Install LEDC fade function. This function will occupy interrupt of LEDC module."]
    #[doc = " @param intr_alloc_flags Flags used to allocate the interrupt. One or multiple (ORred)"]
    #[doc = "        ESP_INTR_FLAG_* values. See esp_intr_alloc.h for more info."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_STATE Fade function already installed."]
    pub fn ledc_fade_func_install(intr_alloc_flags: ::std::os::raw::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Uninstall LEDC fade function."]
    #[doc = ""]
    pub fn ledc_fade_func_uninstall();
}
extern "C" {
    #[doc = " @brief Start LEDC fading."]
    #[doc = " @note  Call ledc_fade_func_install() once before calling this function."]
    #[doc = "        Call this API right after ledc_set_fade_with_time or ledc_set_fade_with_step before to start fading."]
    #[doc = " @note  If a fade operation is running in progress on that channel, the driver would not allow it to be stopped."]
    #[doc = "        Other duty operations will have to wait until the fade operation has finished."]
    #[doc = " @param speed_mode Select the LEDC channel group with specified speed mode. Note that not all targets support high speed mode."]
    #[doc = " @param channel LEDC channel number"]
    #[doc = " @param fade_mode Whether to block until fading done."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_STATE Fade function not installed."]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error."]
    pub fn ledc_fade_start(
        speed_mode: ledc_mode_t,
        channel: ledc_channel_t,
        fade_mode: ledc_fade_mode_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief A thread-safe API to set duty for LEDC channel and return when duty updated."]
    #[doc = " @note  If a fade operation is running in progress on that channel, the driver would not allow it to be stopped."]
    #[doc = "        Other duty operations will have to wait until the fade operation has finished."]
    #[doc = ""]
    #[doc = " @param speed_mode Select the LEDC channel group with specified speed mode. Note that not all targets support high speed mode."]
    #[doc = " @param channel LEDC channel (0-7), select from ledc_channel_t"]
    #[doc = " @param duty Set the LEDC duty, the range of duty setting is [0, (2**duty_resolution)]"]
    #[doc = " @param hpoint Set the LEDC hpoint value(max: 0xfffff)"]
    #[doc = ""]
    pub fn ledc_set_duty_and_update(
        speed_mode: ledc_mode_t,
        channel: ledc_channel_t,
        duty: u32,
        hpoint: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief A thread-safe API to set and start LEDC fade function, with a limited time."]
    #[doc = " @note  Call ledc_fade_func_install() once, before calling this function."]
    #[doc = " @note  If a fade operation is running in progress on that channel, the driver would not allow it to be stopped."]
    #[doc = "        Other duty operations will have to wait until the fade operation has finished."]
    #[doc = " @param speed_mode Select the LEDC channel group with specified speed mode. Note that not all targets support high speed mode."]
    #[doc = " @param channel LEDC channel index (0-7), select from ledc_channel_t"]
    #[doc = " @param target_duty Target duty of fading.( 0 - (2 ** duty_resolution - 1)))"]
    #[doc = " @param max_fade_time_ms The maximum time of the fading ( ms )."]
    #[doc = " @param fade_mode choose blocking or non-blocking mode"]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_STATE Fade function not installed."]
    #[doc = "     - ESP_FAIL Fade function init error"]
    pub fn ledc_set_fade_time_and_start(
        speed_mode: ledc_mode_t,
        channel: ledc_channel_t,
        target_duty: u32,
        max_fade_time_ms: u32,
        fade_mode: ledc_fade_mode_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief A thread-safe API to set and start LEDC fade function."]
    #[doc = " @note  Call ledc_fade_func_install() once before calling this function."]
    #[doc = " @note  If a fade operation is running in progress on that channel, the driver would not allow it to be stopped."]
    #[doc = "        Other duty operations will have to wait until the fade operation has finished."]
    #[doc = " @param speed_mode Select the LEDC channel group with specified speed mode. Note that not all targets support high speed mode."]
    #[doc = " @param channel LEDC channel index (0-7), select from ledc_channel_t"]
    #[doc = " @param target_duty Target duty of fading [0, (2**duty_resolution) - 1]"]
    #[doc = " @param scale Controls the increase or decrease step scale."]
    #[doc = " @param cycle_num increase or decrease the duty every cycle_num cycles"]
    #[doc = " @param fade_mode choose blocking or non-blocking mode"]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_STATE Fade function not installed."]
    #[doc = "     - ESP_FAIL Fade function init error"]
    pub fn ledc_set_fade_step_and_start(
        speed_mode: ledc_mode_t,
        channel: ledc_channel_t,
        target_duty: u32,
        scale: u32,
        cycle_num: u32,
        fade_mode: ledc_fade_mode_t,
    ) -> esp_err_t;
}
pub const camera_pid_t_OV9650_PID: camera_pid_t = 150;
pub const camera_pid_t_OV7725_PID: camera_pid_t = 119;
pub const camera_pid_t_OV2640_PID: camera_pid_t = 38;
pub const camera_pid_t_OV3660_PID: camera_pid_t = 13920;
pub const camera_pid_t_OV5640_PID: camera_pid_t = 22080;
pub const camera_pid_t_OV7670_PID: camera_pid_t = 118;
pub const camera_pid_t_NT99141_PID: camera_pid_t = 5136;
pub const camera_pid_t_GC2145_PID: camera_pid_t = 8517;
pub const camera_pid_t_GC032A_PID: camera_pid_t = 9002;
pub const camera_pid_t_GC0308_PID: camera_pid_t = 155;
pub const camera_pid_t_BF3005_PID: camera_pid_t = 48;
pub type camera_pid_t = u32;
pub const camera_model_t_CAMERA_OV7725: camera_model_t = 0;
pub const camera_model_t_CAMERA_OV2640: camera_model_t = 1;
pub const camera_model_t_CAMERA_OV3660: camera_model_t = 2;
pub const camera_model_t_CAMERA_OV5640: camera_model_t = 3;
pub const camera_model_t_CAMERA_OV7670: camera_model_t = 4;
pub const camera_model_t_CAMERA_NT99141: camera_model_t = 5;
pub const camera_model_t_CAMERA_GC2145: camera_model_t = 6;
pub const camera_model_t_CAMERA_GC032A: camera_model_t = 7;
pub const camera_model_t_CAMERA_GC0308: camera_model_t = 8;
pub const camera_model_t_CAMERA_BF3005: camera_model_t = 9;
pub const camera_model_t_CAMERA_MODEL_MAX: camera_model_t = 10;
pub const camera_model_t_CAMERA_NONE: camera_model_t = 11;
pub type camera_model_t = u32;
pub const camera_sccb_addr_t_OV2640_SCCB_ADDR: camera_sccb_addr_t = 48;
pub const camera_sccb_addr_t_OV5640_SCCB_ADDR: camera_sccb_addr_t = 60;
pub const camera_sccb_addr_t_OV3660_SCCB_ADDR: camera_sccb_addr_t = 60;
pub const camera_sccb_addr_t_OV7725_SCCB_ADDR: camera_sccb_addr_t = 33;
pub const camera_sccb_addr_t_OV7670_SCCB_ADDR: camera_sccb_addr_t = 33;
pub const camera_sccb_addr_t_NT99141_SCCB_ADDR: camera_sccb_addr_t = 42;
pub const camera_sccb_addr_t_GC2145_SCCB_ADDR: camera_sccb_addr_t = 60;
pub const camera_sccb_addr_t_GC032A_SCCB_ADDR: camera_sccb_addr_t = 33;
pub const camera_sccb_addr_t_GC0308_SCCB_ADDR: camera_sccb_addr_t = 33;
pub const camera_sccb_addr_t_BF3005_SCCB_ADDR: camera_sccb_addr_t = 110;
pub type camera_sccb_addr_t = u32;
pub const pixformat_t_PIXFORMAT_RGB565: pixformat_t = 0;
pub const pixformat_t_PIXFORMAT_YUV422: pixformat_t = 1;
pub const pixformat_t_PIXFORMAT_GRAYSCALE: pixformat_t = 2;
pub const pixformat_t_PIXFORMAT_JPEG: pixformat_t = 3;
pub const pixformat_t_PIXFORMAT_RGB888: pixformat_t = 4;
pub const pixformat_t_PIXFORMAT_RAW: pixformat_t = 5;
pub const pixformat_t_PIXFORMAT_RGB444: pixformat_t = 6;
pub const pixformat_t_PIXFORMAT_RGB555: pixformat_t = 7;
pub type pixformat_t = u32;
pub const framesize_t_FRAMESIZE_96X96: framesize_t = 0;
pub const framesize_t_FRAMESIZE_QQVGA: framesize_t = 1;
pub const framesize_t_FRAMESIZE_QCIF: framesize_t = 2;
pub const framesize_t_FRAMESIZE_HQVGA: framesize_t = 3;
pub const framesize_t_FRAMESIZE_240X240: framesize_t = 4;
pub const framesize_t_FRAMESIZE_QVGA: framesize_t = 5;
pub const framesize_t_FRAMESIZE_CIF: framesize_t = 6;
pub const framesize_t_FRAMESIZE_HVGA: framesize_t = 7;
pub const framesize_t_FRAMESIZE_VGA: framesize_t = 8;
pub const framesize_t_FRAMESIZE_SVGA: framesize_t = 9;
pub const framesize_t_FRAMESIZE_XGA: framesize_t = 10;
pub const framesize_t_FRAMESIZE_HD: framesize_t = 11;
pub const framesize_t_FRAMESIZE_SXGA: framesize_t = 12;
pub const framesize_t_FRAMESIZE_UXGA: framesize_t = 13;
pub const framesize_t_FRAMESIZE_FHD: framesize_t = 14;
pub const framesize_t_FRAMESIZE_P_HD: framesize_t = 15;
pub const framesize_t_FRAMESIZE_P_3MP: framesize_t = 16;
pub const framesize_t_FRAMESIZE_QXGA: framesize_t = 17;
pub const framesize_t_FRAMESIZE_QHD: framesize_t = 18;
pub const framesize_t_FRAMESIZE_WQXGA: framesize_t = 19;
pub const framesize_t_FRAMESIZE_P_FHD: framesize_t = 20;
pub const framesize_t_FRAMESIZE_QSXGA: framesize_t = 21;
pub const framesize_t_FRAMESIZE_INVALID: framesize_t = 22;
pub type framesize_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct camera_sensor_info_t {
    pub model: camera_model_t,
    pub name: *const ::std::os::raw::c_char,
    pub sccb_addr: camera_sccb_addr_t,
    pub pid: camera_pid_t,
    pub max_size: framesize_t,
    pub support_jpeg: bool,
}
#[test]
fn bindgen_test_layout_camera_sensor_info_t() {
    assert_eq!(
        ::std::mem::size_of::<camera_sensor_info_t>(),
        32usize,
        concat!("Size of: ", stringify!(camera_sensor_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<camera_sensor_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(camera_sensor_info_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_sensor_info_t>())).model as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_sensor_info_t),
            "::",
            stringify!(model)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_sensor_info_t>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_sensor_info_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_sensor_info_t>())).sccb_addr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_sensor_info_t),
            "::",
            stringify!(sccb_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_sensor_info_t>())).pid as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_sensor_info_t),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_sensor_info_t>())).max_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_sensor_info_t),
            "::",
            stringify!(max_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<camera_sensor_info_t>())).support_jpeg as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_sensor_info_t),
            "::",
            stringify!(support_jpeg)
        )
    );
}
pub const aspect_ratio_t_ASPECT_RATIO_4X3: aspect_ratio_t = 0;
pub const aspect_ratio_t_ASPECT_RATIO_3X2: aspect_ratio_t = 1;
pub const aspect_ratio_t_ASPECT_RATIO_16X10: aspect_ratio_t = 2;
pub const aspect_ratio_t_ASPECT_RATIO_5X3: aspect_ratio_t = 3;
pub const aspect_ratio_t_ASPECT_RATIO_16X9: aspect_ratio_t = 4;
pub const aspect_ratio_t_ASPECT_RATIO_21X9: aspect_ratio_t = 5;
pub const aspect_ratio_t_ASPECT_RATIO_5X4: aspect_ratio_t = 6;
pub const aspect_ratio_t_ASPECT_RATIO_1X1: aspect_ratio_t = 7;
pub const aspect_ratio_t_ASPECT_RATIO_9X16: aspect_ratio_t = 8;
pub type aspect_ratio_t = u32;
pub const gainceiling_t_GAINCEILING_2X: gainceiling_t = 0;
pub const gainceiling_t_GAINCEILING_4X: gainceiling_t = 1;
pub const gainceiling_t_GAINCEILING_8X: gainceiling_t = 2;
pub const gainceiling_t_GAINCEILING_16X: gainceiling_t = 3;
pub const gainceiling_t_GAINCEILING_32X: gainceiling_t = 4;
pub const gainceiling_t_GAINCEILING_64X: gainceiling_t = 5;
pub const gainceiling_t_GAINCEILING_128X: gainceiling_t = 6;
pub type gainceiling_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ratio_settings_t {
    pub max_width: u16,
    pub max_height: u16,
    pub start_x: u16,
    pub start_y: u16,
    pub end_x: u16,
    pub end_y: u16,
    pub offset_x: u16,
    pub offset_y: u16,
    pub total_x: u16,
    pub total_y: u16,
}
#[test]
fn bindgen_test_layout_ratio_settings_t() {
    assert_eq!(
        ::std::mem::size_of::<ratio_settings_t>(),
        20usize,
        concat!("Size of: ", stringify!(ratio_settings_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ratio_settings_t>(),
        2usize,
        concat!("Alignment of ", stringify!(ratio_settings_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ratio_settings_t>())).max_width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ratio_settings_t),
            "::",
            stringify!(max_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ratio_settings_t>())).max_height as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ratio_settings_t),
            "::",
            stringify!(max_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ratio_settings_t>())).start_x as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ratio_settings_t),
            "::",
            stringify!(start_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ratio_settings_t>())).start_y as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ratio_settings_t),
            "::",
            stringify!(start_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ratio_settings_t>())).end_x as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ratio_settings_t),
            "::",
            stringify!(end_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ratio_settings_t>())).end_y as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(ratio_settings_t),
            "::",
            stringify!(end_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ratio_settings_t>())).offset_x as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ratio_settings_t),
            "::",
            stringify!(offset_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ratio_settings_t>())).offset_y as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(ratio_settings_t),
            "::",
            stringify!(offset_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ratio_settings_t>())).total_x as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ratio_settings_t),
            "::",
            stringify!(total_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ratio_settings_t>())).total_y as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(ratio_settings_t),
            "::",
            stringify!(total_y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct resolution_info_t {
    pub width: u16,
    pub height: u16,
    pub aspect_ratio: aspect_ratio_t,
}
#[test]
fn bindgen_test_layout_resolution_info_t() {
    assert_eq!(
        ::std::mem::size_of::<resolution_info_t>(),
        8usize,
        concat!("Size of: ", stringify!(resolution_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<resolution_info_t>(),
        4usize,
        concat!("Alignment of ", stringify!(resolution_info_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<resolution_info_t>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(resolution_info_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<resolution_info_t>())).height as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(resolution_info_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<resolution_info_t>())).aspect_ratio as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(resolution_info_t),
            "::",
            stringify!(aspect_ratio)
        )
    );
}
extern "C" {
    pub static mut resolution: [resolution_info_t; 0usize];
}
extern "C" {
    pub static mut camera_sensor: [camera_sensor_info_t; 0usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_id_t {
    pub MIDH: u8,
    pub MIDL: u8,
    pub PID: u16,
    pub VER: u8,
}
#[test]
fn bindgen_test_layout_sensor_id_t() {
    assert_eq!(
        ::std::mem::size_of::<sensor_id_t>(),
        6usize,
        concat!("Size of: ", stringify!(sensor_id_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_id_t>(),
        2usize,
        concat!("Alignment of ", stringify!(sensor_id_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sensor_id_t>())).MIDH as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_id_t),
            "::",
            stringify!(MIDH)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sensor_id_t>())).MIDL as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_id_t),
            "::",
            stringify!(MIDL)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sensor_id_t>())).PID as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_id_t),
            "::",
            stringify!(PID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sensor_id_t>())).VER as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_id_t),
            "::",
            stringify!(VER)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct camera_status_t {
    pub framesize: framesize_t,
    pub scale: bool,
    pub binning: bool,
    pub quality: u8,
    pub brightness: i8,
    pub contrast: i8,
    pub saturation: i8,
    pub sharpness: i8,
    pub denoise: u8,
    pub special_effect: u8,
    pub wb_mode: u8,
    pub awb: u8,
    pub awb_gain: u8,
    pub aec: u8,
    pub aec2: u8,
    pub ae_level: i8,
    pub aec_value: u16,
    pub agc: u8,
    pub agc_gain: u8,
    pub gainceiling: u8,
    pub bpc: u8,
    pub wpc: u8,
    pub raw_gma: u8,
    pub lenc: u8,
    pub hmirror: u8,
    pub vflip: u8,
    pub dcw: u8,
    pub colorbar: u8,
}
#[test]
fn bindgen_test_layout_camera_status_t() {
    assert_eq!(
        ::std::mem::size_of::<camera_status_t>(),
        36usize,
        concat!("Size of: ", stringify!(camera_status_t))
    );
    assert_eq!(
        ::std::mem::align_of::<camera_status_t>(),
        4usize,
        concat!("Alignment of ", stringify!(camera_status_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_status_t>())).framesize as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_status_t),
            "::",
            stringify!(framesize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_status_t>())).scale as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_status_t),
            "::",
            stringify!(scale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_status_t>())).binning as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_status_t),
            "::",
            stringify!(binning)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_status_t>())).quality as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_status_t),
            "::",
            stringify!(quality)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_status_t>())).brightness as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_status_t),
            "::",
            stringify!(brightness)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_status_t>())).contrast as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_status_t),
            "::",
            stringify!(contrast)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_status_t>())).saturation as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_status_t),
            "::",
            stringify!(saturation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_status_t>())).sharpness as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_status_t),
            "::",
            stringify!(sharpness)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_status_t>())).denoise as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_status_t),
            "::",
            stringify!(denoise)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_status_t>())).special_effect as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_status_t),
            "::",
            stringify!(special_effect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_status_t>())).wb_mode as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_status_t),
            "::",
            stringify!(wb_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_status_t>())).awb as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_status_t),
            "::",
            stringify!(awb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_status_t>())).awb_gain as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_status_t),
            "::",
            stringify!(awb_gain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_status_t>())).aec as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_status_t),
            "::",
            stringify!(aec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_status_t>())).aec2 as *const _ as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_status_t),
            "::",
            stringify!(aec2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_status_t>())).ae_level as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_status_t),
            "::",
            stringify!(ae_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_status_t>())).aec_value as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_status_t),
            "::",
            stringify!(aec_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_status_t>())).agc as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_status_t),
            "::",
            stringify!(agc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_status_t>())).agc_gain as *const _ as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_status_t),
            "::",
            stringify!(agc_gain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_status_t>())).gainceiling as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_status_t),
            "::",
            stringify!(gainceiling)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_status_t>())).bpc as *const _ as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_status_t),
            "::",
            stringify!(bpc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_status_t>())).wpc as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_status_t),
            "::",
            stringify!(wpc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_status_t>())).raw_gma as *const _ as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_status_t),
            "::",
            stringify!(raw_gma)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_status_t>())).lenc as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_status_t),
            "::",
            stringify!(lenc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_status_t>())).hmirror as *const _ as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_status_t),
            "::",
            stringify!(hmirror)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_status_t>())).vflip as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_status_t),
            "::",
            stringify!(vflip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_status_t>())).dcw as *const _ as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_status_t),
            "::",
            stringify!(dcw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_status_t>())).colorbar as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_status_t),
            "::",
            stringify!(colorbar)
        )
    );
}
pub type sensor_t = _sensor;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _sensor {
    pub id: sensor_id_t,
    pub slv_addr: u8,
    pub pixformat: pixformat_t,
    pub status: camera_status_t,
    pub xclk_freq_hz: ::std::os::raw::c_int,
    pub init_status:
        ::std::option::Option<unsafe extern "C" fn(sensor: *mut sensor_t) -> ::std::os::raw::c_int>,
    pub reset:
        ::std::option::Option<unsafe extern "C" fn(sensor: *mut sensor_t) -> ::std::os::raw::c_int>,
    pub set_pixformat: ::std::option::Option<
        unsafe extern "C" fn(
            sensor: *mut sensor_t,
            pixformat: pixformat_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub set_framesize: ::std::option::Option<
        unsafe extern "C" fn(
            sensor: *mut sensor_t,
            framesize: framesize_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub set_contrast: ::std::option::Option<
        unsafe extern "C" fn(
            sensor: *mut sensor_t,
            level: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub set_brightness: ::std::option::Option<
        unsafe extern "C" fn(
            sensor: *mut sensor_t,
            level: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub set_saturation: ::std::option::Option<
        unsafe extern "C" fn(
            sensor: *mut sensor_t,
            level: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub set_sharpness: ::std::option::Option<
        unsafe extern "C" fn(
            sensor: *mut sensor_t,
            level: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub set_denoise: ::std::option::Option<
        unsafe extern "C" fn(
            sensor: *mut sensor_t,
            level: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub set_gainceiling: ::std::option::Option<
        unsafe extern "C" fn(
            sensor: *mut sensor_t,
            gainceiling: gainceiling_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub set_quality: ::std::option::Option<
        unsafe extern "C" fn(
            sensor: *mut sensor_t,
            quality: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub set_colorbar: ::std::option::Option<
        unsafe extern "C" fn(
            sensor: *mut sensor_t,
            enable: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub set_whitebal: ::std::option::Option<
        unsafe extern "C" fn(
            sensor: *mut sensor_t,
            enable: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub set_gain_ctrl: ::std::option::Option<
        unsafe extern "C" fn(
            sensor: *mut sensor_t,
            enable: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub set_exposure_ctrl: ::std::option::Option<
        unsafe extern "C" fn(
            sensor: *mut sensor_t,
            enable: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub set_hmirror: ::std::option::Option<
        unsafe extern "C" fn(
            sensor: *mut sensor_t,
            enable: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub set_vflip: ::std::option::Option<
        unsafe extern "C" fn(
            sensor: *mut sensor_t,
            enable: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub set_aec2: ::std::option::Option<
        unsafe extern "C" fn(
            sensor: *mut sensor_t,
            enable: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub set_awb_gain: ::std::option::Option<
        unsafe extern "C" fn(
            sensor: *mut sensor_t,
            enable: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub set_agc_gain: ::std::option::Option<
        unsafe extern "C" fn(
            sensor: *mut sensor_t,
            gain: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub set_aec_value: ::std::option::Option<
        unsafe extern "C" fn(
            sensor: *mut sensor_t,
            gain: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub set_special_effect: ::std::option::Option<
        unsafe extern "C" fn(
            sensor: *mut sensor_t,
            effect: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub set_wb_mode: ::std::option::Option<
        unsafe extern "C" fn(
            sensor: *mut sensor_t,
            mode: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub set_ae_level: ::std::option::Option<
        unsafe extern "C" fn(
            sensor: *mut sensor_t,
            level: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub set_dcw: ::std::option::Option<
        unsafe extern "C" fn(
            sensor: *mut sensor_t,
            enable: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub set_bpc: ::std::option::Option<
        unsafe extern "C" fn(
            sensor: *mut sensor_t,
            enable: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub set_wpc: ::std::option::Option<
        unsafe extern "C" fn(
            sensor: *mut sensor_t,
            enable: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub set_raw_gma: ::std::option::Option<
        unsafe extern "C" fn(
            sensor: *mut sensor_t,
            enable: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub set_lenc: ::std::option::Option<
        unsafe extern "C" fn(
            sensor: *mut sensor_t,
            enable: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub get_reg: ::std::option::Option<
        unsafe extern "C" fn(
            sensor: *mut sensor_t,
            reg: ::std::os::raw::c_int,
            mask: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub set_reg: ::std::option::Option<
        unsafe extern "C" fn(
            sensor: *mut sensor_t,
            reg: ::std::os::raw::c_int,
            mask: ::std::os::raw::c_int,
            value: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub set_res_raw: ::std::option::Option<
        unsafe extern "C" fn(
            sensor: *mut sensor_t,
            startX: ::std::os::raw::c_int,
            startY: ::std::os::raw::c_int,
            endX: ::std::os::raw::c_int,
            endY: ::std::os::raw::c_int,
            offsetX: ::std::os::raw::c_int,
            offsetY: ::std::os::raw::c_int,
            totalX: ::std::os::raw::c_int,
            totalY: ::std::os::raw::c_int,
            outputX: ::std::os::raw::c_int,
            outputY: ::std::os::raw::c_int,
            scale: bool,
            binning: bool,
        ) -> ::std::os::raw::c_int,
    >,
    pub set_pll: ::std::option::Option<
        unsafe extern "C" fn(
            sensor: *mut sensor_t,
            bypass: ::std::os::raw::c_int,
            mul: ::std::os::raw::c_int,
            sys: ::std::os::raw::c_int,
            root: ::std::os::raw::c_int,
            pre: ::std::os::raw::c_int,
            seld5: ::std::os::raw::c_int,
            pclken: ::std::os::raw::c_int,
            pclk: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub set_xclk: ::std::option::Option<
        unsafe extern "C" fn(
            sensor: *mut sensor_t,
            timer: ::std::os::raw::c_int,
            xclk: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout__sensor() {
    assert_eq!(
        ::std::mem::size_of::<_sensor>(),
        328usize,
        concat!("Size of: ", stringify!(_sensor))
    );
    assert_eq!(
        ::std::mem::align_of::<_sensor>(),
        8usize,
        concat!("Alignment of ", stringify!(_sensor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_sensor>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_sensor),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_sensor>())).slv_addr as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_sensor),
            "::",
            stringify!(slv_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_sensor>())).pixformat as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_sensor),
            "::",
            stringify!(pixformat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_sensor>())).status as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_sensor),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_sensor>())).xclk_freq_hz as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_sensor),
            "::",
            stringify!(xclk_freq_hz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_sensor>())).init_status as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_sensor),
            "::",
            stringify!(init_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_sensor>())).reset as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_sensor),
            "::",
            stringify!(reset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_sensor>())).set_pixformat as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_sensor),
            "::",
            stringify!(set_pixformat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_sensor>())).set_framesize as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_sensor),
            "::",
            stringify!(set_framesize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_sensor>())).set_contrast as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_sensor),
            "::",
            stringify!(set_contrast)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_sensor>())).set_brightness as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_sensor),
            "::",
            stringify!(set_brightness)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_sensor>())).set_saturation as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_sensor),
            "::",
            stringify!(set_saturation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_sensor>())).set_sharpness as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_sensor),
            "::",
            stringify!(set_sharpness)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_sensor>())).set_denoise as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_sensor),
            "::",
            stringify!(set_denoise)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_sensor>())).set_gainceiling as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_sensor),
            "::",
            stringify!(set_gainceiling)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_sensor>())).set_quality as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_sensor),
            "::",
            stringify!(set_quality)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_sensor>())).set_colorbar as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_sensor),
            "::",
            stringify!(set_colorbar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_sensor>())).set_whitebal as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_sensor),
            "::",
            stringify!(set_whitebal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_sensor>())).set_gain_ctrl as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_sensor),
            "::",
            stringify!(set_gain_ctrl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_sensor>())).set_exposure_ctrl as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_sensor),
            "::",
            stringify!(set_exposure_ctrl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_sensor>())).set_hmirror as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_sensor),
            "::",
            stringify!(set_hmirror)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_sensor>())).set_vflip as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_sensor),
            "::",
            stringify!(set_vflip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_sensor>())).set_aec2 as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_sensor),
            "::",
            stringify!(set_aec2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_sensor>())).set_awb_gain as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_sensor),
            "::",
            stringify!(set_awb_gain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_sensor>())).set_agc_gain as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_sensor),
            "::",
            stringify!(set_agc_gain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_sensor>())).set_aec_value as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_sensor),
            "::",
            stringify!(set_aec_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_sensor>())).set_special_effect as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_sensor),
            "::",
            stringify!(set_special_effect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_sensor>())).set_wb_mode as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_sensor),
            "::",
            stringify!(set_wb_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_sensor>())).set_ae_level as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_sensor),
            "::",
            stringify!(set_ae_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_sensor>())).set_dcw as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_sensor),
            "::",
            stringify!(set_dcw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_sensor>())).set_bpc as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_sensor),
            "::",
            stringify!(set_bpc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_sensor>())).set_wpc as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_sensor),
            "::",
            stringify!(set_wpc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_sensor>())).set_raw_gma as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_sensor),
            "::",
            stringify!(set_raw_gma)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_sensor>())).set_lenc as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_sensor),
            "::",
            stringify!(set_lenc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_sensor>())).get_reg as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_sensor),
            "::",
            stringify!(get_reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_sensor>())).set_reg as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_sensor),
            "::",
            stringify!(set_reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_sensor>())).set_res_raw as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_sensor),
            "::",
            stringify!(set_res_raw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_sensor>())).set_pll as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_sensor),
            "::",
            stringify!(set_pll)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_sensor>())).set_xclk as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_sensor),
            "::",
            stringify!(set_xclk)
        )
    );
}
extern "C" {
    pub fn esp_camera_sensor_get_info(id: *mut sensor_id_t) -> *mut camera_sensor_info_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: ::std::os::raw::c_int,
    pub tz_dsttime: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    assert_eq!(
        ::std::mem::size_of::<timezone>(),
        8usize,
        concat!("Size of: ", stringify!(timezone))
    );
    assert_eq!(
        ::std::mem::align_of::<timezone>(),
        4usize,
        concat!("Alignment of ", stringify!(timezone))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timezone>())).tz_minuteswest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_minuteswest)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timezone>())).tz_dsttime as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_dsttime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bintime {
    pub sec: time_t,
    pub frac: u64,
}
#[test]
fn bindgen_test_layout_bintime() {
    assert_eq!(
        ::std::mem::size_of::<bintime>(),
        16usize,
        concat!("Size of: ", stringify!(bintime))
    );
    assert_eq!(
        ::std::mem::align_of::<bintime>(),
        8usize,
        concat!("Alignment of ", stringify!(bintime))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bintime>())).sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bintime),
            "::",
            stringify!(sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bintime>())).frac as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bintime),
            "::",
            stringify!(frac)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[test]
fn bindgen_test_layout_itimerval() {
    assert_eq!(
        ::std::mem::size_of::<itimerval>(),
        32usize,
        concat!("Size of: ", stringify!(itimerval))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerval>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerval>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerval>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_value)
        )
    );
}
pub type locale_t = *mut __locale_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        36usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        4usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn difftime(_time2: time_t, _time1: time_t) -> f64;
}
extern "C" {
    pub fn mktime(_timeptr: *mut tm) -> time_t;
}
extern "C" {
    pub fn time(_timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn asctime(_tblock: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(_time: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gmtime(_timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(_timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn strftime(
        _s: *mut ::std::os::raw::c_char,
        _maxsize: usize,
        _fmt: *const ::std::os::raw::c_char,
        _t: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strftime_l(
        _s: *mut ::std::os::raw::c_char,
        _maxsize: usize,
        _fmt: *const ::std::os::raw::c_char,
        _t: *const tm,
        _l: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn asctime_r(
        arg1: *const tm,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        arg1: *const time_t,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gmtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub fn _tzset_r(arg1: *mut _reent);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __tzrule_struct {
    pub ch: ::std::os::raw::c_char,
    pub m: ::std::os::raw::c_int,
    pub n: ::std::os::raw::c_int,
    pub d: ::std::os::raw::c_int,
    pub s: ::std::os::raw::c_int,
    pub change: time_t,
    pub offset: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout___tzrule_struct() {
    assert_eq!(
        ::std::mem::size_of::<__tzrule_struct>(),
        40usize,
        concat!("Size of: ", stringify!(__tzrule_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__tzrule_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__tzrule_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__tzrule_struct>())).ch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__tzrule_struct),
            "::",
            stringify!(ch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__tzrule_struct>())).m as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__tzrule_struct),
            "::",
            stringify!(m)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__tzrule_struct>())).n as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__tzrule_struct),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__tzrule_struct>())).d as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__tzrule_struct),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__tzrule_struct>())).s as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__tzrule_struct),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__tzrule_struct>())).change as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__tzrule_struct),
            "::",
            stringify!(change)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__tzrule_struct>())).offset as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__tzrule_struct),
            "::",
            stringify!(offset)
        )
    );
}
pub type __tzrule_type = __tzrule_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __tzinfo_struct {
    pub __tznorth: ::std::os::raw::c_int,
    pub __tzyear: ::std::os::raw::c_int,
    pub __tzrule: [__tzrule_type; 2usize],
}
#[test]
fn bindgen_test_layout___tzinfo_struct() {
    assert_eq!(
        ::std::mem::size_of::<__tzinfo_struct>(),
        88usize,
        concat!("Size of: ", stringify!(__tzinfo_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__tzinfo_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__tzinfo_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__tzinfo_struct>())).__tznorth as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__tzinfo_struct),
            "::",
            stringify!(__tznorth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__tzinfo_struct>())).__tzyear as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__tzinfo_struct),
            "::",
            stringify!(__tzyear)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__tzinfo_struct>())).__tzrule as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__tzinfo_struct),
            "::",
            stringify!(__tzrule)
        )
    );
}
pub type __tzinfo_type = __tzinfo_struct;
extern "C" {
    pub fn __gettzinfo() -> *mut __tzinfo_type;
}
extern "C" {
    pub static mut _timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut _daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut _tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn clock_settime(clock_id: clockid_t, tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(clock_id: clockid_t, tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(clock_id: clockid_t, res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn utimes(
        __path: *const ::std::os::raw::c_char,
        __tvp: *const timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn adjtime(arg1: *const timeval, arg2: *mut timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futimes(arg1: ::std::os::raw::c_int, arg2: *const timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lutimes(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn settimeofday(arg1: *const timeval, arg2: *const timezone) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getitimer(
        __which: ::std::os::raw::c_int,
        __value: *mut itimerval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setitimer(
        __which: ::std::os::raw::c_int,
        __value: *const itimerval,
        __ovalue: *mut itimerval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gettimeofday(
        __p: *mut timeval,
        __tz: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[doc = "< Fills buffers when they are empty. Less resources but first 'fb_count' frames might be old"]
pub const camera_grab_mode_t_CAMERA_GRAB_WHEN_EMPTY: camera_grab_mode_t = 0;
#[doc = "< Except when 1 frame buffer is used, queue will always contain the last 'fb_count' frames"]
pub const camera_grab_mode_t_CAMERA_GRAB_LATEST: camera_grab_mode_t = 1;
#[doc = " @brief Configuration structure for camera initialization"]
pub type camera_grab_mode_t = u32;
#[doc = "< Frame buffer is placed in external PSRAM"]
pub const camera_fb_location_t_CAMERA_FB_IN_PSRAM: camera_fb_location_t = 0;
#[doc = "< Frame buffer is placed in internal DRAM"]
pub const camera_fb_location_t_CAMERA_FB_IN_DRAM: camera_fb_location_t = 1;
#[doc = " @brief Camera frame buffer location"]
pub type camera_fb_location_t = u32;
#[doc = " @brief Configuration structure for camera initialization"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct camera_config_t {
    #[doc = "< GPIO pin for camera power down line"]
    pub pin_pwdn: ::std::os::raw::c_int,
    #[doc = "< GPIO pin for camera reset line"]
    pub pin_reset: ::std::os::raw::c_int,
    #[doc = "< GPIO pin for camera XCLK line"]
    pub pin_xclk: ::std::os::raw::c_int,
    #[doc = "< GPIO pin for camera SDA line"]
    pub pin_sscb_sda: ::std::os::raw::c_int,
    #[doc = "< GPIO pin for camera SCL line"]
    pub pin_sscb_scl: ::std::os::raw::c_int,
    #[doc = "< GPIO pin for camera D7 line"]
    pub pin_d7: ::std::os::raw::c_int,
    #[doc = "< GPIO pin for camera D6 line"]
    pub pin_d6: ::std::os::raw::c_int,
    #[doc = "< GPIO pin for camera D5 line"]
    pub pin_d5: ::std::os::raw::c_int,
    #[doc = "< GPIO pin for camera D4 line"]
    pub pin_d4: ::std::os::raw::c_int,
    #[doc = "< GPIO pin for camera D3 line"]
    pub pin_d3: ::std::os::raw::c_int,
    #[doc = "< GPIO pin for camera D2 line"]
    pub pin_d2: ::std::os::raw::c_int,
    #[doc = "< GPIO pin for camera D1 line"]
    pub pin_d1: ::std::os::raw::c_int,
    #[doc = "< GPIO pin for camera D0 line"]
    pub pin_d0: ::std::os::raw::c_int,
    #[doc = "< GPIO pin for camera VSYNC line"]
    pub pin_vsync: ::std::os::raw::c_int,
    #[doc = "< GPIO pin for camera HREF line"]
    pub pin_href: ::std::os::raw::c_int,
    #[doc = "< GPIO pin for camera PCLK line"]
    pub pin_pclk: ::std::os::raw::c_int,
    #[doc = "< Frequency of XCLK signal, in Hz. EXPERIMENTAL: Set to 16MHz on ESP32-S2 or ESP32-S3 to enable EDMA mode"]
    pub xclk_freq_hz: ::std::os::raw::c_int,
    #[doc = "< LEDC timer to be used for generating XCLK"]
    pub ledc_timer: ledc_timer_t,
    #[doc = "< LEDC channel to be used for generating XCLK"]
    pub ledc_channel: ledc_channel_t,
    #[doc = "< Format of the pixel data: PIXFORMAT_ + YUV422|GRAYSCALE|RGB565|JPEG"]
    pub pixel_format: pixformat_t,
    #[doc = "< Size of the output image: FRAMESIZE_ + QVGA|CIF|VGA|SVGA|XGA|SXGA|UXGA"]
    pub frame_size: framesize_t,
    #[doc = "< Quality of JPEG output. 0-63 lower means higher quality"]
    pub jpeg_quality: ::std::os::raw::c_int,
    #[doc = "< Number of frame buffers to be allocated. If more than one, then each frame will be acquired (double speed)"]
    pub fb_count: usize,
    #[doc = "< The location where the frame buffer will be allocated"]
    pub fb_location: camera_fb_location_t,
    #[doc = "< When buffers should be filled"]
    pub grab_mode: camera_grab_mode_t,
}
#[test]
fn bindgen_test_layout_camera_config_t() {
    assert_eq!(
        ::std::mem::size_of::<camera_config_t>(),
        104usize,
        concat!("Size of: ", stringify!(camera_config_t))
    );
    assert_eq!(
        ::std::mem::align_of::<camera_config_t>(),
        8usize,
        concat!("Alignment of ", stringify!(camera_config_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_config_t>())).pin_pwdn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_config_t),
            "::",
            stringify!(pin_pwdn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_config_t>())).pin_reset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_config_t),
            "::",
            stringify!(pin_reset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_config_t>())).pin_xclk as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_config_t),
            "::",
            stringify!(pin_xclk)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_config_t>())).pin_sscb_sda as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_config_t),
            "::",
            stringify!(pin_sscb_sda)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_config_t>())).pin_sscb_scl as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_config_t),
            "::",
            stringify!(pin_sscb_scl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_config_t>())).pin_d7 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_config_t),
            "::",
            stringify!(pin_d7)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_config_t>())).pin_d6 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_config_t),
            "::",
            stringify!(pin_d6)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_config_t>())).pin_d5 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_config_t),
            "::",
            stringify!(pin_d5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_config_t>())).pin_d4 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_config_t),
            "::",
            stringify!(pin_d4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_config_t>())).pin_d3 as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_config_t),
            "::",
            stringify!(pin_d3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_config_t>())).pin_d2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_config_t),
            "::",
            stringify!(pin_d2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_config_t>())).pin_d1 as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_config_t),
            "::",
            stringify!(pin_d1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_config_t>())).pin_d0 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_config_t),
            "::",
            stringify!(pin_d0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_config_t>())).pin_vsync as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_config_t),
            "::",
            stringify!(pin_vsync)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_config_t>())).pin_href as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_config_t),
            "::",
            stringify!(pin_href)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_config_t>())).pin_pclk as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_config_t),
            "::",
            stringify!(pin_pclk)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_config_t>())).xclk_freq_hz as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_config_t),
            "::",
            stringify!(xclk_freq_hz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_config_t>())).ledc_timer as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_config_t),
            "::",
            stringify!(ledc_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_config_t>())).ledc_channel as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_config_t),
            "::",
            stringify!(ledc_channel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_config_t>())).pixel_format as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_config_t),
            "::",
            stringify!(pixel_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_config_t>())).frame_size as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_config_t),
            "::",
            stringify!(frame_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_config_t>())).jpeg_quality as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_config_t),
            "::",
            stringify!(jpeg_quality)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_config_t>())).fb_count as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_config_t),
            "::",
            stringify!(fb_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_config_t>())).fb_location as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_config_t),
            "::",
            stringify!(fb_location)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_config_t>())).grab_mode as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_config_t),
            "::",
            stringify!(grab_mode)
        )
    );
}
#[doc = " @brief Data structure of camera frame buffer"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct camera_fb_t {
    #[doc = "< Pointer to the pixel data"]
    pub buf: *mut u8,
    #[doc = "< Length of the buffer in bytes"]
    pub len: usize,
    #[doc = "< Width of the buffer in pixels"]
    pub width: usize,
    #[doc = "< Height of the buffer in pixels"]
    pub height: usize,
    #[doc = "< Format of the pixel data"]
    pub format: pixformat_t,
    #[doc = "< Timestamp since boot of the first DMA buffer of the frame"]
    pub timestamp: timeval,
}
#[test]
fn bindgen_test_layout_camera_fb_t() {
    assert_eq!(
        ::std::mem::size_of::<camera_fb_t>(),
        56usize,
        concat!("Size of: ", stringify!(camera_fb_t))
    );
    assert_eq!(
        ::std::mem::align_of::<camera_fb_t>(),
        8usize,
        concat!("Alignment of ", stringify!(camera_fb_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_fb_t>())).buf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_fb_t),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_fb_t>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_fb_t),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_fb_t>())).width as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_fb_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_fb_t>())).height as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_fb_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_fb_t>())).format as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_fb_t),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<camera_fb_t>())).timestamp as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(camera_fb_t),
            "::",
            stringify!(timestamp)
        )
    );
}
extern "C" {
    #[doc = " @brief Initialize the camera driver"]
    #[doc = ""]
    #[doc = " @note call camera_probe before calling this function"]
    #[doc = ""]
    #[doc = " This function detects and configures camera over I2C interface,"]
    #[doc = " allocates framebuffer and DMA buffers,"]
    #[doc = " initializes parallel I2S input, and sets up DMA descriptors."]
    #[doc = ""]
    #[doc = " Currently this function can only be called once and there is"]
    #[doc = " no way to de-initialize this module."]
    #[doc = ""]
    #[doc = " @param config  Camera configuration parameters"]
    #[doc = ""]
    #[doc = " @return ESP_OK on success"]
    pub fn esp_camera_init(config: *const camera_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Deinitialize the camera driver"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_STATE if the driver hasn't been initialized yet"]
    pub fn esp_camera_deinit() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Obtain pointer to a frame buffer."]
    #[doc = ""]
    #[doc = " @return pointer to the frame buffer"]
    pub fn esp_camera_fb_get() -> *mut camera_fb_t;
}
extern "C" {
    #[doc = " @brief Return the frame buffer to be reused again."]
    #[doc = ""]
    #[doc = " @param fb    Pointer to the frame buffer"]
    pub fn esp_camera_fb_return(fb: *mut camera_fb_t);
}
extern "C" {
    #[doc = " @brief Get a pointer to the image sensor control structure"]
    #[doc = ""]
    #[doc = " @return pointer to the sensor"]
    pub fn esp_camera_sensor_get() -> *mut sensor_t;
}
extern "C" {
    #[doc = " @brief Save camera settings to non-volatile-storage (NVS)"]
    #[doc = ""]
    #[doc = " @param key   A unique nvs key name for the camera settings"]
    pub fn esp_camera_save_to_nvs(key: *const ::std::os::raw::c_char) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Load camera settings from non-volatile-storage (NVS)"]
    #[doc = ""]
    #[doc = " @param key   A unique nvs key name for the camera settings"]
    pub fn esp_camera_load_from_nvs(key: *const ::std::os::raw::c_char) -> esp_err_t;
}
pub const jpg_scale_t_JPG_SCALE_NONE: jpg_scale_t = 0;
pub const jpg_scale_t_JPG_SCALE_2X: jpg_scale_t = 1;
pub const jpg_scale_t_JPG_SCALE_4X: jpg_scale_t = 2;
pub const jpg_scale_t_JPG_SCALE_8X: jpg_scale_t = 3;
pub const jpg_scale_t_JPG_SCALE_MAX: jpg_scale_t = 3;
pub type jpg_scale_t = u32;
pub type jpg_reader_cb = ::std::option::Option<
    unsafe extern "C" fn(
        arg: *mut ::std::os::raw::c_void,
        index: usize,
        buf: *mut u8,
        len: usize,
    ) -> usize,
>;
pub type jpg_writer_cb = ::std::option::Option<
    unsafe extern "C" fn(
        arg: *mut ::std::os::raw::c_void,
        x: u16,
        y: u16,
        w: u16,
        h: u16,
        data: *mut u8,
    ) -> bool,
>;
extern "C" {
    pub fn esp_jpg_decode(
        len: usize,
        scale: jpg_scale_t,
        reader: jpg_reader_cb,
        writer: jpg_writer_cb,
        arg: *mut ::std::os::raw::c_void,
    ) -> esp_err_t;
}
pub type jpg_out_cb = ::std::option::Option<
    unsafe extern "C" fn(
        arg: *mut ::std::os::raw::c_void,
        index: usize,
        data: *const ::std::os::raw::c_void,
        len: usize,
    ) -> usize,
>;
extern "C" {
    #[doc = " @brief Convert image buffer to JPEG"]
    #[doc = ""]
    #[doc = " @param src       Source buffer in RGB565, RGB888, YUYV or GRAYSCALE format"]
    #[doc = " @param src_len   Length in bytes of the source buffer"]
    #[doc = " @param width     Width in pixels of the source image"]
    #[doc = " @param height    Height in pixels of the source image"]
    #[doc = " @param format    Format of the source image"]
    #[doc = " @param quality   JPEG quality of the resulting image"]
    #[doc = " @param cp        Callback to be called to write the bytes of the output JPEG"]
    #[doc = " @param arg       Pointer to be passed to the callback"]
    #[doc = ""]
    #[doc = " @return true on success"]
    pub fn fmt2jpg_cb(
        src: *mut u8,
        src_len: usize,
        width: u16,
        height: u16,
        format: pixformat_t,
        quality: u8,
        cb: jpg_out_cb,
        arg: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Convert camera frame buffer to JPEG"]
    #[doc = ""]
    #[doc = " @param fb        Source camera frame buffer"]
    #[doc = " @param quality   JPEG quality of the resulting image"]
    #[doc = " @param cp        Callback to be called to write the bytes of the output JPEG"]
    #[doc = " @param arg       Pointer to be passed to the callback"]
    #[doc = ""]
    #[doc = " @return true on success"]
    pub fn frame2jpg_cb(
        fb: *mut camera_fb_t,
        quality: u8,
        cb: jpg_out_cb,
        arg: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Convert image buffer to JPEG buffer"]
    #[doc = ""]
    #[doc = " @param src       Source buffer in RGB565, RGB888, YUYV or GRAYSCALE format"]
    #[doc = " @param src_len   Length in bytes of the source buffer"]
    #[doc = " @param width     Width in pixels of the source image"]
    #[doc = " @param height    Height in pixels of the source image"]
    #[doc = " @param format    Format of the source image"]
    #[doc = " @param quality   JPEG quality of the resulting image"]
    #[doc = " @param out       Pointer to be populated with the address of the resulting buffer."]
    #[doc = "                  You MUST free the pointer once you are done with it."]
    #[doc = " @param out_len   Pointer to be populated with the length of the output buffer"]
    #[doc = ""]
    #[doc = " @return true on success"]
    pub fn fmt2jpg(
        src: *mut u8,
        src_len: usize,
        width: u16,
        height: u16,
        format: pixformat_t,
        quality: u8,
        out: *mut *mut u8,
        out_len: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Convert camera frame buffer to JPEG buffer"]
    #[doc = ""]
    #[doc = " @param fb        Source camera frame buffer"]
    #[doc = " @param quality   JPEG quality of the resulting image"]
    #[doc = " @param out       Pointer to be populated with the address of the resulting buffer"]
    #[doc = " @param out_len   Pointer to be populated with the length of the output buffer"]
    #[doc = ""]
    #[doc = " @return true on success"]
    pub fn frame2jpg(
        fb: *mut camera_fb_t,
        quality: u8,
        out: *mut *mut u8,
        out_len: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Convert image buffer to BMP buffer"]
    #[doc = ""]
    #[doc = " @param src       Source buffer in JPEG, RGB565, RGB888, YUYV or GRAYSCALE format"]
    #[doc = " @param src_len   Length in bytes of the source buffer"]
    #[doc = " @param width     Width in pixels of the source image"]
    #[doc = " @param height    Height in pixels of the source image"]
    #[doc = " @param format    Format of the source image"]
    #[doc = " @param out       Pointer to be populated with the address of the resulting buffer"]
    #[doc = " @param out_len   Pointer to be populated with the length of the output buffer"]
    #[doc = ""]
    #[doc = " @return true on success"]
    pub fn fmt2bmp(
        src: *mut u8,
        src_len: usize,
        width: u16,
        height: u16,
        format: pixformat_t,
        out: *mut *mut u8,
        out_len: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Convert camera frame buffer to BMP buffer"]
    #[doc = ""]
    #[doc = " @param fb        Source camera frame buffer"]
    #[doc = " @param out       Pointer to be populated with the address of the resulting buffer"]
    #[doc = " @param out_len   Pointer to be populated with the length of the output buffer"]
    #[doc = ""]
    #[doc = " @return true on success"]
    pub fn frame2bmp(fb: *mut camera_fb_t, out: *mut *mut u8, out_len: *mut usize) -> bool;
}
extern "C" {
    #[doc = " @brief Convert image buffer to RGB888 buffer (used for face detection)"]
    #[doc = ""]
    #[doc = " @param src       Source buffer in JPEG, RGB565, RGB888, YUYV or GRAYSCALE format"]
    #[doc = " @param src_len   Length in bytes of the source buffer"]
    #[doc = " @param format    Format of the source image"]
    #[doc = " @param rgb_buf   Pointer to the output buffer (width * height * 3)"]
    #[doc = ""]
    #[doc = " @return true on success"]
    pub fn fmt2rgb888(
        src_buf: *const u8,
        src_len: usize,
        format: pixformat_t,
        rgb_buf: *mut u8,
    ) -> bool;
}
extern "C" {
    pub fn jpg2rgb565(src: *const u8, src_len: usize, out: *mut u8, scale: jpg_scale_t) -> bool;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
